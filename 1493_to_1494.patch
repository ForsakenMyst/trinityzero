diff --git a/src/bindings/scripts/include/sc_gossip.h b/src/bindings/scripts/include/sc_gossip.h
--- a/src/bindings/scripts/include/sc_gossip.h
+++ b/src/bindings/scripts/include/sc_gossip.h
@@ -36,8 +36,6 @@
 #define GOSSIP_TEXT_ALTERACVALLEY       "Alterac Valley"
 #define GOSSIP_TEXT_ARATHIBASIN         "Arathi Basin"
 #define GOSSIP_TEXT_WARSONGULCH         "Warsong Gulch"
-#define GOSSIP_TEXT_ARENA               "Arena"
-#define GOSSIP_TEXT_EYEOFTHESTORM       "Eye of The Storm"
 
 #define GOSSIP_TEXT_DRUID               "Druid"
 #define GOSSIP_TEXT_HUNTER              "Hunter"
diff --git a/src/bindings/scripts/scripts/guard/guards.cpp b/src/bindings/scripts/scripts/guard/guards.cpp
--- a/src/bindings/scripts/scripts/guard/guards.cpp
+++ b/src/bindings/scripts/scripts/guard/guards.cpp
@@ -66,7 +66,6 @@
 #define GOSSIP_TEXT_STABLEALDOR               "Aldor Stable"
 #define GOSSIP_TEXT_BATTLEMASTERALLIANCE      "Alliance Battlemasters"
 #define GOSSIP_TEXT_BATTLEMASTERHORDE         "Horde Battlemasters"
-#define GOSSIP_TEXT_BATTLEMASTERARENA         "Arena Battlemasters"
 #define GOSSIP_TEXT_MANALOOM                  "Mana Loom"
 #define GOSSIP_TEXT_ALCHEMYLAB                "Alchemy Lab"
 #define GOSSIP_TEXT_GEMMERCHANT               "Gem Merchant"
@@ -1438,8 +1437,6 @@
         case GOSSIP_ACTION_INFO_DEF + 9:                    //Battlemaster
             player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_ALTERACVALLEY       , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 1);
             player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_ARATHIBASIN         , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 2);
-            player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_ARENA               , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 3);
-            player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_EYEOFTHESTORM       , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 4);
             player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_WARSONGULCH         , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 5);
             player->SEND_GOSSIP_MENU(9531, _Creature->GetGUID());
             break;
@@ -2295,7 +2292,6 @@
         case GOSSIP_ACTION_INFO_DEF + 7:                    //Battlemaster
             player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_BATTLEMASTERALLIANCE , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 1);
             player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_BATTLEMASTERHORDE    , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 2);
-            player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_BATTLEMASTERARENA    , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 3);
             player->SEND_GOSSIP_MENU(10388, _Creature->GetGUID());
             break;
         case GOSSIP_ACTION_INFO_DEF + 8:                    //Profession master
@@ -2402,10 +2398,6 @@
             player->SEND_POI(-1963, 5263, 6, 6, 0, "Horde Battlemasters");
             player->SEND_GOSSIP_MENU(10390,  _Creature->GetGUID());
             break;
-        case GOSSIP_ACTION_INFO_DEF + 3:
-            player->SEND_POI(-1960, 5175, 6, 6, 0, "Arena Battlemasters");
-            player->SEND_GOSSIP_MENU(12510,  _Creature->GetGUID());
-            break;
     }
 }
 
@@ -2600,7 +2592,6 @@
         case GOSSIP_ACTION_INFO_DEF + 7:                    //Battlemaster
             player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_BATTLEMASTERALLIANCE , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 1);
             player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_BATTLEMASTERHORDE    , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 2);
-            player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_BATTLEMASTERARENA    , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 3);
             player->SEND_GOSSIP_MENU(10388, _Creature->GetGUID());
             break;
         case GOSSIP_ACTION_INFO_DEF + 8:                    //Profession master
@@ -2795,7 +2786,6 @@
         case GOSSIP_ACTION_INFO_DEF + 7:                    //Battlemaster
             player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_BATTLEMASTERALLIANCE , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 1);
             player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_BATTLEMASTERHORDE    , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 2);
-            player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_BATTLEMASTERARENA    , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 3);
             player->SEND_GOSSIP_MENU(10438, _Creature->GetGUID());
             break;
         case GOSSIP_ACTION_INFO_DEF + 8:                    //Profession master
@@ -2945,8 +2935,6 @@
         case GOSSIP_ACTION_INFO_DEF + 9:                    //Battlemaster
             player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_ALTERACVALLEY   , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 1);
             player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_ARATHIBASIN     , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 2);
-            player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_ARENA           , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 3);
-            player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_EYEOFTHESTORM   , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 4);
             player->ADD_GOSSIP_ITEM( 0, GOSSIP_TEXT_WARSONGULCH     , GOSSIP_SENDER_SEC_BATTLEINFO, GOSSIP_ACTION_INFO_DEF + 5);
             player->SEND_GOSSIP_MENU(9329, _Creature->GetGUID());
             break;
diff --git a/src/game/Bag.cpp b/src/game/Bag.cpp
--- a/src/game/Bag.cpp
+++ b/src/game/Bag.cpp
@@ -194,16 +194,6 @@
             count += pItem->GetCount();
     }
 
-    if(eItem && eItem->GetProto()->GemProperties)
-    {
-        for(uint32 i=0; i < GetBagSize(); ++i)
-        {
-            pItem = m_bagslot[i];
-            if( pItem && pItem != eItem && pItem->GetProto()->Socket[0].Color )
-                count += pItem->GetGemCountWithID(item);
-        }
-    }
-
     return count;
 }
 
diff --git a/src/game/BattleGround.cpp b/src/game/BattleGround.cpp
--- a/src/game/BattleGround.cpp
+++ b/src/game/BattleGround.cpp
@@ -40,8 +40,6 @@
     m_Queue_type        = MAX_BATTLEGROUND_QUEUES;
     m_InvitedAlliance   = 0;
     m_InvitedHorde      = 0;
-    m_ArenaType         = 0;
-    m_IsArena           = false;
     m_Winner            = 2;
     m_StartTime         = 0;
     m_Events            = 0;
@@ -45,7 +43,6 @@
     m_Winner            = 2;
     m_StartTime         = 0;
     m_Events            = 0;
-    m_IsRated           = false;
     m_BuffChange        = false;
     m_Name              = "";
     m_LevelMin          = 0;
@@ -72,12 +69,6 @@
     m_TeamStartLocO[BG_TEAM_ALLIANCE]   = 0;
     m_TeamStartLocO[BG_TEAM_HORDE]      = 0;
 
-    m_ArenaTeamIds[BG_TEAM_ALLIANCE]   = 0;
-    m_ArenaTeamIds[BG_TEAM_HORDE]      = 0;
-
-    m_ArenaTeamRatingChanges[BG_TEAM_ALLIANCE]   = 0;
-    m_ArenaTeamRatingChanges[BG_TEAM_HORDE]      = 0;
-
     m_BgRaids[BG_TEAM_ALLIANCE]         = NULL;
     m_BgRaids[BG_TEAM_HORDE]            = NULL;
 
@@ -114,7 +105,7 @@
     sBattleGroundMgr.RemoveBattleGround(GetInstanceID());
     // unload map
     if(Map * map = MapManager::Instance().FindMap(GetMapId(), GetInstanceID()))
-        if(map->IsBattleGroundOrArena())
+        if(map->IsBattleGround())
             ((BattleGroundMap*)map)->SetUnload();
     // remove from bg free slot queue
     this->RemoveFromBGFreeSlotQueue();
@@ -229,7 +220,7 @@
     }
 
     // if less then minimum players are in on one side, then start premature finish timer
-    if(GetStatus() == STATUS_IN_PROGRESS && !isArena() && sBattleGroundMgr.GetPrematureFinishTime() && (GetPlayersCountByTeam(ALLIANCE) < GetMinPlayersPerTeam() || GetPlayersCountByTeam(HORDE) < GetMinPlayersPerTeam()))
+    if(GetStatus() == STATUS_IN_PROGRESS  && sBattleGroundMgr.GetPrematureFinishTime() && (GetPlayersCountByTeam(ALLIANCE) < GetMinPlayersPerTeam() || GetPlayersCountByTeam(HORDE) < GetMinPlayersPerTeam()))
     {
         if(!m_PrematureCountDown)
         {
@@ -446,8 +437,6 @@
 {
     this->RemoveFromBGFreeSlotQueue();
     uint32 almost_winning_team = HORDE;
-    ArenaTeam * winner_arena_team = NULL;
-    ArenaTeam * loser_arena_team = NULL;
     uint32 loser_rating = 0;
     uint32 winner_rating = 0;
     WorldPacket data;
@@ -456,10 +445,7 @@
 
     if(winner == ALLIANCE)
     {
-        if(isBattleGround())
-            winmsg = GetTrinityString(LANG_BG_A_WINS);
-        else
-            winmsg = GetTrinityString(LANG_ARENA_GOLD_WINS);
+        winmsg = GetTrinityString(LANG_BG_A_WINS);
 
         PlaySoundToAll(SOUND_ALLIANCE_WINS);                // alliance wins sound
 
@@ -467,10 +453,7 @@
     }
     else if(winner == HORDE)
     {
-        if(isBattleGround())
-            winmsg = GetTrinityString(LANG_BG_H_WINS);
-        else
-            winmsg = GetTrinityString(LANG_ARENA_GREEN_WINS);
+        winmsg = GetTrinityString(LANG_BG_H_WINS);
 
         PlaySoundToAll(SOUND_HORDE_WINS);                   // horde wins sound
 
@@ -484,54 +467,6 @@
     SetStatus(STATUS_WAIT_LEAVE);
     m_EndTime = 0;
 
-    // arena rating calculation
-/*  [TRINITYROLLBACK]
-if(isArena() && isRated())
-    {
-        if(winner == ALLIANCE)
-        {
-            winner_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(ALLIANCE));
-            loser_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(HORDE));
-        }
-        else if(winner == HORDE)
-        {
-            winner_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(HORDE));
-            loser_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(ALLIANCE));
-        }
-        if(winner_arena_team && loser_arena_team)
-        {
-            loser_rating = loser_arena_team->GetStats().rating;
-            winner_rating = winner_arena_team->GetStats().rating;
-            int32 winner_change = winner_arena_team->WonAgainst(loser_rating);
-            int32 loser_change = loser_arena_team->LostAgainst(winner_rating);
-            sLog.outDebug("--- Winner rating: %u, Loser rating: %u, Winner change: %u, Losser change: %u ---", winner_rating, loser_rating, winner_change, loser_change);
-            if(winner == ALLIANCE)
-            {
-                SetArenaTeamRatingChangeForTeam(ALLIANCE, winner_change);
-                SetArenaTeamRatingChangeForTeam(HORDE, loser_change);
-            }
-            else
-            {
-                SetArenaTeamRatingChangeForTeam(HORDE, winner_change);
-                SetArenaTeamRatingChangeForTeam(ALLIANCE, loser_change);
-            }
-        }
-        else
-        {
-            SetArenaTeamRatingChangeForTeam(ALLIANCE, 0);
-            SetArenaTeamRatingChangeForTeam(HORDE, 0);
-        }
-    }
-
-    if(!isArena()){
-
-    if(m_score[GetTeamIndexByTeamId(ALLIANCE)] == m_score[GetTeamIndexByTeamId(HORDE)])
-        almost_winning_team = 0;         //no real winner
-    if(m_score[GetTeamIndexByTeamId(ALLIANCE)] > m_score[GetTeamIndexByTeamId(HORDE)])
-        almost_winning_team = ALLIANCE;
-
-    } */
-
     for(std::map<uint64, BattleGroundPlayer>::iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
     {
         Player *plr = objmgr.GetPlayer(itr->first);
@@ -554,15 +489,6 @@
         uint32 team = itr->second.Team;
         if(!team) team = plr->GetTeam();
 
-        // per player calculation
-   /* [TRINITYROLLBACK]   
-   if(isArena() && isRated() && winner_arena_team && loser_arena_team)
-        {
-            if(team == winner)
-                winner_arena_team->MemberWon(plr,loser_rating);
-            else
-                loser_arena_team->MemberLost(plr,winner_rating);
-        } */
 
         if(team == winner)
         {
@@ -595,8 +521,8 @@
         sBattleGroundMgr.BuildPvpLogDataPacket(&data, this);
         plr->GetSession()->SendPacket(&data);
 
-        uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(GetTypeID(), GetArenaType());
+        uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(GetTypeID());
         sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, this, plr->GetTeam(), plr->GetBattleGroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, TIME_TO_AUTOREMOVE, GetStartTime());
         plr->GetSession()->SendPacket(&data);
     }
 
@@ -599,21 +525,5 @@
         sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, this, plr->GetTeam(), plr->GetBattleGroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, TIME_TO_AUTOREMOVE, GetStartTime());
         plr->GetSession()->SendPacket(&data);
     }
 
-  /* [TRINITYROLLBACK] 
-  if(isArena() && isRated() && winner_arena_team && loser_arena_team)
-    {
-        // update arena points only after increasing the player's match count!
-        //obsolete: winner_arena_team->UpdateArenaPointsHelper();
-        //obsolete: loser_arena_team->UpdateArenaPointsHelper();
-        // save the stat changes
-        winner_arena_team->SaveToDB();
-        loser_arena_team->SaveToDB();
-        // send updated arena team stats to players
-        // this way all arena team members will get notified, not only the ones who participated in this match
-        winner_arena_team->NotifyStatsChanged();
-        loser_arena_team->NotifyStatsChanged();
-    sLog.outDebug("Rated arena match between %s and %s finished, winner: %s", loser_arena_team->GetName().c_str(),winner_arena_team->GetName().c_str(),winner_arena_team->GetName().c_str());
-    } */
-
     // inform invited players about the removal
@@ -619,5 +529,5 @@
     // inform invited players about the removal
-    sBattleGroundMgr.m_BattleGroundQueues[sBattleGroundMgr.BGQueueTypeId(GetTypeID(), GetArenaType())].BGEndedRemoveInvites(this);
+    sBattleGroundMgr.m_BattleGroundQueues[sBattleGroundMgr.BGQueueTypeId(GetTypeID())].BGEndedRemoveInvites(this);
 
     if(Source)
     {
@@ -633,8 +543,6 @@
         case BATTLEGROUND_AV: return 15972;
         case BATTLEGROUND_WS: return 14623;
         case BATTLEGROUND_AB: return 14879;
-        case BATTLEGROUND_EY: return 22516;
-        case BATTLEGROUND_NA: return 20200;
         default:              return 0;
     }
 }
@@ -660,9 +568,6 @@
         case BATTLEGROUND_AB:
             mark = ITEM_AB_MARK_OF_HONOR;
             break;
-        case BATTLEGROUND_EY:            
-            mark = ITEM_EY_MARK_OF_HONOR;
-            break;
         default:
             return;
     }
@@ -739,9 +644,6 @@
         case BATTLEGROUND_AB:
             quest = SPELL_AB_QUEST_REWARD;
             break;
-        case BATTLEGROUND_EY:
-            quest = SPELL_EY_QUEST_REWARD;
-            break;
         default:
             return;
     }
@@ -800,45 +702,7 @@
             if(!team) team = plr->GetTeam();
 
             uint32 bgTypeId = GetTypeID();
-            uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(GetTypeID(), GetArenaType());
-            // if arena, remove the specific arena auras
-      /*   [TRINITYROLLBACK]  
-	  if(isArena())
-            {
-                plr->RemoveArenaAuras(true);    // removes debuffs / dots etc., we don't want the player to die after porting out
-                bgTypeId=BATTLEGROUND_AA;       // set the bg type to all arenas (it will be used for queue refreshing)
-
-                // summon old pet if there was one and there isn't a current pet
-                if(!plr->GetPet() && plr->GetTemporaryUnsummonedPetNumber())
-                {
-                    Pet* NewPet = new Pet;
-                    if(!NewPet->LoadPetFromDB(plr, 0, (plr)->GetTemporaryUnsummonedPetNumber(), true))
-                        delete NewPet;
-
-                    (plr)->SetTemporaryUnsummonedPetNumber(0);
-                }
-
-                if(isRated() && GetStatus() == STATUS_IN_PROGRESS)
-                {
-                    //left a rated match while the encounter was in progress, consider as loser
-                    ArenaTeam * winner_arena_team = 0;
-                    ArenaTeam * loser_arena_team = 0;
-                    if(team == HORDE)
-                    {
-                        winner_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(ALLIANCE));
-                        loser_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(HORDE));
-                    }
-                    else
-                    {
-                        winner_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(HORDE));
-                        loser_arena_team = objmgr.GetArenaTeamById(GetArenaTeamIdForTeam(ALLIANCE));
-                    }
-                    if(winner_arena_team && loser_arena_team)
-                    {
-                        loser_arena_team->MemberLost(plr,winner_arena_team->GetRating());
-                    }
-                }
-            } */
+            uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(GetTypeID());
 
             WorldPacket data;
             if(SendPacket)
@@ -907,8 +771,6 @@
     SetStartTime(0);
     SetEndTime(0);
     SetLastResurrectTime(0);
-    SetArenaType(0);
-    SetRated(false);
 
     m_Events = 0;
 
@@ -954,55 +816,8 @@
     sBattleGroundMgr.BuildPlayerJoinedBattleGroundPacket(&data, plr);
     SendPacketToTeam(team, &data, plr, false);
 
-    // add arena specific auras
-    if(isArena())
-    {
-        plr->RemoveArenaSpellCooldowns();
-        plr->RemoveArenaAuras();
-        plr->RemoveAllEnchantments(TEMP_ENCHANTMENT_SLOT);
-        if(team == ALLIANCE)                                // gold
-        {
-            if(plr->GetTeam() == HORDE)
-                plr->CastSpell(plr, SPELL_HORDE_GOLD_FLAG,true);
-            else
-                plr->CastSpell(plr, SPELL_ALLIANCE_GOLD_FLAG,true);
-        }
-        else                                                // green
-        {
-            if(plr->GetTeam() == HORDE)
-                plr->CastSpell(plr, SPELL_HORDE_GREEN_FLAG,true);
-            else
-                plr->CastSpell(plr, SPELL_ALLIANCE_GREEN_FLAG,true);
-        }
-
-        plr->DestroyConjuredItems(true);
-
-        Pet* pet = plr->GetPet();
-        if(pet)
-        {
-            if(pet->getPetType() == SUMMON_PET || pet->getPetType() == HUNTER_PET)
-            {
-                (plr)->SetTemporaryUnsummonedPetNumber(pet->GetCharmInfo()->GetPetNumber());
-                (plr)->SetOldPetSpell(pet->GetUInt32Value(UNIT_CREATED_BY_SPELL));
-            }
-            (plr)->RemovePet(NULL,PET_SAVE_NOT_IN_SLOT);
-        }
-    else
-            (plr)->SetTemporaryUnsummonedPetNumber(0);
-
-        if(GetStatus() == STATUS_WAIT_JOIN)                 // not started yet
-        {
-            plr->CastSpell(plr, SPELL_ARENA_PREPARATION, true);
-
-            plr->SetHealth(plr->GetMaxHealth());
-            plr->SetPower(POWER_MANA, plr->GetMaxPower(POWER_MANA));
-        }
-    }
-    else
-    {
-        if(GetStatus() == STATUS_WAIT_JOIN)                 // not started yet
-            plr->CastSpell(plr, SPELL_PREPARATION, true);   // reduces all mana cost of spells.
-    }
+    if(GetStatus() == STATUS_WAIT_JOIN)                 // not started yet
+         plr->CastSpell(plr, SPELL_PREPARATION, true);   // reduces all mana cost of spells.
 
     // Log
     sLog.outDetail("BATTLEGROUND: Player %s joined the battle.", plr->GetName());
@@ -1120,10 +935,7 @@
             itr->second->HonorableKills += value;
             break;
         case SCORE_BONUS_HONOR:                             // Honor bonus
-            // do not add honor in arenas
-            if(isBattleGround())
-            {
                /* [TRINITYROLLBACK] to replace?
 			   // reward honor instantly
                 if(Source->RewardHonor(NULL, 1, value))
                     itr->second->BonusHonor += value; */
@@ -1126,8 +938,7 @@
                /* [TRINITYROLLBACK] to replace?
 			   // reward honor instantly
                 if(Source->RewardHonor(NULL, 1, value))
                     itr->second->BonusHonor += value; */
-            }
             break;
             //used only in EY, but in MSG_PVP_LOG_DATA opcode
         case SCORE_DAMAGE_DONE:                             // Damage Done
@@ -1454,7 +1265,7 @@
     SetStatus(STATUS_WAIT_LEAVE);
     SetEndTime(TIME_TO_AUTOREMOVE);
     // inform invited players about the removal
-    sBattleGroundMgr.m_BattleGroundQueues[sBattleGroundMgr.BGQueueTypeId(GetTypeID(), GetArenaType())].BGEndedRemoveInvites(this);
+    sBattleGroundMgr.m_BattleGroundQueues[sBattleGroundMgr.BGQueueTypeId(GetTypeID())].BGEndedRemoveInvites(this);
 }
 
 // Battleground messages are localized using the dbc lang, they are not client language dependent
@@ -1506,8 +1317,6 @@
 
 void BattleGround::HandleKillPlayer( Player *player, Player *killer )
 {
-    //keep in mind that for arena this will have to be changed a bit
-
     // add +1 deaths
     UpdatePlayerScore(player, SCORE_DEATHS, 1);
 
diff --git a/src/game/BattleGround.h b/src/game/BattleGround.h
--- a/src/game/BattleGround.h
+++ b/src/game/BattleGround.h
@@ -68,7 +68,6 @@
     SPELL_SPIRIT_HEAL_CHANNEL       = 22011,                // Spirit Heal Channel
     SPELL_SPIRIT_HEAL               = 22012,                // Spirit Heal
     SPELL_RESURRECTION_VISUAL       = 24171,                // Resurrection Impact Visual
-    SPELL_ARENA_PREPARATION         = 32727,                // use this one, 32728 not correct
     SPELL_ALLIANCE_GOLD_FLAG        = 32724,
     SPELL_ALLIANCE_GREEN_FLAG       = 32725,
     SPELL_HORDE_GOLD_FLAG           = 35774,
@@ -89,7 +88,6 @@
     START_DELAY0                    = 120000,               // ms
     START_DELAY1                    = 60000,                // ms
     START_DELAY2                    = 30000,                // ms
-    START_DELAY3                    = 15000,                // ms used only in arena
     RESPAWN_ONE_DAY                 = 86400,                // secs
     RESPAWN_IMMEDIATELY             = 0,                    // secs
     BUFF_RESPAWN_TIME               = 180,                  // secs
@@ -136,11 +134,6 @@
     BATTLEGROUND_AV     = 1,
     BATTLEGROUND_WS     = 2,
     BATTLEGROUND_AB     = 3,
-    BATTLEGROUND_NA     = 4,
-    BATTLEGROUND_BE     = 5,
-    BATTLEGROUND_AA     = 6,
-    BATTLEGROUND_EY     = 7,
-    BATTLEGROUND_RL     = 8
 };
 
 // handle the queue types and bg types separately to enable joining queue for different sized arenas at the same time
@@ -149,10 +142,6 @@
     BATTLEGROUND_QUEUE_AV     = 1,
     BATTLEGROUND_QUEUE_WS     = 2,
     BATTLEGROUND_QUEUE_AB     = 3,
-    BATTLEGROUND_QUEUE_EY     = 4,
-    BATTLEGROUND_QUEUE_2v2     = 5,
-    BATTLEGROUND_QUEUE_3v3     = 6,
-    BATTLEGROUND_QUEUE_5v5     = 7,
 };
 
 enum ScoreType
@@ -181,13 +170,6 @@
     // TODO : implement them
 };
 
-enum ArenaType
-{
-    ARENA_TYPE_2v2          = 2,
-    ARENA_TYPE_3v3          = 3,
-    ARENA_TYPE_5v5          = 5
-};
-
 enum BattleGroundType
 {
     TYPE_BATTLEGROUND     = 3,
@@ -191,7 +173,6 @@
 enum BattleGroundType
 {
     TYPE_BATTLEGROUND     = 3,
-    TYPE_ARENA            = 4
 };
 
 enum BattleGroundWinner
@@ -214,7 +195,6 @@
     BG_JOIN_ERR_GROUP_TOO_MANY = 2,
     BG_JOIN_ERR_MIXED_FACTION = 3,
     BG_JOIN_ERR_MIXED_LEVELS = 4,
-    BG_JOIN_ERR_MIXED_ARENATEAM = 5,
     BG_JOIN_ERR_GROUP_MEMBER_ALREADY_IN_QUEUE = 6,
     BG_JOIN_ERR_GROUP_DESERTER = 7,
     BG_JOIN_ERR_ALL_QUEUES_USED = 8,
@@ -289,7 +269,6 @@
         uint32 GetMinPlayersPerTeam() const { return m_MinPlayersPerTeam; }
 
         int GetStartDelayTime() const       { return m_StartDelayTime; }
-        uint8 GetArenaType() const          { return m_ArenaType; }
         uint8 GetWinner() const             { return m_Winner; }
         uint32 GetBattlemasterEntry() const;
 
@@ -305,9 +284,6 @@
         void SetMaxPlayers(uint32 MaxPlayers) { m_MaxPlayers = MaxPlayers; }
         void SetMinPlayers(uint32 MinPlayers) { m_MinPlayers = MinPlayers; }
         void SetLevelRange(uint32 min, uint32 max) { m_LevelMin = min; m_LevelMax = max; }
-        void SetRated(bool state)           { m_IsRated = state; }
-        void SetArenaType(uint8 type)       { m_ArenaType = type; }
-        void SetArenaorBGType(bool _isArena) { m_IsArena = _isArena; }
         void SetWinner(uint8 winner)        { m_Winner = winner; }
 
         void ModifyStartDelayTime(int diff) { m_StartDelayTime -= diff; }
@@ -332,10 +308,6 @@
         bool HasFreeSlots() const;
         uint32 GetFreeSlotsForTeam(uint32 Team) const;
 
-        bool isArena() const        { return m_IsArena; }
-        bool isBattleGround() const { return !m_IsArena; }
-        bool isRated() const        { return m_IsRated; }
-
         typedef std::map<uint64, BattleGroundPlayer> BattleGroundPlayerMap;
         BattleGroundPlayerMap const& GetPlayers() const { return m_Players; }
         uint32 GetPlayersSize() const { return m_Players.size(); }
@@ -404,7 +376,7 @@
 
         uint8 GetTeamIndexByTeamId(uint32 Team) const { return Team == ALLIANCE ? BG_TEAM_ALLIANCE : BG_TEAM_HORDE; }
         uint32 GetPlayersCountByTeam(uint32 Team) const { return m_PlayersCount[GetTeamIndexByTeamId(Team)]; }
-        uint32 GetAlivePlayersCountByTeam(uint32 Team) const;   // used in arenas to correctly handle death in spirit of redemption / last stand etc. (killer = killed) cases
+        uint32 GetAlivePlayersCountByTeam(uint32 Team) const;   //[TRINITYROLLBACK] used in arenas to correctly handle death in spirit of redemption / last stand etc. (killer = killed) cases
         void UpdatePlayersCountByTeam(uint32 Team, bool remove)
         {
             if(remove)
@@ -413,10 +385,4 @@
                 ++m_PlayersCount[GetTeamIndexByTeamId(Team)];
         }
 
-        // used for rated arena battles
-        void SetArenaTeamIdForTeam(uint32 Team, uint32 ArenaTeamId) { m_ArenaTeamIds[GetTeamIndexByTeamId(Team)] = ArenaTeamId; }
-        uint32 GetArenaTeamIdForTeam(uint32 Team) const { return m_ArenaTeamIds[GetTeamIndexByTeamId(Team)]; }
-        void SetArenaTeamRatingChangeForTeam(uint32 Team, int32 RatingChange) { m_ArenaTeamRatingChanges[GetTeamIndexByTeamId(Team)] = RatingChange; }
-        int32 GetArenaTeamRatingChangeForTeam(uint32 Team) const { return m_ArenaTeamRatingChanges[GetTeamIndexByTeamId(Team)]; }
-
         /* Triggers handle */
@@ -422,7 +388,5 @@
         /* Triggers handle */
-        // must be implemented in BG subclass
-        virtual void HandleAreaTrigger(Player* /*Source*/, uint32 /*Trigger*/) {}
         // must be implemented in BG subclass if need AND call base class generic code
         virtual void HandleKillPlayer(Player *player, Player *killer);
         virtual void HandleKillUnit(Creature* /*unit*/, Player* /*killer*/);
 
@@ -425,7 +389,9 @@
         // must be implemented in BG subclass if need AND call base class generic code
         virtual void HandleKillPlayer(Player *player, Player *killer);
         virtual void HandleKillUnit(Creature* /*unit*/, Player* /*killer*/);
 
+		// must be implemented in BG subclass
+        virtual void HandleAreaTrigger(Player* /*Source*/, uint32 /*Trigger*/) {}
         /* Battleground events */
         /* these functions will return true event is possible, but false if player is bugger */
         virtual void EventPlayerDroppedFlag(Player* /*player*/) {}
@@ -463,7 +429,6 @@
 
         virtual bool HandlePlayerUnderMap(Player * plr) {return false;}
 
-        // since arenas can be AvA or Hvh, we have to get the "temporary" team of a player
         uint32 GetPlayerTeam(uint64 guid);
 
         void SetDeleteThis() {m_SetDeleteThis = true;}
@@ -501,7 +466,6 @@
         uint32 m_EndTime;
         uint32 m_LastResurrectTime;
         uint32 m_Queue_type;
-        uint8  m_ArenaType;                                 // 2=2v2, 3=3v3, 5=5v5
         bool   m_InBGFreeSlotQueue;                         // used to make sure that BG is only once inserted into the BattleGroundMgr.BGFreeSlotQueue[bgTypeId] deque
         bool   m_SetDeleteThis;                             // used for safe deletion of the bg after end / all players leave
         // this variable is not used .... it can be found in many other ways... but to store it in BG object instance is useless
@@ -505,5 +469,5 @@
         bool   m_InBGFreeSlotQueue;                         // used to make sure that BG is only once inserted into the BattleGroundMgr.BGFreeSlotQueue[bgTypeId] deque
         bool   m_SetDeleteThis;                             // used for safe deletion of the bg after end / all players leave
         // this variable is not used .... it can be found in many other ways... but to store it in BG object instance is useless
-        //uint8  m_BattleGroundType;                        // 3=BG, 4=arena
+        //uint8  m_BattleGroundType;                        // 3=BG
         //instead of uint8 (in previous line) is bool used
@@ -509,4 +473,3 @@
         //instead of uint8 (in previous line) is bool used
-        bool   m_IsArena;
         uint8  m_Winner;                                    // 0=alliance, 1=horde, 2=none
         int32  m_StartDelayTime;
@@ -511,6 +474,5 @@
         uint8  m_Winner;                                    // 0=alliance, 1=horde, 2=none
         int32  m_StartDelayTime;
-        bool   m_IsRated;                                   // is this battle rated?
         bool   m_PrematureCountDown;
         uint32 m_PrematureCountDownTimer;
         char const *m_Name;
@@ -532,11 +494,6 @@
         /* Players count by team */
         uint32 m_PlayersCount[2];
 
-        /* Arena team ids by team */
-        uint32 m_ArenaTeamIds[2];
-
-        int32 m_ArenaTeamRatingChanges[2];
-
         /* Limits */
         uint32 m_LevelMin;
         uint32 m_LevelMax;
diff --git a/src/game/BattleGroundHandler.cpp b/src/game/BattleGroundHandler.cpp
--- a/src/game/BattleGroundHandler.cpp
+++ b/src/game/BattleGroundHandler.cpp
@@ -95,8 +95,8 @@
 
     sLog.outDebug( "WORLD: Recvd CMSG_BATTLEMASTER_JOIN Message from: " I64FMT, guid);
 
-    // can do this, since it's battleground, not arena
-    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bgTypeId, 0);
+    // can do this, since it's battleground
+    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bgTypeId);
 
     // ignore if player is already in BG
     if(_player->InBattleGround())
@@ -145,6 +145,6 @@
         // no group found, error
         if(!grp)
             return;
-        uint32 err = grp->CanJoinBattleGroundQueue(bgTypeId, bgQueueTypeId, 0, bg->GetMaxPlayersPerTeam(), false, 0);
+        uint32 err = grp->CanJoinBattleGroundQueue(bgTypeId, bgQueueTypeId, 0, bg->GetMaxPlayersPerTeam());
         if (err != BG_JOIN_ERR_OK)
         {
@@ -149,6 +149,6 @@
         if (err != BG_JOIN_ERR_OK)
         {
-            SendBattleGroundOrArenaJoinError(err);
+            SendBattleGroundJoinError(err);
             return;
         }
     }
@@ -158,7 +158,7 @@
     if(joinAsGroup /* && _player->GetGroup()*/)
     {
         sLog.outDebug("Battleground: the following players are joining as group:");
-        GroupQueueInfo * ginfo = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddGroup(_player, bgTypeId, 0, false, 0);
+        GroupQueueInfo * ginfo = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddGroup(_player, bgTypeId);
         for(GroupReference *itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
         {
             Player *member = itr->getSource();
@@ -193,7 +193,7 @@
         sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_WAIT_QUEUE, 0, 0);
         SendPacket(&data);
 
-        GroupQueueInfo * ginfo = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddGroup(_player, bgTypeId, 0, false, 0);
+        GroupQueueInfo * ginfo = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddGroup(_player, bgTypeId);
         sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddPlayer(_player, ginfo);
         sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId, _player->GetBattleGroundQueueIdFromLevel());
         sLog.outDebug("Battleground: player joined queue for bg queue type %u bg type %u: GUID %u, NAME %s",bgQueueTypeId,bgTypeId,_player->GetGUIDLow(), _player->GetName());
@@ -276,11 +276,6 @@
         return;
     }
 
-    BattlemasterListEntry const* bl = sBattlemasterListStore.LookupEntry(bgTypeId);
-
-    if(!bl)
-        return;
-
     WorldPacket data;
     sBattleGroundMgr.BuildBattleGroundListPacket(&data, _player->GetGUID(), _player, bgTypeId);
     SendPacket( &data );
@@ -292,7 +287,7 @@
 
     sLog.outDebug( "WORLD: Recvd CMSG_BATTLEFIELD_PORT Message");
 
-    uint8 type;                                             // arenatype if arena
+    uint8 type;                                             
     uint8 unk2;                                             // unk, can be 0x0 (may be if was invited?) and 0x1
     uint32 instanceId;
     uint32 bgTypeId;                                        // type id from dbc
@@ -328,7 +323,6 @@
 
                 // get possibly needed data from groupinfo
                 bgTypeId = itrPlayerStatus->second.GroupInfo->BgTypeId;
-                uint8 arenatype = itrPlayerStatus->second.GroupInfo->ArenaType;
                 uint8 israted = itrPlayerStatus->second.GroupInfo->IsRated;
                 uint8 status = 0;
 
@@ -356,7 +350,7 @@
 
                 // re - invite player with proper data
                 WorldPacket data;
-                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, itrPlayerStatus->second.GroupInfo->Team?itrPlayerStatus->second.GroupInfo->Team:_player->GetTeam(), i, status, INVITE_ACCEPT_WAIT_TIME, 0, arenatype, israted);
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, itrPlayerStatus->second.GroupInfo->Team?itrPlayerStatus->second.GroupInfo->Team:_player->GetTeam(), i, status, INVITE_ACCEPT_WAIT_TIME, 0);
                 SendPacket(&data);
             }
         }
@@ -366,7 +360,7 @@
     uint32 bgQueueTypeId = 0;
     // get the bg what we were invited to
     BattleGroundQueue::QueuedPlayersMap::iterator itrPlayerStatus;
-    bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bgTypeId,type);
+    bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bgTypeId);
     itrPlayerStatus = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].find(_player->GetGUID());
 
     if(itrPlayerStatus == sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].end())
@@ -401,7 +395,6 @@
     {
         uint32 queueSlot = 0;
         uint32 team = 0;
-        uint32 arenatype = 0;
         uint32 israted = 0;
         uint32 rating = 0;
         uint32 opponentsRating = 0;
@@ -411,5 +404,4 @@
             && pitr->second.GroupInfo )
         {
             team = pitr->second.GroupInfo->Team;
-            arenatype = pitr->second.GroupInfo->ArenaType;
             israted = pitr->second.GroupInfo->IsRated;
@@ -415,6 +407,4 @@
             israted = pitr->second.GroupInfo->IsRated;
-            rating = pitr->second.GroupInfo->ArenaTeamRating;
-            opponentsRating = pitr->second.GroupInfo->OpponentsTeamRating;
         }
         else
         {
@@ -462,21 +452,8 @@
                 break;
             case 0:                                     // leave queue
                 queueSlot = _player->GetBattleGroundQueueIndex(bgQueueTypeId);
-                /*
-                if player leaves rated arena match before match start, it is counted as he played but he lost
-                */
-       /*      [TRINITYROLLBACK]
-	      if (israted) 
-                {
-                    ArenaTeam * at = objmgr.GetArenaTeamById(team);
-                    if (at)
-                    {
-                        sLog.outDebug("UPDATING memberLost's personal arena rating for %u by opponents rating: %u, because he has left queue!", GUID_LOPART(_player->GetGUID()), opponentsRating);
-                        at->MemberLost(_player, opponentsRating);
-                        at->SaveToDB();
-                    }
-                } */
+
                 _player->RemoveBattleGroundQueueId(bgQueueTypeId); // must be called this way, because if you move this call to queue->removeplayer, it causes bugs
                 sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_NONE, 0, 0);
                 sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].RemovePlayer(_player->GetGUID(), true);
                 // player left queue, we should update it, maybe now his group fits in
@@ -479,8 +456,8 @@
                 _player->RemoveBattleGroundQueueId(bgQueueTypeId); // must be called this way, because if you move this call to queue->removeplayer, it causes bugs
                 sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_NONE, 0, 0);
                 sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].RemovePlayer(_player->GetGUID(), true);
                 // player left queue, we should update it, maybe now his group fits in
-                sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId,_player->GetBattleGroundQueueIdFromLevel(),arenatype,israted,rating);
+                sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId,_player->GetBattleGroundQueueIdFromLevel());
                 SendPacket(&data);
                 sLog.outDebug("Battleground: player %s (%u) left queue for bgtype %u, queue type %u.",_player->GetName(),_player->GetGUIDLow(),bg->GetTypeID(),bgQueueTypeId);
                 break;
@@ -528,7 +505,7 @@
         BattleGround *bg = _player->GetBattleGround();
         if(bg)
         {
-            uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+            uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID());
             uint32 queueSlot = _player->GetBattleGroundQueueIndex(bgQueueTypeId);
             if((bg->GetStatus() <= STATUS_IN_PROGRESS))
             {
@@ -538,7 +515,6 @@
             for (uint32 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; i++)
             {
                 uint32 queue_id = _player->GetBattleGroundQueueId(i);       // battlegroundqueueid stores the type id, not the instance id, so this is definitely wrong
-                uint8 arenatype = sBattleGroundMgr.BGArenaType(queue_id);
                 uint8 isRated = 0;
                 if (i == queueSlot || !queue_id)                            // we need to get the instance ids
                     continue;
@@ -547,7 +523,6 @@
                     continue;
                 if(itrPlayerStatus->second.GroupInfo)
                 {
-                    arenatype = itrPlayerStatus->second.GroupInfo->ArenaType;
                     isRated = itrPlayerStatus->second.GroupInfo->IsRated;
                 }
                 BattleGround *bg2 = sBattleGroundMgr.GetBattleGroundTemplate(sBattleGroundMgr.BGTemplateId(queue_id)); //  try this
@@ -555,7 +530,7 @@
                 {
                     //in this call is small bug, this call should be filled by player's waiting time in queue
                     //this call nulls all timers for client :
-                    sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg2, _player->GetTeam(), i, STATUS_WAIT_QUEUE, 0, 0,arenatype,isRated);
+                    sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg2, _player->GetTeam(), i, STATUS_WAIT_QUEUE, 0, 0);
                     SendPacket(&data);
                 }
             }
@@ -570,9 +545,7 @@
             if(!queue_id)
                 continue;
             uint32 bgTypeId = sBattleGroundMgr.BGTemplateId(queue_id);
-            uint8 arenatype = sBattleGroundMgr.BGArenaType(queue_id);
-            uint8 isRated = 0;
             BattleGround *bg = sBattleGroundMgr.GetBattleGroundTemplate(bgTypeId);
             BattleGroundQueue::QueuedPlayersMap::iterator itrPlayerStatus = sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].find(_player->GetGUID());
             if(itrPlayerStatus == sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].end())
                 continue;
@@ -575,11 +548,7 @@
             BattleGround *bg = sBattleGroundMgr.GetBattleGroundTemplate(bgTypeId);
             BattleGroundQueue::QueuedPlayersMap::iterator itrPlayerStatus = sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].find(_player->GetGUID());
             if(itrPlayerStatus == sBattleGroundMgr.m_BattleGroundQueues[queue_id].m_QueuedPlayers[_player->GetBattleGroundQueueIdFromLevel()].end())
                 continue;
-            if(itrPlayerStatus->second.GroupInfo)
-            {
-                arenatype = itrPlayerStatus->second.GroupInfo->ArenaType;
-                isRated = itrPlayerStatus->second.GroupInfo->IsRated;
-            }
+
             if(bg && queue_id)
             {
@@ -584,6 +553,6 @@
             if(bg && queue_id)
             {
-                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), i, STATUS_WAIT_QUEUE, 0, 0, arenatype, isRated);
+                sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), i, STATUS_WAIT_QUEUE, 0, 0);
                 SendPacket(&data);
             }
         }
@@ -644,167 +613,6 @@
     bg->AddPlayerToResurrectQueue(guid, _player->GetGUID());
 }
 
-void WorldSession::HandleBattleGroundArenaJoin( WorldPacket & recv_data )
-{
-    CHECK_PACKET_SIZE(recv_data, 8+1+1+1);
-
-    sLog.outDebug("WORLD: CMSG_BATTLEMASTER_JOIN_ARENA");
-    recv_data.hexlike();
-
-    // ignore if we already in BG or BG queue
-    if(_player->InBattleGround())
-        return;
-
-    uint64 guid;                                            // arena Battlemaster guid
-    uint8 type;                                             // 2v2, 3v3 or 5v5
-    uint8 asGroup;                                          // asGroup
-    uint8 isRated;                                          // isRated
-    Group * grp;
-
-    recv_data >> guid >> type >> asGroup >> isRated;
-
-    Creature *unit = ObjectAccessor::GetCreature(*_player, guid);
-    if(!unit)
-        return;
-
-    if(!unit->isBattleMaster())                             // it's not battle master
-        return;
-
-    uint8 arenatype = 0;
-    uint32 arenaRating = 0;
-
-    switch(type)
-    {
-        case 0:
-            arenatype = ARENA_TYPE_2v2;
-            break;
-        case 1:
-            arenatype = ARENA_TYPE_3v3;
-            break;
-        case 2:
-            arenatype = ARENA_TYPE_5v5;
-            break;
-        default:
-            sLog.outError("Unknown arena type %u at HandleBattleGroundArenaJoin()", type);
-            return;
-    }
-
-    //check existance
-    BattleGround* bg = NULL;
-    if( !(bg = sBattleGroundMgr.GetBattleGroundTemplate(BATTLEGROUND_AA)) )
-    {
-        sLog.outError("Battleground: template bg (all arenas) not found");
-        return;
-    }
-
-    uint8 bgTypeId = bg->GetTypeID();
-    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bgTypeId, arenatype);
-
-    // check queueing conditions
-    if(!asGroup)
-    {
-        // check if already in queue
-        if (_player->GetBattleGroundQueueIndex(bgQueueTypeId) < PLAYER_MAX_BATTLEGROUND_QUEUES)
-            //player is already in this queue
-            return;
-        // check if has free queue slots
-        if(!_player->HasFreeBattleGroundQueueId())
-            return;
-    }
-    else
-    {
-        grp = _player->GetGroup();
-        // no group found, error
-        if(!grp)
-            return;
-        uint32 err = grp->CanJoinBattleGroundQueue(bgTypeId, bgQueueTypeId, arenatype, arenatype, (bool)isRated, type);
-        if (err != BG_JOIN_ERR_OK)
-        {
-            SendBattleGroundOrArenaJoinError(err);
-            return;
-        }
-    }
-
-    uint32 ateamId = 0;
-
-  /*[TRINITYROLLBACK]
-    if(isRated) 
-    {
-        ateamId = _player->GetArenaTeamId(type);
-        // check real arenateam existence only here (if it was moved to group->CanJoin .. () then we would ahve to get it twice)
-        ArenaTeam * at = objmgr.GetArenaTeamById(ateamId);
-        if(!at)
-        {
-            _player->GetSession()->SendNotInArenaTeamPacket(arenatype);
-            return;
-        }
-        // get the team rating for queueing
-        arenaRating = at->GetRating();
-        // the arenateam id must match for everyone in the group
-        // get the personal ratings for queueing
-        uint32 avg_pers_rating = 0;
-        for(GroupReference *itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
-        {
-            Player *member = itr->getSource();
-
-            // calc avg personal rating
-            avg_pers_rating += member->GetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (type*6) + 5);
-        }
-
-        if( arenatype )
-            avg_pers_rating /= arenatype;
-
-        // if avg personal rating is more than 150 points below the teams rating, the team will be queued against an opponent matching or similar to the average personal rating
-        if(avg_pers_rating + 150 < arenaRating)
-            arenaRating = avg_pers_rating;
-    } */
-
-    if(asGroup)
-    {
-        GroupQueueInfo * ginfo = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddGroup(_player, bgTypeId, arenatype, isRated, arenaRating, ateamId);
-        sLog.outDebug("Battleground: arena join as group start");
-        if(isRated)
-//[TRINITYROLLBACK]            sLog.outDebug("Battleground: arena team id %u, leader %s queued with rating %u for type %u",_player->GetArenaTeamId(type),_player->GetName(),arenaRating,arenatype);
-        for(GroupReference *itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
-        {
-            Player *member = itr->getSource();
-            if(!member) continue;
-
-            uint32 queueSlot = member->AddBattleGroundQueueId(bgQueueTypeId);// add to queue
-
-            // store entry point coords (same as leader entry point)
-            member->SetBattleGroundEntryPoint(_player->GetMapId(),_player->GetPositionX(),_player->GetPositionY(),_player->GetPositionZ(),_player->GetOrientation());
-
-            WorldPacket data;
-            // send status packet (in queue)
-            sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, member->GetTeam(), queueSlot, STATUS_WAIT_QUEUE, 0, 0, arenatype, isRated);
-            member->GetSession()->SendPacket(&data);
-            sBattleGroundMgr.BuildGroupJoinedBattlegroundPacket(&data, bgTypeId);
-            member->GetSession()->SendPacket(&data);
-            sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddPlayer(member, ginfo);
-            sLog.outDebug("Battleground: player joined queue for arena as group bg queue type %u bg type %u: GUID %u, NAME %s",bgQueueTypeId,bgTypeId,member->GetGUIDLow(), member->GetName());
-        }
-        sLog.outDebug("Battleground: arena join as group end");
-        sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId, _player->GetBattleGroundQueueIdFromLevel(), arenatype, isRated, arenaRating);
-    }
-    else
-    {
-        uint32 queueSlot = _player->AddBattleGroundQueueId(bgQueueTypeId);
-
-        // store entry point coords
-        _player->SetBattleGroundEntryPoint(_player->GetMapId(),_player->GetPositionX(),_player->GetPositionY(),_player->GetPositionZ(),_player->GetOrientation());
-
-        WorldPacket data;
-        // send status packet (in queue)
-        sBattleGroundMgr.BuildBattleGroundStatusPacket(&data, bg, _player->GetTeam(), queueSlot, STATUS_WAIT_QUEUE, 0, 0, arenatype, isRated);
-        SendPacket(&data);
-        GroupQueueInfo * ginfo = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddGroup(_player, bgTypeId, arenatype, isRated, arenaRating);
-        sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].AddPlayer(_player, ginfo);
-        sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgTypeId, _player->GetBattleGroundQueueIdFromLevel(), arenatype, isRated, arenaRating);
-        sLog.outDebug("Battleground: player joined queue for arena, skirmish, bg queue type %u bg type %u: GUID %u, NAME %s",bgQueueTypeId,bgTypeId,_player->GetGUIDLow(), _player->GetName());
-    }
-}
-
 void WorldSession::HandleBattleGroundReportAFK( WorldPacket & recv_data )
 {
     CHECK_PACKET_SIZE(recv_data, 8);
@@ -824,7 +632,7 @@
     reportedPlayer->ReportedAfkBy(_player);
 }
 
-void WorldSession::SendBattleGroundOrArenaJoinError(uint8 err)
+void WorldSession::SendBattleGroundJoinError(uint8 err)
 {
     WorldPacket data;
     int32 msg;
@@ -852,7 +660,6 @@
             msg = LANG_BG_GROUP_MEMBER_NO_FREE_QUEUE_SLOTS;
             break;
         case BG_JOIN_ERR_GROUP_NOT_ENOUGH:
-        case BG_JOIN_ERR_MIXED_ARENATEAM:
         default:
             return;
             break;
diff --git a/src/game/BattleGroundMgr.cpp b/src/game/BattleGroundMgr.cpp
--- a/src/game/BattleGroundMgr.cpp
+++ b/src/game/BattleGroundMgr.cpp
@@ -66,7 +66,7 @@
 }
 
 // initialize eligible groups from the given source matching the given specifications
-void BattleGroundQueue::EligibleGroups::Init(BattleGroundQueue::QueuedGroupsList *source, uint32 BgTypeId, uint32 side, uint32 MaxPlayers, uint8 ArenaType, bool IsRated, uint32 MinRating, uint32 MaxRating, uint32 DisregardTime, uint32 excludeTeam)
+void BattleGroundQueue::EligibleGroups::Init(BattleGroundQueue::QueuedGroupsList *source, uint32 BgTypeId, uint32 side, uint32 MaxPlayers, uint32 DisregardTime)
 {
     // clear from prev initialization
     clear();
@@ -77,8 +77,6 @@
         next = itr;
         ++next;
         if( (*itr)->BgTypeId == BgTypeId &&     // bg type must match
-            (*itr)->ArenaType == ArenaType &&   // arena type must match
-            (*itr)->IsRated == IsRated &&       // israted must match
             (*itr)->IsInvitedToBGInstanceGUID == 0 && // leave out already invited groups
             (*itr)->Team == side &&             // match side
             (*itr)->Players.size() <= MaxPlayers &&   // the group must fit in the bg
@@ -82,12 +80,9 @@
             (*itr)->IsInvitedToBGInstanceGUID == 0 && // leave out already invited groups
             (*itr)->Team == side &&             // match side
             (*itr)->Players.size() <= MaxPlayers &&   // the group must fit in the bg
-            ( !excludeTeam || (*itr)->ArenaTeamId != excludeTeam ) && // if excludeTeam is specified, leave out those arena team ids
-            ( !IsRated || (*itr)->Players.size() == MaxPlayers ) &&   // if rated, then pass only if the player count is exact NEEDS TESTING! (but now this should never happen)
-            ( !DisregardTime || (*itr)->JoinTime <= DisregardTime              // pass if disregard time is greater than join time
-               || (*itr)->ArenaTeamRating == 0                 // pass if no rating info
-               || ( (*itr)->ArenaTeamRating >= MinRating       // pass if matches the rating range
-                     && (*itr)->ArenaTeamRating <= MaxRating ) ) )
+            ( (*itr)->Players.size() == MaxPlayers ) &&   // if rated, then pass only if the player count is exact NEEDS TESTING! (but now this should never happen)
+            ( !DisregardTime || (*itr)->JoinTime <= DisregardTime ) // pass if disregard time is greater than join time
+		  )
         {
             // the group matches the conditions
             // using push_back for proper selecting when inviting
@@ -130,7 +125,7 @@
 }
 
 // add group to bg queue with the given leader and bg specifications
-GroupQueueInfo * BattleGroundQueue::AddGroup(Player *leader, uint32 BgTypeId, uint8 ArenaType, bool isRated, uint32 arenaRating, uint32 arenateamid)
+GroupQueueInfo * BattleGroundQueue::AddGroup(Player *leader, uint32 BgTypeId)
 {
     uint32 queue_id = leader->GetBattleGroundQueueIdFromLevel();
 
@@ -139,9 +134,6 @@
     // (e.g. leader leaving queue then joining as individual again)
     GroupQueueInfo* ginfo = new GroupQueueInfo;
     ginfo->BgTypeId                  = BgTypeId;
-    ginfo->ArenaType                 = ArenaType;
-    ginfo->ArenaTeamId               = arenateamid;
-    ginfo->IsRated                   = isRated;
     ginfo->IsInvitedToBGInstanceGUID = 0;                       // maybe this should be modifiable by function arguments to enable selection of running instances?
     ginfo->JoinTime                  = getMSTime();
     ginfo->Team                      = leader->GetTeam();
@@ -145,8 +137,6 @@
     ginfo->IsInvitedToBGInstanceGUID = 0;                       // maybe this should be modifiable by function arguments to enable selection of running instances?
     ginfo->JoinTime                  = getMSTime();
     ginfo->Team                      = leader->GetTeam();
-    ginfo->ArenaTeamRating           = arenaRating;
-    ginfo->OpponentsTeamRating       = 0;                       //initialize it to 0
 
     ginfo->Players.clear();
 
@@ -262,10 +252,10 @@
         // NEEDS TESTING!
         // group wasn't empty, so it wasn't deleted, and player have left a rated queue -> everyone from the group should leave too
         // don't remove recursively if already invited to bg!
-        else if(!group->IsInvitedToBGInstanceGUID && decreaseInvitedCount && group->IsRated)
+        else if(!group->IsInvitedToBGInstanceGUID && decreaseInvitedCount)
         {
             // remove next player, this is recursive
             // first send removal information
             if(Player *plr2 = objmgr.GetPlayer(group->Players.begin()->first))
             {
                 BattleGround * bg = sBattleGroundMgr.GetBattleGroundTemplate(group->BgTypeId);
@@ -266,10 +256,10 @@
         {
             // remove next player, this is recursive
             // first send removal information
             if(Player *plr2 = objmgr.GetPlayer(group->Players.begin()->first))
             {
                 BattleGround * bg = sBattleGroundMgr.GetBattleGroundTemplate(group->BgTypeId);
-                uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(group->BgTypeId,group->ArenaType);
+                uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(group->BgTypeId);
                 uint32 queueSlot = plr2->GetBattleGroundQueueIndex(bgQueueTypeId);
                 plr2->RemoveBattleGroundQueueId(bgQueueTypeId); // must be called this way, because if you move this call to queue->removeplayer, it causes bugs
                 WorldPacket data;
@@ -293,7 +283,7 @@
         // not yet invited
         // set invitation
         ginfo->IsInvitedToBGInstanceGUID = bg->GetInstanceID();
-        uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+        uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID());
         // loop through the players
         for(std::map<uint64,PlayerQueueInfo*>::iterator itr = ginfo->Players.begin(); itr != ginfo->Players.end(); ++itr)
         {
@@ -356,7 +346,7 @@
 }
 
 // this function is responsible for the selection of queued groups when trying to create new battlegrounds
-bool BattleGroundQueue::BuildSelectionPool(uint32 bgTypeId, uint32 queue_id, uint32 MinPlayers, uint32 MaxPlayers,  SelectionPoolBuildMode mode, uint8 ArenaType, bool isRated, uint32 MinRating, uint32 MaxRating, uint32 DisregardTime, uint32 excludeTeam)
+bool BattleGroundQueue::BuildSelectionPool(uint32 bgTypeId, uint32 queue_id, uint32 MinPlayers, uint32 MaxPlayers,  SelectionPoolBuildMode mode, uint32 DisregardTime)
 {
     uint32 side;
     switch(mode)
@@ -379,7 +369,7 @@
     }
 
     // initiate the groups eligible to create the bg
-    m_EligibleGroups.Init(&(m_QueuedGroups[queue_id]), bgTypeId, side, MaxPlayers, ArenaType, isRated, MinRating, MaxRating, DisregardTime, excludeTeam);
+    m_EligibleGroups.Init(&(m_QueuedGroups[queue_id]), bgTypeId, side, MaxPlayers, DisregardTime);
     // init the selected groups (clear)
     // and set m_CurrEligGroups pointer
     // we set it this way to only have one EligibleGroups object to save some memory
@@ -403,8 +393,7 @@
 }
 
 // used to remove the Enter Battle window if the battle has already, but someone still has it
-// (this can happen in arenas mainly, since the preparation is shorter than the timer for the bgqueueremove event
 void BattleGroundQueue::BGEndedRemoveInvites(BattleGround *bg)
 {
     uint32 queue_id = bg->GetQueueType();
     uint32 bgInstanceId = bg->GetInstanceID();
@@ -407,8 +396,8 @@
 void BattleGroundQueue::BGEndedRemoveInvites(BattleGround *bg)
 {
     uint32 queue_id = bg->GetQueueType();
     uint32 bgInstanceId = bg->GetInstanceID();
-    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID());
     QueuedGroupsList::iterator itr, next;
     for(itr = m_QueuedGroups[queue_id].begin(); itr != m_QueuedGroups[queue_id].end(); itr = next)
     {
@@ -465,7 +454,7 @@
 it must be called after fully adding the members of a group to ensure group joining
 should be called after removeplayer functions in some cases
 */
-void BattleGroundQueue::Update(uint32 bgTypeId, uint32 queue_id, uint8 arenatype, bool isRated, uint32 arenaRating)
+void BattleGroundQueue::Update(uint32 bgTypeId, uint32 queue_id)
 {
     if (queue_id >= MAX_BATTLEGROUND_QUEUES)
     {
@@ -478,7 +467,7 @@
     if (m_QueuedGroups[queue_id].empty())
         return;
 
-    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bgTypeId, arenatype);
+    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bgTypeId);
 
     //battleground with free slot for player should be always the last in this queue
     BGFreeSlotQueueType::iterator itr, next;
@@ -487,8 +476,7 @@
         next = itr;
         ++next;
         // battleground is running, so if:
-        // DO NOT allow queue manager to invite new player to running arena
-        if ((*itr)->isBattleGround() && (*itr)->GetTypeID() == bgTypeId && (*itr)->GetQueueType() == queue_id && (*itr)->GetStatus() > STATUS_WAIT_QUEUE && (*itr)->GetStatus() < STATUS_WAIT_LEAVE)
+        if ((*itr)->GetTypeID() == bgTypeId && (*itr)->GetQueueType() == queue_id && (*itr)->GetStatus() > STATUS_WAIT_QUEUE && (*itr)->GetStatus() < STATUS_WAIT_LEAVE)
         {
             //we must check both teams
             BattleGround* bg = *itr; //we have to store battleground pointer here, because when battleground is full, it is removed from free queue (not yet implemented!!)
@@ -524,6 +512,5 @@
         return;
     }
 
-    // get the min. players per team, properly for larger arenas as well. (must have full teams for arena matches!)
     uint32 MinPlayersPerTeam = bg_template->GetMinPlayersPerTeam();
     uint32 MaxPlayersPerTeam = bg_template->GetMaxPlayersPerTeam();
@@ -528,29 +515,3 @@
     uint32 MinPlayersPerTeam = bg_template->GetMinPlayersPerTeam();
     uint32 MaxPlayersPerTeam = bg_template->GetMaxPlayersPerTeam();
-    if(bg_template->isArena())
-    {
-        if(sBattleGroundMgr.isArenaTesting())
-        {
-            MaxPlayersPerTeam = 1;
-            MinPlayersPerTeam = 1;
-        }
-        else
-        {
-            switch(arenatype)
-            {
-            case ARENA_TYPE_2v2:
-                MaxPlayersPerTeam = 2;
-                MinPlayersPerTeam = 2;
-                break;
-            case ARENA_TYPE_3v3:
-                MaxPlayersPerTeam = 3;
-                MinPlayersPerTeam = 3;
-                break;
-            case ARENA_TYPE_5v5:
-                MaxPlayersPerTeam = 5;
-                MinPlayersPerTeam = 5;
-                break;
-            }
-        }
-    }
 
@@ -556,9 +517,4 @@
 
-    // found out the minimum and maximum ratings the newly added team should battle against
-    // arenaRating is the rating of the latest joined team
-    uint32 arenaMinRating = (arenaRating <= sBattleGroundMgr.GetMaxRatingDifference()) ? 0 : arenaRating - sBattleGroundMgr.GetMaxRatingDifference();
-    // if no rating is specified, set maxrating to 0
-    uint32 arenaMaxRating = (arenaRating == 0)? 0 : arenaRating + sBattleGroundMgr.GetMaxRatingDifference();
     uint32 discardTime = 0;
     // if max rating difference is set and the time past since server startup is greater than the rating discard time
     // (after what time the ratings aren't taken into account when making teams) then
@@ -568,8 +524,8 @@
         discardTime = getMSTime() - sBattleGroundMgr.GetRatingDiscardTimer();
 
     // try to build the selection pools
-    bool bAllyOK = BuildSelectionPool(bgTypeId, queue_id, MinPlayersPerTeam, MaxPlayersPerTeam, NORMAL_ALLIANCE, arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime);
+    bool bAllyOK = BuildSelectionPool(bgTypeId, queue_id, MinPlayersPerTeam, MaxPlayersPerTeam, NORMAL_ALLIANCE, discardTime);
     if(bAllyOK)
         sLog.outDebug("Battleground: ally pool successfully built");
     else
         sLog.outDebug("Battleground: ally pool wasn't created");
@@ -572,8 +528,8 @@
     if(bAllyOK)
         sLog.outDebug("Battleground: ally pool successfully built");
     else
         sLog.outDebug("Battleground: ally pool wasn't created");
-    bool bHordeOK = BuildSelectionPool(bgTypeId, queue_id, MinPlayersPerTeam, MaxPlayersPerTeam, NORMAL_HORDE, arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime);
+    bool bHordeOK = BuildSelectionPool(bgTypeId, queue_id, MinPlayersPerTeam, MaxPlayersPerTeam, NORMAL_HORDE, discardTime);
     if(bHordeOK)
         sLog.outDebug("Battleground: horde pool successfully built");
     else
@@ -583,48 +539,4 @@
     if (bAllyOK && bHordeOK)
     {
         BattleGround * bg2 = 0;
-        // special handling for arenas
-        if(bg_template->isArena())
-        {
-            // Find a random arena, that can be created
-            uint8 arenas[] = {BATTLEGROUND_NA, BATTLEGROUND_BE, BATTLEGROUND_RL};
-            uint32 arena_num = urand(0,2);
-            if( !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[arena_num%3])) &&
-                !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[(arena_num+1)%3])) &&
-                !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[(arena_num+2)%3])) )
-            {
-                sLog.outError("Battleground: couldn't create any arena instance!");
-                return;
-            }
-
-            // set the MaxPlayersPerTeam values based on arenatype
-            // setting the min player values isn't needed, since we won't be using that value later on.
-            if(sBattleGroundMgr.isArenaTesting())
-            {
-                bg2->SetMaxPlayersPerTeam(1);
-                bg2->SetMaxPlayers(2);
-            }
-            else
-            {
-                switch(arenatype)
-                {
-                case ARENA_TYPE_2v2:
-                    bg2->SetMaxPlayersPerTeam(2);
-                    bg2->SetMaxPlayers(4);
-                    break;
-                case ARENA_TYPE_3v3:
-                    bg2->SetMaxPlayersPerTeam(3);
-                    bg2->SetMaxPlayers(6);
-                    break;
-                case ARENA_TYPE_5v5:
-                    bg2->SetMaxPlayersPerTeam(5);
-                    bg2->SetMaxPlayers(10);
-                    break;
-                default:
-                    break;
-                }
-            }
-        }
-        else
-        {
             // create new battleground
@@ -630,6 +542,5 @@
             // create new battleground
-            bg2 = sBattleGroundMgr.CreateNewBattleGround(bgTypeId);
-        }
+        bg2 = sBattleGroundMgr.CreateNewBattleGround(bgTypeId);
 
         if(!bg2)
         {
@@ -640,10 +551,6 @@
         // start the joining of the bg
         bg2->SetStatus(STATUS_WAIT_JOIN);
         bg2->SetQueueType(queue_id);
-        // initialize arena / rating info
-        bg2->SetArenaType(arenatype);
-        // set rating
-        bg2->SetRated(isRated);
 
         std::list<GroupQueueInfo* >::iterator itr;
 
@@ -677,17 +584,7 @@
             ++invitecounter;
         }
 
-        if (isRated)
-        {
-            std::list<GroupQueueInfo* >::iterator itr_alliance = m_SelectionPools[NORMAL_ALLIANCE].SelectedGroups.begin();
-            std::list<GroupQueueInfo* >::iterator itr_horde = m_SelectionPools[NORMAL_HORDE].SelectedGroups.begin();
-            (*itr_alliance)->OpponentsTeamRating = (*itr_horde)->ArenaTeamRating;
-            sLog.outDebug("setting opposite team rating for team %u to %u", (*itr_alliance)->ArenaTeamId, (*itr_alliance)->OpponentsTeamRating);
-            (*itr_horde)->OpponentsTeamRating = (*itr_alliance)->ArenaTeamRating;
-            sLog.outDebug("setting opposite team rating for team %u to %u", (*itr_horde)->ArenaTeamId, (*itr_horde)->OpponentsTeamRating);
-        }
-
         // start the battleground
         bg2->StartBattleGround();
     }
 
@@ -690,155 +587,7 @@
         // start the battleground
         bg2->StartBattleGround();
     }
 
-    // there weren't enough players for a "normal" match
-    // if arena, enable horde versus horde or alliance versus alliance teams here
-
-    else if(bg_template->isArena())
-    {
-        bool bOneSideHordeTeam1 = false, bOneSideHordeTeam2 = false;
-        bool bOneSideAllyTeam1 = false, bOneSideAllyTeam2 = false;
-        bOneSideHordeTeam1 = BuildSelectionPool(bgTypeId, queue_id,MaxPlayersPerTeam,MaxPlayersPerTeam,ONESIDE_HORDE_TEAM1,arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime);
-        if(bOneSideHordeTeam1)
-        {
-            // one team has been selected, find out if other can be selected too
-            std::list<GroupQueueInfo* >::iterator itr;
-            // temporarily change the team side to enable building the next pool excluding the already selected groups
-            for(itr = m_SelectionPools[ONESIDE_HORDE_TEAM1].SelectedGroups.begin(); itr != m_SelectionPools[ONESIDE_HORDE_TEAM1].SelectedGroups.end(); ++itr)
-                (*itr)->Team=ALLIANCE;
-
-            bOneSideHordeTeam2 = BuildSelectionPool(bgTypeId, queue_id,MaxPlayersPerTeam,MaxPlayersPerTeam,ONESIDE_HORDE_TEAM2,arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime, (*(m_SelectionPools[ONESIDE_HORDE_TEAM1].SelectedGroups.begin()))->ArenaTeamId);
-
-            // change back the team to horde
-            for(itr = m_SelectionPools[ONESIDE_HORDE_TEAM1].SelectedGroups.begin(); itr != m_SelectionPools[ONESIDE_HORDE_TEAM1].SelectedGroups.end(); ++itr)
-                (*itr)->Team=HORDE;
-
-            if(!bOneSideHordeTeam2)
-                bOneSideHordeTeam1 = false;
-        }
-        if(!bOneSideHordeTeam1)
-        {
-            // check for one sided ally
-            bOneSideAllyTeam1 = BuildSelectionPool(bgTypeId, queue_id,MaxPlayersPerTeam,MaxPlayersPerTeam,ONESIDE_ALLIANCE_TEAM1,arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime);
-            if(bOneSideAllyTeam1)
-            {
-                // one team has been selected, find out if other can be selected too
-                std::list<GroupQueueInfo* >::iterator itr;
-                // temporarily change the team side to enable building the next pool excluding the already selected groups
-                for(itr = m_SelectionPools[ONESIDE_ALLIANCE_TEAM1].SelectedGroups.begin(); itr != m_SelectionPools[ONESIDE_ALLIANCE_TEAM1].SelectedGroups.end(); ++itr)
-                    (*itr)->Team=HORDE;
-
-                bOneSideAllyTeam2 = BuildSelectionPool(bgTypeId, queue_id,MaxPlayersPerTeam,MaxPlayersPerTeam,ONESIDE_ALLIANCE_TEAM2,arenatype, isRated, arenaMinRating, arenaMaxRating, discardTime,(*(m_SelectionPools[ONESIDE_ALLIANCE_TEAM1].SelectedGroups.begin()))->ArenaTeamId);
-
-                // change back the team to ally
-                for(itr = m_SelectionPools[ONESIDE_ALLIANCE_TEAM1].SelectedGroups.begin(); itr != m_SelectionPools[ONESIDE_ALLIANCE_TEAM1].SelectedGroups.end(); ++itr)
-                    (*itr)->Team=ALLIANCE;
-            }
-
-            if(!bOneSideAllyTeam2)
-                bOneSideAllyTeam1 = false;
-        }
-        // 1-sided BuildSelectionPool() will work, because the MinPlayersPerTeam == MaxPlayersPerTeam in every arena!!!!
-        if( (bOneSideHordeTeam1 && bOneSideHordeTeam2) ||
-            (bOneSideAllyTeam1 && bOneSideAllyTeam2) )
-        {
-            // which side has enough players?
-            uint32 side = 0;
-            SelectionPoolBuildMode mode1, mode2;
-            // find out what pools are we using
-            if(bOneSideAllyTeam1 && bOneSideAllyTeam2)
-            {
-                side = ALLIANCE;
-                mode1 = ONESIDE_ALLIANCE_TEAM1;
-                mode2 = ONESIDE_ALLIANCE_TEAM2;
-            }
-            else
-            {
-                side = HORDE;
-                mode1 = ONESIDE_HORDE_TEAM1;
-                mode2 = ONESIDE_HORDE_TEAM2;
-            }
-
-            // create random arena
-            uint8 arenas[] = {BATTLEGROUND_NA, BATTLEGROUND_BE, BATTLEGROUND_RL};
-            uint32 arena_num = urand(0,2);
-            BattleGround* bg2 = NULL;
-            if( !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[arena_num%3])) &&
-                !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[(arena_num+1)%3])) &&
-                !(bg2 = sBattleGroundMgr.CreateNewBattleGround(arenas[(arena_num+2)%3])) )
-            {
-                sLog.outError("Could not create arena.");
-                return;
-            }
-
-            sLog.outDebug("Battleground: One-faction arena created.");
-            // init stats
-            if(sBattleGroundMgr.isArenaTesting())
-            {
-                bg2->SetMaxPlayersPerTeam(1);
-                bg2->SetMaxPlayers(2);
-            }
-            else
-            {
-                switch(arenatype)
-                {
-                case ARENA_TYPE_2v2:
-                    bg2->SetMaxPlayersPerTeam(2);
-                    bg2->SetMaxPlayers(4);
-                    break;
-                case ARENA_TYPE_3v3:
-                    bg2->SetMaxPlayersPerTeam(3);
-                    bg2->SetMaxPlayers(6);
-                    break;
-                case ARENA_TYPE_5v5:
-                    bg2->SetMaxPlayersPerTeam(5);
-                    bg2->SetMaxPlayers(10);
-                    break;
-                default:
-                    break;
-                }
-            }
-
-            bg2->SetRated(isRated);
-
-            // assigned team of the other group
-            uint32 other_side;
-            if(side == ALLIANCE)
-                other_side = HORDE;
-            else
-                other_side = ALLIANCE;
-
-            // start the joining of the bg
-            bg2->SetStatus(STATUS_WAIT_JOIN);
-            bg2->SetQueueType(queue_id);
-            // initialize arena / rating info
-            bg2->SetArenaType(arenatype);
-
-            std::list<GroupQueueInfo* >::iterator itr;
-
-            // invite players from the first group as horde players (actually green team)
-            for(itr = m_SelectionPools[mode1].SelectedGroups.begin(); itr != m_SelectionPools[mode1].SelectedGroups.end(); ++itr)
-            {
-                InviteGroupToBG((*itr),bg2,HORDE);
-            }
-
-            // invite players from the second group as ally players (actually gold team)
-            for(itr = m_SelectionPools[mode2].SelectedGroups.begin(); itr != m_SelectionPools[mode2].SelectedGroups.end(); ++itr)
-            {
-                InviteGroupToBG((*itr),bg2,ALLIANCE);
-            }
-
-            if (isRated)
-            {
-                std::list<GroupQueueInfo* >::iterator itr_alliance = m_SelectionPools[mode1].SelectedGroups.begin();
-                std::list<GroupQueueInfo* >::iterator itr_horde = m_SelectionPools[mode2].SelectedGroups.begin();
-                (*itr_alliance)->OpponentsTeamRating = (*itr_horde)->ArenaTeamRating;
-                (*itr_horde)->OpponentsTeamRating = (*itr_alliance)->ArenaTeamRating;
-            }
-
-            bg2->StartBattleGround();
-        }
-    }
 }
 
 /*********************************************************/
@@ -865,7 +614,7 @@
     uint32 queueSlot = plr->GetBattleGroundQueueIndex(bg->GetTypeID());
     if (queueSlot < PLAYER_MAX_BATTLEGROUND_QUEUES)         // player is in queue
     {
-        uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+        uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID());
         uint32 queueSlot = plr->GetBattleGroundQueueIndex(bgQueueTypeId);
         if (queueSlot < PLAYER_MAX_BATTLEGROUND_QUEUES) // player is in queue
         {
@@ -902,7 +651,7 @@
 
     sLog.outDebug("Battleground: removing player %u from bg queue for instance %u because of not pressing enter battle in time.",plr->GetGUIDLow(),m_BgInstanceGUID);
 
-    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID(), bg->GetArenaType());
+    uint32 bgQueueTypeId = sBattleGroundMgr.BGQueueTypeId(bg->GetTypeID());
     uint32 queueSlot = plr->GetBattleGroundQueueIndex(bgQueueTypeId);
     if (queueSlot < PLAYER_MAX_BATTLEGROUND_QUEUES) // player is in queue
     {
@@ -910,17 +659,6 @@
         BattleGroundQueue::QueuedPlayersMap::iterator qMapItr = sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[plr->GetBattleGroundQueueIdFromLevel()].find(m_PlayerGuid);
         if (qMapItr != sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].m_QueuedPlayers[plr->GetBattleGroundQueueIdFromLevel()].end() && qMapItr->second.GroupInfo && qMapItr->second.GroupInfo->IsInvitedToBGInstanceGUID == m_BgInstanceGUID)
         {
-          /* [TRINITYROLLBACK]
-		  if (qMapItr->second.GroupInfo->IsRated) 
-            {
-                ArenaTeam * at = objmgr.GetArenaTeamById(qMapItr->second.GroupInfo->ArenaTeamId);
-                if (at)
-                {
-                    sLog.outDebug("UPDATING memberLost's personal arena rating for %u by opponents rating: %u", GUID_LOPART(plr->GetGUID()), qMapItr->second.GroupInfo->OpponentsTeamRating);
-                    at->MemberLost(plr, qMapItr->second.GroupInfo->OpponentsTeamRating);
-                    at->SaveToDB();
-                }
-            } */
             plr->RemoveBattleGroundQueueId(bgQueueTypeId);
             sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].RemovePlayer(m_PlayerGuid, true);
             sBattleGroundMgr.m_BattleGroundQueues[bgQueueTypeId].Update(bgQueueTypeId, bg->GetQueueType());
@@ -949,9 +687,6 @@
 BattleGroundMgr::BattleGroundMgr()
 {
     m_BattleGrounds.clear();
-    m_AutoDistributePoints = (bool)sWorld.getConfig(CONFIG_ARENA_AUTO_DISTRIBUTE_POINTS);
-    m_MaxRatingDifference = sWorld.getConfig(CONFIG_ARENA_MAX_RATING_DIFFERENCE);
-    m_RatingDiscardTimer = sWorld.getConfig(CONFIG_ARENA_RATING_DISCARD_TIMER);
     m_PrematureFinishTimer = sWorld.getConfig(CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER);
     m_NextRatingDiscardUpdate = m_RatingDiscardTimer;
     m_AutoDistributionTimeChecker = 0;
@@ -955,7 +690,6 @@
     m_PrematureFinishTimer = sWorld.getConfig(CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER);
     m_NextRatingDiscardUpdate = m_RatingDiscardTimer;
     m_AutoDistributionTimeChecker = 0;
-    m_ArenaTesting = false;
 }
 
 BattleGroundMgr::~BattleGroundMgr()
@@ -990,35 +724,5 @@
             delete bg;
         }
     }
-    // if rating difference counts, maybe force-update queues
-    if(m_MaxRatingDifference)
-    {
-        // it's time to force update
-        if(m_NextRatingDiscardUpdate < diff)
-        {
-            // forced update for level 70 rated arenas
-            m_BattleGroundQueues[BATTLEGROUND_QUEUE_2v2].Update(BATTLEGROUND_AA,6,ARENA_TYPE_2v2,true,0);
-            m_BattleGroundQueues[BATTLEGROUND_QUEUE_3v3].Update(BATTLEGROUND_AA,6,ARENA_TYPE_3v3,true,0);
-            m_BattleGroundQueues[BATTLEGROUND_QUEUE_5v5].Update(BATTLEGROUND_AA,6,ARENA_TYPE_5v5,true,0);
-            m_NextRatingDiscardUpdate = m_RatingDiscardTimer;
-        }
-        else
-            m_NextRatingDiscardUpdate -= diff;
-    }
-    if(m_AutoDistributePoints)
-    {
-        if(m_AutoDistributionTimeChecker < diff)
-        {
-            if(time(NULL) > m_NextAutoDistributionTime)
-            {
-                DistributeArenaPoints();
-                m_NextAutoDistributionTime = time(NULL) + BATTLEGROUND_ARENA_POINT_DISTRIBUTION_DAY * sWorld.getConfig(CONFIG_ARENA_AUTO_DISTRIBUTE_INTERVAL_DAYS);
-                CharacterDatabase.PExecute("UPDATE saved_variables SET NextArenaPointDistributionTime = '"I64FMTD"'", m_NextAutoDistributionTime);
-            }
-            m_AutoDistributionTimeChecker = 600000; // check 10 minutes
-        }
-        else
-            m_AutoDistributionTimeChecker -= diff;
-    }
 }
 
@@ -1023,4 +727,4 @@
 }
 
-void BattleGroundMgr::BuildBattleGroundStatusPacket(WorldPacket *data, BattleGround *bg, uint32 team, uint8 QueueSlot, uint8 StatusID, uint32 Time1, uint32 Time2, uint32 arenatype, uint8 israted)
+void BattleGroundMgr::BuildBattleGroundStatusPacket(WorldPacket *data, BattleGround *bg, uint32 team, uint8 QueueSlot, uint8 StatusID, uint32 Time1, uint32 Time2)
 {
@@ -1026,4 +730,5 @@
 {
+	// [TRINITY ROLLBACK] this procedure must be rewritten 
     // we can be in 3 queues in same time...
     if(StatusID == 0)
     {
@@ -1033,6 +738,6 @@
         return;
     }
 
-    data->Initialize(SMSG_BATTLEFIELD_STATUS, (4+1+1+4+2+4+1+4+4+4));
+    data->Initialize(SMSG_BATTLEFIELD_STATUS, (5*4+1));
     *data << uint32(QueueSlot);                             // queue id (0...2) - player can be in 3 queues in time
     // uint64 in client
@@ -1037,5 +742,5 @@
     *data << uint32(QueueSlot);                             // queue id (0...2) - player can be in 3 queues in time
     // uint64 in client
-    *data << uint64( uint64(arenatype ? arenatype : bg->GetArenaType()) | (uint64(0x0D) << 8) | (uint64(bg->GetTypeID()) << 16) | (uint64(0x1F90) << 48) );
+	// *data << uint64( uint64(arenatype ? arenatype : bg->GetArenaType()) | (uint64(0x0D) << 8) | (uint64(bg->GetTypeID()) << 16) | (uint64(0x1F90) << 48) );
     *data << uint32(0);                                     // unknown
     // alliance/horde for BG and skirmish/rated for Arenas
@@ -1040,6 +745,5 @@
     *data << uint32(0);                                     // unknown
     // alliance/horde for BG and skirmish/rated for Arenas
-    *data << uint8(bg->isArena() ? ( israted ? israted : bg->isRated() ) : bg->GetTeamIndexByTeamId(team));
 /*    *data << uint8(arenatype ? arenatype : bg->GetArenaType());                     // team type (0=BG, 2=2x2, 3=3x3, 5=5x5), for arenas    // NOT PROPER VALUE IF ARENA ISN'T RUNNING YET!!!!
     switch(bg->GetTypeID())                                 // value depends on bg id
     {
@@ -1110,7 +814,4 @@
 
 void BattleGroundMgr::BuildPvpLogDataPacket(WorldPacket *data, BattleGround *bg)
 {
-  /* [TRINITYROLLBACK]
-  uint8 type = (bg->isArena() ? 1 : 0);  
-                                                            // last check on 2.4.1
     data->Initialize(MSG_PVP_LOG_DATA, (1+1+4+40*bg->GetPlayerScoresSize()));
@@ -1116,3 +817,3 @@
     data->Initialize(MSG_PVP_LOG_DATA, (1+1+4+40*bg->GetPlayerScoresSize()));
-    *data << uint8(type);                                   // seems to be type (battleground=0/arena=1)
+    *data << uint8(0);                                      // seems to be type (battleground=0)
 
@@ -1118,23 +819,4 @@
 
-    if(type)                                                // arena
-    {
-        // it seems this must be according to BG_WINNER_A/H and _NOT_ BG_TEAM_A/H
-        for(int i = 1; i >= 0; --i)
-        {
-            *data << uint32(3000-bg->m_ArenaTeamRatingChanges[i]);                      // rating change: showed value - 3000
-            *data << uint32(3999);  // huge thanks for TOM_RUS for this!
-            sLog.outDebug("rating change: %d", bg->m_ArenaTeamRatingChanges[i]);
-        }
-        for(int i = 1; i >= 0; --i)
-        {
-            uint32 at_id = bg->m_ArenaTeamIds[i];
-            ArenaTeam * at = objmgr.GetArenaTeamById(at_id);
-            if(at)
-                *data << at->GetName();
-            else
-                *data << (uint8)0;
-        }
-    } */
 
     if(bg->GetWinner() == 2)
     {
@@ -1155,31 +837,11 @@
         Player *plr = objmgr.GetPlayer(itr->first);
         uint32 team = bg->GetPlayerTeam(itr->first);
         if(!team && plr) team = plr->GetTeam();
-  // [TRINITYROLLBACK]      
-  //if(type == 0)
-  //      {
-            *data << (int32)itr->second->HonorableKills;
-            *data << (int32)itr->second->Deaths;
-            *data << (int32)(itr->second->BonusHonor);
- /*       }
-  [TRINITYROLLBACK]
-        else 
-        {
-            // that part probably wrong
-            if(plr)
-            {
-                if(team == HORDE)
-                    *data << uint8(0);
-                else if(team == ALLIANCE)
-                {
-                    *data << uint8(1);
-                }
-                else
-                    *data << uint8(0);
-            }
-            else
-                *data << uint8(0);
-        } */
+
+        *data << (int32)itr->second->HonorableKills;
+        *data << (int32)itr->second->Deaths;
+        *data << (int32)(itr->second->BonusHonor);
+
         *data << (int32)itr->second->DamageDone;             // damage done
         *data << (int32)itr->second->HealingDone;            // healing done
         switch(bg->GetTypeID())                              // battleground specific things
@@ -1202,16 +864,6 @@
                 *data << (uint32)((BattleGroundABScore*)itr->second)->BasesAssaulted;       // bases asssulted
                 *data << (uint32)((BattleGroundABScore*)itr->second)->BasesDefended;        // bases defended
                 break;
-      /* [TRINITYROLLBACK]     case BATTLEGROUND_EY:
-                *data << (uint32)0x00000001;                 // count of next fields
-                *data << (uint32)((BattleGroundEYScore*)itr->second)->FlagCaptures;         // flag captures
-                break;
-            case BATTLEGROUND_NA:
-            case BATTLEGROUND_BE:
-            case BATTLEGROUND_AA:
-            case BATTLEGROUND_RL:
-                *data << (int32)0;                          // 0 
-                break; */
             default:
                 sLog.outDebug("Unhandled MSG_PVP_LOG_DATA for BG id %u", bg->GetTypeID());
                 *data << (int32)0;
@@ -1268,26 +920,7 @@
         return;
     bg->IncreaseInvitedCount(team);
 
-    plr->SetInviteForBattleGroundQueueType(BGQueueTypeId(bg->GetTypeID(),bg->GetArenaType()), bgInstanceGUID);
-
-    // set the arena teams for rated matches
-   /* [TRINITYROLLBACK] if(bg->isArena() && bg->isRated())
-    {
-        switch(bg->GetArenaType())
-        {
-        case ARENA_TYPE_2v2:
-            bg->SetArenaTeamIdForTeam(team, plr->GetArenaTeamId(0));
-            break;
-        case ARENA_TYPE_3v3:
-            bg->SetArenaTeamIdForTeam(team, plr->GetArenaTeamId(1));
-            break;
-        case ARENA_TYPE_5v5:
-            bg->SetArenaTeamIdForTeam(team, plr->GetArenaTeamId(2));
-            break;
-        default:
-            break;
-        }
-    } */
+    plr->SetInviteForBattleGroundQueueType(BGQueueTypeId(bg->GetTypeID()), bgInstanceGUID);
 
     // create invite events:
     //add events to player's counters ---- this is not good way - there should be something like global event processor, where we should add those events
@@ -1328,22 +961,6 @@
         case BATTLEGROUND_AB:
             bg = new BattleGroundAB(*(BattleGroundAB*)bg_template);
             break;
-     /*[TRINITYROLLBACK]   
-	    case BATTLEGROUND_NA:
-            bg = new BattleGroundNA(*(BattleGroundNA*)bg_template);
-            break;
-        case BATTLEGROUND_BE:
-            bg = new BattleGroundBE(*(BattleGroundBE*)bg_template);
-            break;
-        case BATTLEGROUND_AA:
-            bg = new BattleGroundAA(*(BattleGroundAA*)bg_template);
-            break;
-        case BATTLEGROUND_EY:
-            bg = new BattleGroundEY(*(BattleGroundEY*)bg_template);
-            break;
-        case BATTLEGROUND_RL:
-            bg = new BattleGroundRL(*(BattleGroundRL*)bg_template);
-            break; */
         default:
             //bg = new BattleGround;
             return 0;
@@ -1375,10 +992,10 @@
 }
 
 // used to create the BG templates
-uint32 BattleGroundMgr::CreateBattleGround(uint32 bgTypeId, uint32 MinPlayersPerTeam, uint32 MaxPlayersPerTeam, uint32 LevelMin, uint32 LevelMax, char* BattleGroundName, uint32 MapID, float Team1StartLocX, float Team1StartLocY, float Team1StartLocZ, float Team1StartLocO, float Team2StartLocX, float Team2StartLocY, float Team2StartLocZ, float Team2StartLocO)
+uint32 BattleGroundMgr::CreateBattleGround(uint32 bgTypeId, uint32 MinPlayersPerTeam, uint32 MaxPlayersPerTeam, uint32 LevelMin, uint32 LevelMax, float Team1StartLocX, float Team1StartLocY, float Team1StartLocZ, float Team1StartLocO, float Team2StartLocX, float Team2StartLocY, float Team2StartLocZ, float Team2StartLocO)
 {
     // Create the BG
     BattleGround *bg = NULL;
 
     switch(bgTypeId)
     {
@@ -1379,18 +996,25 @@
 {
     // Create the BG
     BattleGround *bg = NULL;
 
     switch(bgTypeId)
     {
-        case BATTLEGROUND_AV: bg = new BattleGroundAV; break;
-        case BATTLEGROUND_WS: bg = new BattleGroundWS; break;
-        case BATTLEGROUND_AB: bg = new BattleGroundAB; break;
-    /*[TRINITYROLLBACK]   
-	    case BATTLEGROUND_NA: bg = new BattleGroundNA; break;
-        case BATTLEGROUND_BE: bg = new BattleGroundBE; break;
-        case BATTLEGROUND_AA: bg = new BattleGroundAA; break;
-        case BATTLEGROUND_EY: bg = new BattleGroundEY; break;
-        case BATTLEGROUND_RL: bg = new BattleGroundRL; break; */
+        case BATTLEGROUND_AV: 
+			bg = new BattleGroundAV; 
+		    bg->SetName("Alterac Valley");
+			bg->SetMapId(30);
+		break;
+        case BATTLEGROUND_WS: 
+			bg = new BattleGroundWS;
+            bg->SetName("Warsong Gulch");
+			bg->SetMapId(489);
+		break;
+        case BATTLEGROUND_AB: 
+			bg = new BattleGroundAB;
+			bg->SetName("Arathi Basin");
+			bg->SetMapId(529);
+		break;
+
         default:bg = new BattleGround;   break;             // placeholder for non implemented BG
     }
 
@@ -1394,7 +1018,5 @@
         default:bg = new BattleGround;   break;             // placeholder for non implemented BG
     }
 
-    bg->SetMapId(MapID);
-
     bg->Reset();
 
@@ -1399,15 +1021,8 @@
     bg->Reset();
 
-    BattlemasterListEntry const *bl = sBattlemasterListStore.LookupEntry(bgTypeId);
-    //in previous method is checked if exists entry in sBattlemasterListStore, so no check needed
-    if (bl)
-    {
-        bg->SetArenaorBGType(bl->type == TYPE_ARENA);
-    }
-
     bg->SetTypeID(bgTypeId);
     bg->SetInstanceID(0);                               // template bg, instance id is 0
     bg->SetMinPlayersPerTeam(MinPlayersPerTeam);
     bg->SetMaxPlayersPerTeam(MaxPlayersPerTeam);
     bg->SetMinPlayers(MinPlayersPerTeam*2);
     bg->SetMaxPlayers(MaxPlayersPerTeam*2);
@@ -1408,10 +1023,9 @@
     bg->SetTypeID(bgTypeId);
     bg->SetInstanceID(0);                               // template bg, instance id is 0
     bg->SetMinPlayersPerTeam(MinPlayersPerTeam);
     bg->SetMaxPlayersPerTeam(MaxPlayersPerTeam);
     bg->SetMinPlayers(MinPlayersPerTeam*2);
     bg->SetMaxPlayers(MaxPlayersPerTeam*2);
-    bg->SetName(BattleGroundName);
     bg->SetTeamStartLoc(ALLIANCE, Team1StartLocX, Team1StartLocY, Team1StartLocZ, Team1StartLocO);
     bg->SetTeamStartLoc(HORDE,    Team2StartLocX, Team2StartLocY, Team2StartLocZ, Team2StartLocO);
     bg->SetLevelRange(LevelMin, LevelMax);
@@ -1430,7 +1044,6 @@
     float AStartLoc[4];
     float HStartLoc[4];
     uint32 MaxPlayersPerTeam, MinPlayersPerTeam, MinLvl, MaxLvl, start1, start2;
-    BattlemasterListEntry const *bl;
     WorldSafeLocsEntry const *start;
 
     uint32 count = 0;
@@ -1459,10 +1072,4 @@
         uint32 bgTypeID = fields[0].GetUInt32();
 
         // can be overwrited by values from DB
-        bl = sBattlemasterListStore.LookupEntry(bgTypeID);
-        if(!bl)
-        {
-            sLog.outError("Battleground ID %u not found in BattlemasterList.dbc. Battleground not created.",bgTypeID);
-            continue;
-        }
 
@@ -1468,8 +1075,8 @@
 
-        MaxPlayersPerTeam = bl->maxplayersperteam;
-        MinPlayersPerTeam = bl->maxplayersperteam/2;
-        MinLvl = bl->minlvl;
-        MaxLvl = bl->maxlvl;
+        MaxPlayersPerTeam = 0;
+        MinPlayersPerTeam = 0;
+        MinLvl = 0;
+        MaxLvl = 0;
 
         if(fields[1].GetUInt32())
             MinPlayersPerTeam = fields[1].GetUInt32();
@@ -1493,13 +1100,6 @@
             AStartLoc[2] = start->z;
             AStartLoc[3] = fields[6].GetFloat();
         }
-        else if(bgTypeID == BATTLEGROUND_AA)
-        {
-            AStartLoc[0] = 0;
-            AStartLoc[1] = 0;
-            AStartLoc[2] = 0;
-            AStartLoc[3] = fields[6].GetFloat();
-        }
         else
         {
             sLog.outErrorDb("Table `battleground_template` for id %u have non-existed WorldSafeLocs.dbc id %u in field `AllianceStartLoc`. BG not created.",bgTypeID,start1);
@@ -1516,13 +1116,6 @@
             HStartLoc[2] = start->z;
             HStartLoc[3] = fields[8].GetFloat();
         }
-        else if(bgTypeID == BATTLEGROUND_AA)
-        {
-            HStartLoc[0] = 0;
-            HStartLoc[1] = 0;
-            HStartLoc[2] = 0;
-            HStartLoc[3] = fields[8].GetFloat();
-        }
         else
         {
             sLog.outErrorDb("Table `battleground_template` for id %u have non-existed WorldSafeLocs.dbc id %u in field `HordeStartLoc`. BG not created.",bgTypeID,start2);
@@ -1530,7 +1123,7 @@
         }
 
         //sLog.outDetail("Creating battleground %s, %u-%u", bl->name[sWorld.GetDBClang()], MinLvl, MaxLvl);
-        if(!CreateBattleGround(bgTypeID, MinPlayersPerTeam, MaxPlayersPerTeam, MinLvl, MaxLvl, bl->name[sWorld.GetDefaultDbcLocale()], bl->mapid[0], AStartLoc[0], AStartLoc[1], AStartLoc[2], AStartLoc[3], HStartLoc[0], HStartLoc[1], HStartLoc[2], HStartLoc[3]))
+        if(!CreateBattleGround(bgTypeID, MinPlayersPerTeam, MaxPlayersPerTeam, MinLvl, MaxLvl, AStartLoc[0], AStartLoc[1], AStartLoc[2], AStartLoc[3], HStartLoc[0], HStartLoc[1], HStartLoc[2], HStartLoc[3]))
             continue;
 
         ++count;
@@ -1542,77 +1135,6 @@
     sLog.outString( ">> Loaded %u battlegrounds", count );
 }
 
-void BattleGroundMgr::InitAutomaticArenaPointDistribution()
-{
-    if(m_AutoDistributePoints)
-    {
-        sLog.outDebug("Initializing Automatic Arena Point Distribution");
-        QueryResult * result = CharacterDatabase.Query("SELECT NextArenaPointDistributionTime FROM saved_variables");
-        if(!result)
-        {
-            sLog.outDebug("Battleground: Next arena point distribution time not found in SavedVariables, reseting it now.");
-            m_NextAutoDistributionTime = time(NULL) + BATTLEGROUND_ARENA_POINT_DISTRIBUTION_DAY * sWorld.getConfig(CONFIG_ARENA_AUTO_DISTRIBUTE_INTERVAL_DAYS);
-            CharacterDatabase.PExecute("INSERT INTO saved_variables (NextArenaPointDistributionTime) VALUES ('"I64FMTD"')", m_NextAutoDistributionTime);
-        }
-        else
-        {
-            m_NextAutoDistributionTime = (*result)[0].GetUInt64();
-            delete result;
-        }
-        sLog.outDebug("Automatic Arena Point Distribution initialized.");
-    }
-}
-
-void BattleGroundMgr::DistributeArenaPoints()
-{ /* [TRINITYROLLBACK]
-    // used to distribute arena points based on last week's stats
-    sWorld.SendGlobalText("Flushing Arena points based on team ratings, this may take a few minutes. Please stand by...", NULL);
-
-    sWorld.SendGlobalText("Distributing arena points to players...", NULL);
-
-    //temporary structure for storing maximum points to add values for all players
-    std::map<uint32, uint32> PlayerPoints;
-
-    //at first update all points for all team members
-    for(ObjectMgr::ArenaTeamMap::iterator team_itr = objmgr.GetArenaTeamMapBegin(); team_itr != objmgr.GetArenaTeamMapEnd(); ++team_itr)
-    {
-        if(ArenaTeam * at = team_itr->second)
-        {
-            at->UpdateArenaPointsHelper(PlayerPoints);
-        }
-    }
-
-    //cycle that gives points to all players
-    for (std::map<uint32, uint32>::iterator plr_itr = PlayerPoints.begin(); plr_itr != PlayerPoints.end(); ++plr_itr)
-    {
-        //update to database
-        CharacterDatabase.PExecute("UPDATE characters SET arena_pending_points = '%u' WHERE `guid` = '%u'", plr_itr->second, plr_itr->first);
-        //add points if player is online
-        Player* pl = objmgr.GetPlayer(plr_itr->first);
-        if (pl)
-            pl->ModifyArenaPoints(plr_itr->second);
-    }
-
-    PlayerPoints.clear();
-
-    sWorld.SendGlobalText("Finished setting arena points for online players.", NULL);
-
-    sWorld.SendGlobalText("Modifying played count, arena points etc. for loaded arena teams, sending updated stats to online players...", NULL);
-    for(ObjectMgr::ArenaTeamMap::iterator titr = objmgr.GetArenaTeamMapBegin(); titr != objmgr.GetArenaTeamMapEnd(); ++titr)
-    {
-        if(ArenaTeam * at = titr->second)
-        {
-            at->FinishWeek();                              // set played this week etc values to 0 in memory, too
-            at->SaveToDB();                                // save changes
-            at->NotifyStatsChanged();                      // notify the players of the changes
-        }
-    }
-
-    sWorld.SendGlobalText("Modification done.", NULL);
-
-    sWorld.SendGlobalText("Done flushing Arena points.", NULL); */
-}
-
 void BattleGroundMgr::BuildBattleGroundListPacket(WorldPacket *data, uint64 guid, Player* plr, uint32 bgTypeId)
 {
     uint32 PlayerLevel = 10;
@@ -1623,13 +1145,7 @@
     data->Initialize(SMSG_BATTLEFIELD_LIST);
     *data << uint64(guid);                                  // battlemaster guid
     *data << uint32(bgTypeId);                              // battleground id
-    if(bgTypeId == BATTLEGROUND_AA)                         // arena
-    {
-        *data << uint8(5);                                  // unk
-        *data << uint32(0);                                 // unk
-    }
-    else                                                    // battleground
-    {
+
         *data << uint8(0x00);                               // unk
 
         size_t count_pos = data->wpos();
@@ -1645,7 +1161,6 @@
             }
         }
         data->put<uint32>( count_pos , count);
-    }
 }
 
 void BattleGroundMgr::SendToBattleGround(Player *pl, uint32 instanceId)
@@ -1686,20 +1201,7 @@
         m_BattleGrounds.erase(itr);
 }
 
-bool BattleGroundMgr::IsArenaType(uint32 bgTypeId) const
-{
-    return ( bgTypeId == BATTLEGROUND_AA ||
-        bgTypeId == BATTLEGROUND_BE ||
-        bgTypeId == BATTLEGROUND_NA ||
-        bgTypeId == BATTLEGROUND_RL );
-}
-
-bool BattleGroundMgr::IsBattleGroundType(uint32 bgTypeId) const
-{
-    return !IsArenaType(bgTypeId);
-}
-
-uint32 BattleGroundMgr::BGQueueTypeId(uint32 bgTypeId, uint8 arenaType) const
+uint32 BattleGroundMgr::BGQueueTypeId(uint32 bgTypeId) const
 {
     switch(bgTypeId)
     {
@@ -1709,23 +1211,6 @@
         return BATTLEGROUND_QUEUE_AB;
     case BATTLEGROUND_AV:
         return BATTLEGROUND_QUEUE_AV;
-    case BATTLEGROUND_EY:
-        return BATTLEGROUND_QUEUE_EY;
-    case BATTLEGROUND_AA:
-    case BATTLEGROUND_NA:
-    case BATTLEGROUND_RL:
-    case BATTLEGROUND_BE:
-        switch(arenaType)
-        {
-        case ARENA_TYPE_2v2:
-            return BATTLEGROUND_QUEUE_2v2;
-        case ARENA_TYPE_3v3:
-            return BATTLEGROUND_QUEUE_3v3;
-        case ARENA_TYPE_5v5:
-            return BATTLEGROUND_QUEUE_5v5;
-        default:
-            return 0;
-        }
     default:
         return 0;
     }
@@ -1741,14 +1226,8 @@
         return BATTLEGROUND_AB;
     case BATTLEGROUND_QUEUE_AV:
         return BATTLEGROUND_AV;
-    case BATTLEGROUND_QUEUE_EY:
-        return BATTLEGROUND_EY;
-    case BATTLEGROUND_QUEUE_2v2:
-    case BATTLEGROUND_QUEUE_3v3:
-    case BATTLEGROUND_QUEUE_5v5:
-        return BATTLEGROUND_AA;
     default:
         return 0;
     }
 }
 
@@ -1750,31 +1229,8 @@
     default:
         return 0;
     }
 }
 
-uint8 BattleGroundMgr::BGArenaType(uint32 bgQueueTypeId) const
-{
-    switch(bgQueueTypeId)
-    {
-    case BATTLEGROUND_QUEUE_2v2:
-        return ARENA_TYPE_2v2;
-    case BATTLEGROUND_QUEUE_3v3:
-        return ARENA_TYPE_3v3;
-    case BATTLEGROUND_QUEUE_5v5:
-        return ARENA_TYPE_5v5;
-    default:
-        return 0;
-    }
-}
-
-void BattleGroundMgr::ToggleArenaTesting()
-{
-    m_ArenaTesting = !m_ArenaTesting;
-    if(m_ArenaTesting)
-        sWorld.SendGlobalText("Arenas are set to 1v1 for debugging. So, don't join as group.", NULL);
-    else
-        sWorld.SendGlobalText("Arenas are set to normal playercount.", NULL);
-}
 
 void BattleGroundMgr::SetHolidayWeekends(uint32 mask)
 {
diff --git a/src/game/BattleGroundMgr.h b/src/game/BattleGroundMgr.h
--- a/src/game/BattleGroundMgr.h
+++ b/src/game/BattleGroundMgr.h
@@ -32,5 +32,5 @@
 //typedef std::map<uint32, BattleGroundQueue*> BattleGroundQueueSet;
 typedef std::deque<BattleGround*> BGFreeSlotQueueType;
 
-#define MAX_BATTLEGROUND_QUEUES 7                           // for level ranges 10-19, 20-29, 30-39, 40-49, 50-59, 60-69, 70+
+#define MAX_BATTLEGROUND_QUEUES 3                           // for level ranges 10-19, 20-29, 30-39, 40-49, 50-59, 60-69, 70+
 
@@ -36,3 +36,3 @@
 
-#define MAX_BATTLEGROUND_TYPES 9                            // each BG type will be in array
+#define MAX_BATTLEGROUND_TYPES 3                            // each BG type will be in array
 
@@ -38,7 +38,5 @@
 
-#define MAX_BATTLEGROUND_QUEUE_TYPES 8
-
-#define BATTLEGROUND_ARENA_POINT_DISTRIBUTION_DAY    86400     // seconds in a day
+#define MAX_BATTLEGROUND_QUEUE_TYPES 3
 
 struct GroupQueueInfo;                                      // type predefinition
 struct PlayerQueueInfo                                      // stores information for players in queue
@@ -55,7 +53,5 @@
     uint32  Team;                                           // Player team (ALLIANCE/HORDE)
     uint32  BgTypeId;                                       // battleground type id
     bool    IsRated;                                        // rated
-    uint8   ArenaType;                                      // 2v2, 3v3, 5v5 or 0 when BG
-    uint32  ArenaTeamId;                                    // team id if rated match
     uint32  JoinTime;                                       // time when group was added
     uint32  IsInvitedToBGInstanceGUID;                      // was invited to certain BG
@@ -60,7 +56,5 @@
     uint32  JoinTime;                                       // time when group was added
     uint32  IsInvitedToBGInstanceGUID;                      // was invited to certain BG
-    uint32  ArenaTeamRating;                                // if rated match, inited to the rating of the team
-    uint32  OpponentsTeamRating;                            // for rated arena matches
 };
 
 class BattleGround;
@@ -70,5 +64,5 @@
         BattleGroundQueue();
         ~BattleGroundQueue();
 
-        void Update(uint32 bgTypeId, uint32 queue_id, uint8 arenatype = 0, bool isRated = false, uint32 minRating = 0);
+        void Update(uint32 bgTypeId, uint32 queue_id);
 
@@ -74,5 +68,5 @@
 
-        GroupQueueInfo * AddGroup(Player * leader, uint32 BgTypeId, uint8 ArenaType, bool isRated, uint32 ArenaRating, uint32 ArenaTeamId = 0);
+        GroupQueueInfo * AddGroup(Player * leader, uint32 BgTypeId);
         void AddPlayer(Player *plr, GroupQueueInfo *ginfo);
         void RemovePlayer(uint64 guid, bool decreaseInvitedCount);
         void DecreaseGroupLength(uint32 queueId, uint32 AsGroup);
@@ -88,7 +82,7 @@
         class EligibleGroups : public std::list<GroupQueueInfo *>
         {
         public:
-            void Init(QueuedGroupsList * source, uint32 BgTypeId, uint32 side, uint32 MaxPlayers, uint8 ArenaType = 0, bool IsRated = false, uint32 MinRating = 0, uint32 MaxRating = 0, uint32 DisregardTime = 0, uint32 excludeTeam = 0);
+            void Init(QueuedGroupsList * source, uint32 BgTypeId, uint32 side, uint32 MaxPlayers, uint32 DisregardTime = 0);
         };
 
         EligibleGroups m_EligibleGroups;
@@ -123,7 +117,7 @@
 
         SelectionPool m_SelectionPools[NUM_SELECTION_POOL_TYPES];
 
-        bool BuildSelectionPool(uint32 bgTypeId, uint32 queue_id, uint32 MinPlayers, uint32 MaxPlayers, SelectionPoolBuildMode mode, uint8 ArenaType = 0, bool isRated = false, uint32 MinRating = 0, uint32 MaxRating = 0, uint32 DisregardTime = 0, uint32 excludeTeam = 0);
+        bool BuildSelectionPool(uint32 bgTypeId, uint32 queue_id, uint32 MinPlayers, uint32 MaxPlayers, SelectionPoolBuildMode mode, uint32 DisregardTime = 0);
 
     private:
 
@@ -179,7 +173,7 @@
         void BuildGroupJoinedBattlegroundPacket(WorldPacket *data, uint32 bgTypeId);
         void BuildUpdateWorldStatePacket(WorldPacket *data, uint32 field, uint32 value);
         void BuildPvpLogDataPacket(WorldPacket *data, BattleGround *bg);
-        void BuildBattleGroundStatusPacket(WorldPacket *data, BattleGround *bg, uint32 team, uint8 QueueSlot, uint8 StatusID, uint32 Time1, uint32 Time2, uint32 arenatype = 0, uint8 israted = 0);
+        void BuildBattleGroundStatusPacket(WorldPacket *data, BattleGround *bg, uint32 team, uint8 QueueSlot, uint8 StatusID, uint32 Time1, uint32 Time2);
         void BuildPlaySoundPacket(WorldPacket *data, uint32 soundid);
 
         /* Player invitation */
@@ -202,7 +196,7 @@
         BattleGround * GetBattleGroundTemplate(uint32 bgTypeId);
         BattleGround * CreateNewBattleGround(uint32 bgTypeId);
 
-        uint32 CreateBattleGround(uint32 bgTypeId, uint32 MinPlayersPerTeam, uint32 MaxPlayersPerTeam, uint32 LevelMin, uint32 LevelMax, char* BattleGroundName, uint32 MapID, float Team1StartLocX, float Team1StartLocY, float Team1StartLocZ, float Team1StartLocO, float Team2StartLocX, float Team2StartLocY, float Team2StartLocZ, float Team2StartLocO);
+        uint32 CreateBattleGround(uint32 bgTypeId, uint32 MinPlayersPerTeam, uint32 MaxPlayersPerTeam, uint32 LevelMin, uint32 LevelMax, float Team1StartLocX, float Team1StartLocY, float Team1StartLocZ, float Team1StartLocO, float Team2StartLocX, float Team2StartLocY, float Team2StartLocZ, float Team2StartLocO);
 
         inline void AddBattleGround(uint32 ID, BattleGround* BG) { m_BattleGrounds[ID] = BG; };
         void RemoveBattleGround(uint32 instanceID);
@@ -219,7 +213,5 @@
 
         void SendAreaSpiritHealerQueryOpcode(Player *pl, BattleGround *bg, uint64 guid);
 
-        bool IsArenaType(uint32 bgTypeId) const;
-        bool IsBattleGroundType(uint32 bgTypeId) const;
-        uint32 BGQueueTypeId(uint32 bgTypeId, uint8 arenaType) const;
+        uint32 BGQueueTypeId(uint32 bgTypeId) const;
         uint32 BGTemplateId(uint32 bgQueueTypeId) const;
@@ -225,5 +217,4 @@
         uint32 BGTemplateId(uint32 bgQueueTypeId) const;
-        uint8 BGArenaType(uint32 bgQueueTypeId) const;
 
         uint32 GetMaxRatingDifference() const {return m_MaxRatingDifference;}
         uint32 GetRatingDiscardTimer() const {return m_RatingDiscardTimer;}
@@ -227,7 +218,4 @@
 
         uint32 GetMaxRatingDifference() const {return m_MaxRatingDifference;}
         uint32 GetRatingDiscardTimer() const {return m_RatingDiscardTimer;}
-
-        void InitAutomaticArenaPointDistribution();
-        void DistributeArenaPoints();
         uint32 GetPrematureFinishTime() const {return m_PrematureFinishTimer;}
@@ -233,6 +221,4 @@
         uint32 GetPrematureFinishTime() const {return m_PrematureFinishTimer;}
-        void ToggleArenaTesting();
-        const bool isArenaTesting() const { return m_ArenaTesting; }
 
         void SetHolidayWeekends(uint32 mask);
     private:
@@ -246,7 +232,6 @@
         uint64 m_NextAutoDistributionTime;
         uint32 m_AutoDistributionTimeChecker;
         uint32 m_PrematureFinishTimer;
-        bool   m_ArenaTesting;
 };
 
 #define sBattleGroundMgr Trinity::Singleton<BattleGroundMgr>::Instance()
diff --git a/src/game/CharacterHandler.cpp b/src/game/CharacterHandler.cpp
--- a/src/game/CharacterHandler.cpp
+++ b/src/game/CharacterHandler.cpp
@@ -84,7 +84,6 @@
         res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADDECLINEDNAMES,   "SELECT genitive, dative, accusative, instrumental, prepositional FROM character_declinedname WHERE guid = '%u'",GUID_LOPART(m_guid));
     // in other case still be dummy query
     res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADGUILD,           "SELECT guildid,rank FROM guild_member WHERE guid = '%u'", GUID_LOPART(m_guid));
-    res &= SetPQuery(PLAYER_LOGIN_QUERY_LOADARENAINFO,       "SELECT arenateamid, played_week, played_season, personal_rating FROM arena_team_member WHERE guid='%u'", GUID_LOPART(m_guid));
 
     return res;
 }
diff --git a/src/game/Chat.cpp b/src/game/Chat.cpp
--- a/src/game/Chat.cpp
+++ b/src/game/Chat.cpp
@@ -128,7 +128,6 @@
         { "mount",          SEC_MODERATOR,      false, &ChatHandler::HandleModifyMountCommand,         "", NULL },
         { "honor",          SEC_MODERATOR,      false, &ChatHandler::HandleModifyHonorCommand,         "", NULL },
         { "rep",            SEC_MODERATOR,      false, &ChatHandler::HandleModifyRepCommand,           "", NULL },
-        { "arena",          SEC_MODERATOR,      false, &ChatHandler::HandleModifyArenaCommand,         "", NULL },
         { "drunk",          SEC_MODERATOR,      false, &ChatHandler::HandleDrunkCommand,               "", NULL },
         { "standstate",     SEC_GAMEMASTER,     false, &ChatHandler::HandleStandStateCommand,          "", NULL },
         { "morph",          SEC_GAMEMASTER,     false, &ChatHandler::HandleMorphCommand,               "", NULL },
@@ -204,7 +203,6 @@
         { "Mod32Value",     SEC_ADMINISTRATOR,  false, &ChatHandler::HandleMod32Value,                 "", NULL },
         { "anim",           SEC_GAMEMASTER,     false, &ChatHandler::HandleAnimCommand,                "", NULL },
         { "lootrecipient",  SEC_GAMEMASTER,     false, &ChatHandler::HandleGetLootRecipient,           "", NULL },
-        { "arena",          SEC_ADMINISTRATOR,  false, &ChatHandler::HandleDebugArenaCommand,          "", NULL },
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
@@ -623,7 +621,6 @@
         { "damage",         SEC_ADMINISTRATOR,  false, &ChatHandler::HandleDamageCommand,              "", NULL },
         { "combatstop",     SEC_GAMEMASTER,     false, &ChatHandler::HandleCombatStopCommand,          "", NULL },
         { "ahbotoptions",   SEC_ADMINISTRATOR,  true,    &ChatHandler::HandleAHBotOptionsCommand,        "", NULL },
-        { "flusharenapoints",    SEC_ADMINISTRATOR, false, &ChatHandler::HandleFlushArenaPointsCommand,         "",   NULL },
         { "chardelete",     SEC_CONSOLE,        true,  &ChatHandler::HandleCharacterDeleteCommand,     "", NULL },
         { "sendmessage",    SEC_ADMINISTRATOR,  true,  &ChatHandler::HandleSendMessageCommand,         "", NULL },
         { "playall",        SEC_ADMINISTRATOR,  false, &ChatHandler::HandlePlayAllCommand,             "", NULL },
@@ -631,7 +628,6 @@
         { "freeze",         SEC_ADMINISTRATOR,  false, &ChatHandler::HandleFreezeCommand,              "", NULL },
         { "unfreeze",       SEC_ADMINISTRATOR,  false, &ChatHandler::HandleUnFreezeCommand,            "", NULL },
         { "listfreeze",     SEC_ADMINISTRATOR,  false, &ChatHandler::HandleListFreezeCommand,          "", NULL },
-        { "flusharenapoints", SEC_ADMINISTRATOR, false, &ChatHandler::HandleFlushArenaPointsCommand,   "", NULL },
         { "possess",        SEC_ADMINISTRATOR,  false, &ChatHandler::HandlePossessCommand,             "", NULL },
         { "unpossess",      SEC_ADMINISTRATOR,  false, &ChatHandler::HandleUnPossessCommand,           "", NULL },
         { "bindsight",      SEC_ADMINISTRATOR,  false, &ChatHandler::HandleBindSightCommand,           "", NULL },
diff --git a/src/game/Chat.h b/src/game/Chat.h
--- a/src/game/Chat.h
+++ b/src/game/Chat.h
@@ -181,7 +181,6 @@
         bool HandleModifyTalentCommand (const char* args);
         bool HandleModifyHonorCommand (const char* args);
         bool HandleModifyRepCommand(const char* args);
-        bool HandleModifyArenaCommand(const char* args);
         bool HandleModifyGenderCommand(const char* args);
 
         bool HandleNpcAddCommand(const char* args);
@@ -469,7 +468,6 @@
         bool HandleCombatStopCommand(const char *args);
         bool HandleCharDeleteCommand(const char *args);
         bool HandleSendMessageCommand(const char * args);
-        bool HandleFlushArenaPointsCommand(const char *args);
         bool HandlePlayAllCommand(const char* args);
         bool HandleRepairitemsCommand(const char* args);
 
@@ -487,7 +485,6 @@
         bool HandleSaveAllCommand(const char* args);
         bool HandleGetItemState(const char * args);
         bool HandleGetLootRecipient(const char * args);
-        bool HandleDebugArenaCommand(const char * args);
         bool HandleDebugThreatList(const char * args);
         bool HandleDebugHostilRefList(const char * args);
         bool HandlePossessCommand(const char* args);
diff --git a/src/game/Creature.cpp b/src/game/Creature.cpp
--- a/src/game/Creature.cpp
+++ b/src/game/Creature.cpp
@@ -754,11 +754,6 @@
             case BATTLEGROUND_AV:  pPlayer->PlayerTalkClass->SendGossipMenu(7616,GetGUID()); break;
             case BATTLEGROUND_WS:  pPlayer->PlayerTalkClass->SendGossipMenu(7599,GetGUID()); break;
             case BATTLEGROUND_AB:  pPlayer->PlayerTalkClass->SendGossipMenu(7642,GetGUID()); break;
-            case BATTLEGROUND_EY:
-            case BATTLEGROUND_NA:
-            case BATTLEGROUND_BE:
-            case BATTLEGROUND_AA:
-            case BATTLEGROUND_RL:  pPlayer->PlayerTalkClass->SendGossipMenu(10024,GetGUID()); break;
             break;
         }
         return false;
diff --git a/src/game/Debugcmds.cpp b/src/game/Debugcmds.cpp
--- a/src/game/Debugcmds.cpp
+++ b/src/game/Debugcmds.cpp
@@ -542,12 +542,6 @@
     return true;
 }
 
-bool ChatHandler::HandleDebugArenaCommand(const char * /*args*/)
-{
-    sBattleGroundMgr.ToggleArenaTesting();
-    return true;
-}
-
 bool ChatHandler::HandleDebugThreatList(const char * /*args*/)
 {
     Creature* target = getSelectedCreature();
diff --git a/src/game/GameObject.cpp b/src/game/GameObject.cpp
--- a/src/game/GameObject.cpp
+++ b/src/game/GameObject.cpp
@@ -1265,10 +1265,6 @@
                             if(bg->GetTypeID() == BATTLEGROUND_WS)
                                 bg->EventPlayerClickedOnFlag(player, this);
                             break;
-                        case 184142:                        // Netherstorm Flag
-                            if(bg->GetTypeID() == BATTLEGROUND_EY)
-                                bg->EventPlayerClickedOnFlag(player, this);
-                            break;
                     }
                 }
                 //this cause to call return, all flags must be deleted here!!
diff --git a/src/game/Group.cpp b/src/game/Group.cpp
--- a/src/game/Group.cpp
+++ b/src/game/Group.cpp
@@ -881,5 +877,4 @@
                                                             // guess size
         WorldPacket data(SMSG_GROUP_LIST, (1+1+1+1+8+4+GetMembersCount()*20));
         data << (uint8)m_groupType;                         // group type
-        data << (uint8)(isBGGroup() ? 1 : 0);               // 2.0.x, isBattleGroundGroup?
         data << (uint8)(citr->group);                       // groupid
@@ -885,6 +880,4 @@
         data << (uint8)(citr->group);                       // groupid
-        data << (uint8)(citr->assistant?0x01:0);            // 0x2 main assist, 0x4 main tank
-        data << uint64(0x50000000FFFFFFFELL);               // related to voice chat?
         data << uint32(GetMembersCount()-1);
         for(member_citerator citr2 = m_memberSlots.begin(); citr2 != m_memberSlots.end(); ++citr2)
         {
@@ -892,6 +885,5 @@
                 continue;
 
             data << citr2->name;
-            data << (uint64)citr2->guid;
-                                                            // online-state
+            data << citr2->guid;
             data << (uint8)(objmgr.GetPlayer(citr2->guid) ? 1 : 0);
@@ -897,5 +889,4 @@
             data << (uint8)(objmgr.GetPlayer(citr2->guid) ? 1 : 0);
-            data << (uint8)(citr2->group);                  // groupid
-            data << (uint8)(citr2->assistant?0x01:0);       // 0x2 main assist, 0x4 main tank
+            data << (uint8)(citr2->group | (citr2->assistant?0x01:0));     // 0x2 main assist, 0x4 main tank  
         }
 
@@ -900,5 +891,5 @@
         }
 
-        data << uint64(m_leaderGuid);                       // leader guid
+        data << m_leaderGuid;                       // leader guid
         if(GetMembersCount()-1)
         {
@@ -903,5 +894,5 @@
         if(GetMembersCount()-1)
         {
-            data << (uint8)m_lootMethod;                    // loot method
+            data << m_lootMethod;                    // loot method
             data << (uint64)m_looterGuid;                   // looter guid
             data << (uint8)m_lootThreshold;                 // loot threshold
@@ -906,7 +897,6 @@
             data << (uint64)m_looterGuid;                   // looter guid
             data << (uint8)m_lootThreshold;                 // loot threshold
-            data << (uint8)m_difficulty;                    // Heroic Mod Group
-
+            data << (uint16)2;
         }
         player->GetSession()->SendPacket( &data );
     }
@@ -1315,7 +1305,7 @@
     SendUpdate();
 }
 
-uint32 Group::CanJoinBattleGroundQueue(uint32 bgTypeId, uint32 bgQueueType, uint32 MinPlayerCount, uint32 MaxPlayerCount, bool isRated, uint32 arenaSlot)
+uint32 Group::CanJoinBattleGroundQueue(uint32 bgTypeId, uint32 bgQueueType, uint32 MinPlayerCount, uint32 MaxPlayerCount)
 {
     // check for min / max count
     uint32 memberscount = GetMembersCount();
@@ -1324,10 +1314,10 @@
     if(memberscount > MaxPlayerCount)
         return BG_JOIN_ERR_GROUP_TOO_MANY;
 
-    // get a player as reference, to compare other players' stats to (arena team id, queue id based on level, etc.)
+    // get a player as reference, to compare other players' stats to ( queue id based on level, etc.)
     Player * reference = GetFirstMember()->getSource();
     // no reference found, can't join this way
     if(!reference)
         return BG_JOIN_ERR_OFFLINE_MEMBER;
 
     uint32 bgQueueId = reference->GetBattleGroundQueueIdFromLevel();
@@ -1328,10 +1318,9 @@
     Player * reference = GetFirstMember()->getSource();
     // no reference found, can't join this way
     if(!reference)
         return BG_JOIN_ERR_OFFLINE_MEMBER;
 
     uint32 bgQueueId = reference->GetBattleGroundQueueIdFromLevel();
- //  [TRINITYROLLBACK]  uint32 arenaTeamId = reference->GetArenaTeamId(arenaSlot);
     uint32 team = reference->GetTeam();
 
     // check every member of the group to be able to join
@@ -1347,9 +1336,6 @@
         // not in the same battleground level braket, don't let join
         if(member->GetBattleGroundQueueIdFromLevel() != bgQueueId)
             return BG_JOIN_ERR_MIXED_LEVELS;
-        // don't let join rated matches if the arena team id doesn't match
-  /* [TRINITYROLLBACK]     if(isRated && member->GetArenaTeamId(arenaSlot) != arenaTeamId) 
-            return BG_JOIN_ERR_MIXED_ARENATEAM; */
         // don't let join if someone from the group is already in that bg queue
         if(member->InBattleGroundQueueForBattleGroundQueueType(bgQueueType))
             return BG_JOIN_ERR_GROUP_MEMBER_ALREADY_IN_QUEUE;
@@ -1353,8 +1339,7 @@
         // don't let join if someone from the group is already in that bg queue
         if(member->InBattleGroundQueueForBattleGroundQueueType(bgQueueType))
             return BG_JOIN_ERR_GROUP_MEMBER_ALREADY_IN_QUEUE;
-        // check for deserter debuff in case not arena queue
-        if(bgTypeId != BATTLEGROUND_AA && !member->CanJoinToBattleground())
+        if(!member->CanJoinToBattleground())
             return BG_JOIN_ERR_GROUP_DESERTER;
         // check if member can join any more battleground queues
         if(!member->HasFreeBattleGroundQueueId())
diff --git a/src/game/Group.h b/src/game/Group.h
--- a/src/game/Group.h
+++ b/src/game/Group.h
@@ -249,7 +248,7 @@
         void ConvertToRaid();
 
         void SetBattlegroundGroup(BattleGround *bg) { m_bgGroup = bg; }
-        uint32 CanJoinBattleGroundQueue(uint32 bgTypeId, uint32 bgQueueType, uint32 MinPlayerCount, uint32 MaxPlayerCount, bool isRated, uint32 arenaSlot);
+        uint32 CanJoinBattleGroundQueue(uint32 bgTypeId, uint32 bgQueueType, uint32 MinPlayerCount, uint32 MaxPlayerCount);
 
         void ChangeMembersGroup(const uint64 &guid, const uint8 &group);
         void ChangeMembersGroup(Player *player, const uint8 &group);
diff --git a/src/game/Item.cpp b/src/game/Item.cpp
--- a/src/game/Item.cpp
+++ b/src/game/Item.cpp
@@ -799,67 +748,6 @@
     SetState(ITEM_CHANGED);
 }
 
-bool Item::GemsFitSockets() const
-{
-    bool fits = true;
-    for(uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
-    {
-        uint8 SocketColor = GetProto()->Socket[enchant_slot-SOCK_ENCHANTMENT_SLOT].Color;
-
-        uint32 enchant_id = GetEnchantmentId(EnchantmentSlot(enchant_slot));
-        if(!enchant_id)
-        {
-            if(SocketColor) fits &= false;
-            continue;
-        }
-
-        SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
-        if(!enchantEntry)
-        {
-            if(SocketColor) fits &= false;
-            continue;
-        }
-
-        uint8 GemColor = 0;
-
-        /*
-		uint32 gemid = enchantEntry->GemID;
-        if(gemid)
-        {
-            ItemPrototype const* gemProto = sItemStorage.LookupEntry<ItemPrototype>(gemid);
-            if(gemProto)
-            {
-                GemPropertiesEntry const* gemProperty = sGemPropertiesStore.LookupEntry(gemProto->GemProperties);
-                if(gemProperty)
-                    GemColor = gemProperty->color;
-            }
-        }
-		*/
-
-        fits &= (GemColor & SocketColor) ? true : false;
-    }
-    return fits;
-}
-
-uint8 Item::GetGemCountWithID(uint32 GemID) const
-{
-    uint8 count = 0;
-    for(uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
-    {
-        uint32 enchant_id = GetEnchantmentId(EnchantmentSlot(enchant_slot));
-        if(!enchant_id)
-            continue;
-
-        SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
-        if(!enchantEntry)
-            continue;
-
-        //if(GemID == enchantEntry->GemID)
-        //    ++count;
-    }
-    return count;
-}
-
 bool Item::IsLimitedToAnotherMapOrZone( uint32 cur_mapId, uint32 cur_zoneId) const
 {
     ItemPrototype const* proto = GetProto();
diff --git a/src/game/Item.h b/src/game/Item.h
--- a/src/game/Item.h
+++ b/src/game/Item.h
@@ -110,11 +110,9 @@
     EQUIP_ERR_LOOT_CANT_LOOT_THAT_NOW            = 66,
     EQUIP_ERR_ITEM_UNIQUE_EQUIPABLE              = 67,
     EQUIP_ERR_VENDOR_MISSING_TURNINS             = 68,
-    EQUIP_ERR_NOT_ENOUGH_HONOR_POINTS            = 69,
-    EQUIP_ERR_NOT_ENOUGH_ARENA_POINTS            = 70,
     EQUIP_ERR_ITEM_MAX_COUNT_SOCKETED            = 71,
     EQUIP_ERR_MAIL_BOUND_ITEM                    = 72,
     EQUIP_ERR_NO_SPLIT_WHILE_PROSPECTING         = 73,
     EQUIP_ERR_ITEM_MAX_COUNT_EQUIPPED_SOCKETED   = 75,
     EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE_SOCKETED    = 76,
     EQUIP_ERR_TOO_MUCH_GOLD                      = 77,
@@ -115,8 +113,7 @@
     EQUIP_ERR_ITEM_MAX_COUNT_SOCKETED            = 71,
     EQUIP_ERR_MAIL_BOUND_ITEM                    = 72,
     EQUIP_ERR_NO_SPLIT_WHILE_PROSPECTING         = 73,
     EQUIP_ERR_ITEM_MAX_COUNT_EQUIPPED_SOCKETED   = 75,
     EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE_SOCKETED    = 76,
     EQUIP_ERR_TOO_MUCH_GOLD                      = 77,
-    EQUIP_ERR_NOT_DURING_ARENA_MATCH             = 78,
     EQUIP_ERR_CANNOT_TRADE_THAT                  = 79,
@@ -122,5 +119,4 @@
     EQUIP_ERR_CANNOT_TRADE_THAT                  = 79,
-    EQUIP_ERR_PERSONAL_ARENA_RATING_TOO_LOW      = 80
     // probably exist more
 };
 
@@ -164,7 +160,7 @@
     PROP_ENCHANTMENT_SLOT_2     = 8,                        // used with RandomSuffix and RandomProperty
     PROP_ENCHANTMENT_SLOT_3     = 9,                        // used with RandomProperty
     PROP_ENCHANTMENT_SLOT_4     = 10,                       // used with RandomProperty
-    MAX_ENCHANTMENT_SLOT        = 11
+    MAX_ENCHANTMENT_SLOT        = 7
 };
 
 #define MAX_VISIBLE_ITEM_OFFSET   16                        // 16 fields per visible item (creator(2) + enchantments(12) + properties(1) + pad(1))
@@ -229,8 +225,7 @@
 
         bool IsFitToSpellRequirements(SpellEntry const* spellInfo) const;
         bool IsLimitedToAnotherMapOrZone( uint32 cur_mapId, uint32 cur_zoneId) const;
-        bool GemsFitSockets() const;
 
         uint32 GetCount() const { return GetUInt32Value (ITEM_FIELD_STACK_COUNT); }
         void SetCount(uint32 value) { SetUInt32Value (ITEM_FIELD_STACK_COUNT, value); }
         uint32 GetMaxStackCount() const { return GetProto()->Stackable; }
@@ -233,8 +228,7 @@
 
         uint32 GetCount() const { return GetUInt32Value (ITEM_FIELD_STACK_COUNT); }
         void SetCount(uint32 value) { SetUInt32Value (ITEM_FIELD_STACK_COUNT, value); }
         uint32 GetMaxStackCount() const { return GetProto()->Stackable; }
-        uint8 GetGemCountWithID(uint32 GemID) const;
 
         uint8 GetSlot() const {return m_slot;}
         Bag *GetContainer() { return m_container; }
diff --git a/src/game/ItemHandler.cpp b/src/game/ItemHandler.cpp
--- a/src/game/ItemHandler.cpp
+++ b/src/game/ItemHandler.cpp
@@ -324,7 +324,6 @@
         data << pProto->ItemId;
         data << pProto->Class;
         data << pProto->SubClass;
-        data << uint32(-1);                                 // new 2.0.3, not exist in wdb cache?
         data << Name;
         data << uint8(0x00);                                //pProto->Name2; // blizz not send name there, just uint8(0x00); <-- \0 = empty string = empty name...
         data << uint8(0x00);                                //pProto->Name3; // blizz not send name there, just uint8(0x00);
@@ -424,16 +422,8 @@
         data << pProto->Block;
         data << pProto->ItemSet;
         data << pProto->MaxDurability;
         data << pProto->Area;
         data << pProto->Map;                                // Added in 1.12.x & 2.0.1 client branch
         data << pProto->BagFamily;
-        data << pProto->TotemCategory;
-        for(int s = 0; s < 3; s++)
-        {
-            data << pProto->Socket[s].Color;
-            data << pProto->Socket[s].Content;
-        }
-        data << pProto->socketBonus;
-        data << pProto->GemProperties;
         data << pProto->RequiredDisenchantSkill;
         data << pProto->ArmorDamageModifier;
@@ -438,6 +428,5 @@
         data << pProto->RequiredDisenchantSkill;
         data << pProto->ArmorDamageModifier;
-        data << uint32(0);                                  // added in 2.4.2.8209, duration (seconds)
         SendPacket( &data );
     }
     else
@@ -1102,137 +1091,6 @@
     _player->DestroyItemCount(gift, count, true);
 }
 
-void WorldSession::HandleSocketOpcode(WorldPacket& recv_data)
-{
-    sLog.outDebug("WORLD: CMSG_SOCKET_GEMS");
-
-    CHECK_PACKET_SIZE(recv_data,8*4);
-
-    uint64 guids[4];
-    uint32 GemEnchants[3], OldEnchants[3];
-    Item *Gems[3];
-    bool SocketBonusActivated, SocketBonusToBeActivated;
-
-    for(int i = 0; i < 4; i++)
-        recv_data >> guids[i];
-
-    if(!guids[0])
-        return;
-
-    //cheat -> tried to socket same gem multiple times
-    if((guids[1] && (guids[1] == guids[2] || guids[1] == guids[3])) || (guids[2] && (guids[2] == guids[3])))
-        return;
-
-    Item *itemTarget = _player->GetItemByGuid(guids[0]);
-    if(!itemTarget)                                         //missing item to socket
-        return;
-
-    //this slot is excepted when applying / removing meta gem bonus
-    uint8 slot = itemTarget->IsEquipped() ? itemTarget->GetSlot() : NULL_SLOT;
-
-    for(int i = 0; i < 3; i++)
-        Gems[i] = guids[i + 1] ? _player->GetItemByGuid(guids[i + 1]) : NULL;
-
-    GemPropertiesEntry const *GemProps[3];
-    for(int i = 0; i < 3; ++i)                              //get geminfo from dbc storage
-    {
-        GemProps[i] = (Gems[i]) ? sGemPropertiesStore.LookupEntry(Gems[i]->GetProto()->GemProperties) : NULL;
-    }
-
-    for(int i = 0; i < 3; ++i)                              //check for hack maybe
-    {
-        // tried to put gem in socket where no socket exists / tried to put normal gem in meta socket
-        // tried to put meta gem in normal socket
-        if( GemProps[i] && ( !itemTarget->GetProto()->Socket[i].Color ||
-            itemTarget->GetProto()->Socket[i].Color == SOCKET_COLOR_META && GemProps[i]->color != SOCKET_COLOR_META ||
-            itemTarget->GetProto()->Socket[i].Color != SOCKET_COLOR_META && GemProps[i]->color == SOCKET_COLOR_META ) )
-            return;
-    }
-
-    for(int i = 0; i < 3; ++i)                              //get new and old enchantments
-    {
-        GemEnchants[i] = (GemProps[i]) ? GemProps[i]->spellitemenchantement : 0;
-        OldEnchants[i] = itemTarget->GetEnchantmentId(EnchantmentSlot(SOCK_ENCHANTMENT_SLOT+i));
-    }
-
-    // check unique-equipped conditions
-    for(int i = 0; i < 3; ++i)
-    {
-        if (Gems[i] && (Gems[i]->GetProto()->Flags & ITEM_FLAGS_UNIQUE_EQUIPPED))
-        {
-            // for equipped item check all equipment for duplicate equipped gems
-            if(itemTarget->IsEquipped())
-            {
-                if(GetPlayer()->GetItemOrItemWithGemEquipped(Gems[i]->GetEntry()))
-                {
-                    _player->SendEquipError( EQUIP_ERR_ITEM_UNIQUE_EQUIPABLE, itemTarget, NULL );
-                    return;
-                }
-            }
-
-            // continue check for case when attempt add 2 similar unique equipped gems in one item.
-            for (int j = 0; j < 3; ++j)
-            {
-                if ((i != j) && (Gems[j]) && (Gems[i]->GetProto()->ItemId == Gems[j]->GetProto()->ItemId))
-                {
-                    _player->SendEquipError( EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE_SOCKETED, itemTarget, NULL );
-                    return;
-                }
-            }
-            /*
-			for (int j = 0; j < 3; ++j)
-            {
-                if (OldEnchants[j])
-                {
-                    SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(OldEnchants[j]);
-                    if(!enchantEntry)
-                        continue;
-
-                    if ((enchantEntry->GemID == Gems[i]->GetProto()->ItemId) && (i != j))
-                    {
-                        _player->SendEquipError( EQUIP_ERR_ITEM_UNIQUE_EQUIPPABLE_SOCKETED, itemTarget, NULL );
-                        return;
-                    }
-                }
-            }
-			*/
-        }
-    }
-
-    SocketBonusActivated = itemTarget->GemsFitSockets();    //save state of socketbonus
-    _player->ToggleMetaGemsActive(slot, false);             //turn off all metagems (except for the target item)
-
-    //if a meta gem is being equipped, all information has to be written to the item before testing if the conditions for the gem are met
-
-    //remove ALL enchants
-    for(uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
-        _player->ApplyEnchantment(itemTarget,EnchantmentSlot(enchant_slot),false);
-
-    for(int i = 0; i < 3; ++i)
-    {
-        if(GemEnchants[i])
-        {
-            itemTarget->SetEnchantment(EnchantmentSlot(SOCK_ENCHANTMENT_SLOT+i), GemEnchants[i],0,0);
-            if(Item* guidItem = _player->GetItemByGuid(guids[i + 1]))
-                _player->DestroyItem(guidItem->GetBagSlot(), guidItem->GetSlot(), true );
-        }
-    }
-
-    for(uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
-        _player->ApplyEnchantment(itemTarget,EnchantmentSlot(enchant_slot),true);
-
-    SocketBonusToBeActivated = itemTarget->GemsFitSockets();//current socketbonus state
-    if(SocketBonusActivated ^ SocketBonusToBeActivated)     //if there was a change...
-    {
-        _player->ApplyEnchantment(itemTarget,BONUS_ENCHANTMENT_SLOT,false);
-        itemTarget->SetEnchantment(BONUS_ENCHANTMENT_SLOT, (SocketBonusToBeActivated ? itemTarget->GetProto()->socketBonus : 0), 0, 0);
-        _player->ApplyEnchantment(itemTarget,BONUS_ENCHANTMENT_SLOT,true);
-        //it is not displayed, client has an inbuilt system to determine if the bonus is activated
-    }
-
-    _player->ToggleMetaGemsActive(slot, true);              //turn on all metagems (except for target item)
-}
-
 void WorldSession::HandleCancelTempItemEnchantmentOpcode(WorldPacket& recv_data)
 {
     sLog.outDebug("WORLD: CMSG_CANCEL_TEMP_ENCHANTMENT");
diff --git a/src/game/ItemPrototype.h b/src/game/ItemPrototype.h
--- a/src/game/ItemPrototype.h
+++ b/src/game/ItemPrototype.h
@@ -97,5 +97,5 @@
     ITEM_FLAGS_WRAPPED                        = 0x00000008,
     ITEM_FLAGS_WRAPPER                        = 0x00000200, // used or not used wrapper
     ITEM_FLAGS_PARTY_LOOT                     = 0x00000800, // determines if item is party loot or not
-    ITEM_FLAGS_CHARTER                        = 0x00002000, // arena/guild charter
+    ITEM_FLAGS_CHARTER                        = 0x00002000, // guild charter
     ITEM_FLAGS_UNIQUE_EQUIPPED                = 0x00080000,
@@ -101,3 +101,2 @@
     ITEM_FLAGS_UNIQUE_EQUIPPED                = 0x00080000,
-    ITEM_FLAGS_USEABLE_IN_ARENA               = 0x00200000,
     ITEM_FLAGS_THROWABLE                      = 0x00400000, // not used in game for check trow possibility, only for item in game tooltip
@@ -103,5 +102,4 @@
     ITEM_FLAGS_THROWABLE                      = 0x00400000, // not used in game for check trow possibility, only for item in game tooltip
-    ITEM_FLAGS_SPECIALUSE                     = 0x00800000, // last used flag in 2.3.0
     ITEM_FLAGS_BOA                            = 0x08000000, // bind on account
     ITEM_FLAGS_MILLABLE                       = 0x20000000
 };
@@ -130,15 +128,6 @@
     BAG_FAMILY_MASK_QUEST_ITEMS               = 0x00004000
 };
 
-enum SocketColor
-{
-    SOCKET_COLOR_META                           = 1,
-    SOCKET_COLOR_RED                            = 2,
-    SOCKET_COLOR_YELLOW                         = 4,
-    SOCKET_COLOR_BLUE                           = 8
-};
-
-#define SOCKET_COLOR_ALL (SOCKET_COLOR_META | SOCKET_COLOR_RED | SOCKET_COLOR_YELLOW | SOCKET_COLOR_BLUE)
 
 enum InventoryType
 {
@@ -254,22 +243,6 @@
 
 #define MAX_ITEM_SUBCLASS_WEAPON                  21
 
-/* [TRINITYROLLBACK] tbc enumerations
-enum ItemSubclassGem
-{
-    ITEM_SUBCLASS_GEM_RED                       = 0,
-    ITEM_SUBCLASS_GEM_BLUE                      = 1,
-    ITEM_SUBCLASS_GEM_YELLOW                    = 2,
-    ITEM_SUBCLASS_GEM_PURPLE                    = 3,
-    ITEM_SUBCLASS_GEM_GREEN                     = 4,
-    ITEM_SUBCLASS_GEM_ORANGE                    = 5,
-    ITEM_SUBCLASS_GEM_META                      = 6,
-    ITEM_SUBCLASS_GEM_SIMPLE                    = 7,
-    ITEM_SUBCLASS_GEM_PRISMATIC                 = 8
-}; */
-
-#define MAX_ITEM_SUBCLASS_GEM                     9
-
 enum ItemSubclassArmor
 {
     ITEM_SUBCLASS_ARMOR_MISC                    = 0,
@@ -400,25 +373,8 @@
 
 #define MAX_ITEM_SUBCLASS_JUNK                    6
 
-/* [TRINITYROLLBACK] tbc enumerations [?]
-enum ItemSubclassGlyph
-{
-    ITEM_SUBCLASS_GLYPH_WARRIOR                 = 1,
-    ITEM_SUBCLASS_GLYPH_PALADIN                 = 2,
-    ITEM_SUBCLASS_GLYPH_HUNTER                  = 3,
-    ITEM_SUBCLASS_GLYPH_ROGUE                   = 4,
-    ITEM_SUBCLASS_GLYPH_PRIEST                  = 5,
-    ITEM_SUBCLASS_GLYPH_DEATH_KNIGHT            = 6,
-    ITEM_SUBCLASS_GLYPH_SHAMAN                  = 7,
-    ITEM_SUBCLASS_GLYPH_MAGE                    = 8,
-    ITEM_SUBCLASS_GLYPH_WARLOCK                 = 9,
-    ITEM_SUBCLASS_GLYPH_DRUID                   = 11
-};
-*/
-#define MAX_ITEM_SUBCLASS_GLYPH                   12
-
 const uint32 MaxItemSubclassValues[MAX_ITEM_CLASS] =
 {
     MAX_ITEM_SUBCLASS_CONSUMABLE,
     MAX_ITEM_SUBCLASS_CONTAINER,
     MAX_ITEM_SUBCLASS_WEAPON,
@@ -420,9 +376,8 @@
 const uint32 MaxItemSubclassValues[MAX_ITEM_CLASS] =
 {
     MAX_ITEM_SUBCLASS_CONSUMABLE,
     MAX_ITEM_SUBCLASS_CONTAINER,
     MAX_ITEM_SUBCLASS_WEAPON,
-    MAX_ITEM_SUBCLASS_GEM,
     MAX_ITEM_SUBCLASS_ARMOR,
     MAX_ITEM_SUBCLASS_REAGENT,
     MAX_ITEM_SUBCLASS_PROJECTILE,
@@ -538,9 +492,7 @@
     uint32 Block;
     uint32 ItemSet;                                         // id from ItemSet.dbc
     uint32 MaxDurability;
     uint32 Area;                                            // id from AreaTable.dbc
     uint32 Map;                                             // id from Map.dbc
     uint32 BagFamily;                                       // id from ItemBagFamily.dbc
-    uint32 TotemCategory;                                   // id from TotemCategory.dbc
-    _Socket Socket[3];
     uint32 socketBonus;                                     // id from SpellItemEnchantment.dbc
@@ -546,5 +498,4 @@
     uint32 socketBonus;                                     // id from SpellItemEnchantment.dbc
-    uint32 GemProperties;                                   // id from GemProperties.dbc
     uint32 RequiredDisenchantSkill;
     float  ArmorDamageModifier;
     uint32 ScriptId;
diff --git a/src/game/Language.h b/src/game/Language.h
--- a/src/game/Language.h
+++ b/src/game/Language.h
@@ -283,7 +283,6 @@
     LANG_YOU_ENABLE_CHAT                = 304,
 
     LANG_COMMAND_MODIFY_REP             = 305,
-    LANG_COMMAND_MODIFY_ARENA           = 306,
     LANG_COMMAND_FACTION_NOTFOUND       = 307,
     LANG_COMMAND_FACTION_UNKNOWN        = 308,
     LANG_COMMAND_FACTION_INVPARAM       = 309,
@@ -577,10 +576,6 @@
     LANG_BG_WS_ALLIANCE_FLAG_RESPAWNED  = 614,
     LANG_BG_WS_HORDE_FLAG_RESPAWNED     = 615,
 
-    LANG_BG_EY_ONE_MINUTE               = 636,
-    LANG_BG_EY_HALF_MINUTE              = 637,
-    LANG_BG_EY_BEGIN                    = 638,
-
     LANG_BG_AB_ALLY                     = 650,
     LANG_BG_AB_HORDE                    = 651,
     LANG_BG_AB_NODE_STABLES             = 652,
@@ -599,34 +594,6 @@
     LANG_BG_AB_H_NEAR_VICTORY           = 665,
     LANG_BG_MARK_BY_MAIL                = 666,
 
-    LANG_BG_EY_HAS_TAKEN_A_M_TOWER      = 667,
-    LANG_BG_EY_HAS_TAKEN_H_M_TOWER      = 668,
-    LANG_BG_EY_HAS_TAKEN_A_D_RUINS      = 669,
-    LANG_BG_EY_HAS_TAKEN_H_D_RUINS      = 670,
-    LANG_BG_EY_HAS_TAKEN_A_B_TOWER      = 671,
-    LANG_BG_EY_HAS_TAKEN_H_B_TOWER      = 672,
-    LANG_BG_EY_HAS_TAKEN_A_F_RUINS      = 673,
-    LANG_BG_EY_HAS_TAKEN_H_F_RUINS      = 674,
-    LANG_BG_EY_HAS_LOST_A_M_TOWER       = 675,
-    LANG_BG_EY_HAS_LOST_H_M_TOWER       = 676,
-    LANG_BG_EY_HAS_LOST_A_D_RUINS       = 677,
-    LANG_BG_EY_HAS_LOST_H_D_RUINS       = 678,
-    LANG_BG_EY_HAS_LOST_A_B_TOWER       = 679,
-    LANG_BG_EY_HAS_LOST_H_B_TOWER       = 680,
-    LANG_BG_EY_HAS_LOST_A_F_RUINS       = 681,
-    LANG_BG_EY_HAS_LOST_H_F_RUINS       = 682,
-    LANG_BG_EY_HAS_TAKEN_FLAG           = 683,
-    LANG_BG_EY_CAPTURED_FLAG_A          = 684,
-    LANG_BG_EY_CAPTURED_FLAG_H          = 685,
-    LANG_BG_EY_DROPPED_FLAG             = 686,
-    LANG_BG_EY_RESETED_FLAG             = 687,
-
-    LANG_ARENA_ONE_TOOLOW               = 700,
-    LANG_ARENA_ONE_MINUTE               = 701,
-    LANG_ARENA_THIRTY_SECONDS           = 702,
-    LANG_ARENA_FIFTEEN_SECONDS          = 703,
-    LANG_ARENA_BEGUN                    = 704,
-
     LANG_WAIT_BEFORE_SPEAKING           = 705,
     LANG_NOT_EQUIPPED_ITEM              = 706,
     LANG_PLAYER_DND                     = 707,
@@ -637,7 +604,4 @@
     LANG_BG_QUEUE_ANNOUNCE_SELF         = 711,
     LANG_BG_QUEUE_ANNOUNCE_WORLD        = 712,
 
-
-    LANG_YOUR_ARENA_LEVEL_REQ_ERROR     = 713,
-//    LANG_HIS_ARENA_LEVEL_REQ_ERROR      = 714, an opcode exists for this
     LANG_YOUR_BG_LEVEL_REQ_ERROR        = 715,
@@ -643,5 +607,4 @@
     LANG_YOUR_BG_LEVEL_REQ_ERROR        = 715,
-//    LANG_YOUR_ARENA_TEAM_FULL           = 716, an opcode exists for this
 
     LANG_BG_AV_ALLY                     = 717,
     LANG_BG_AV_HORDE                    = 718,
@@ -683,9 +646,7 @@
 
     // Room for BG/ARENA                  751-769 not used
 
-    LANG_ARENA_TESTING                  = 785,
-
     LANG_AUTO_ANN                       = 786,
     LANG_ANNOUNCE_COLOR                 = 787,
 
     LANG_BG_GROUP_TOO_LARGE             = 1122, // "Your group is too large for this battleground. Please regroup to join."
@@ -688,12 +649,7 @@
     LANG_AUTO_ANN                       = 786,
     LANG_ANNOUNCE_COLOR                 = 787,
 
     LANG_BG_GROUP_TOO_LARGE             = 1122, // "Your group is too large for this battleground. Please regroup to join."
-    LANG_ARENA_GROUP_TOO_LARGE          = 1123, // "Your group is too large for this arena. Please regroup to join."
-    LANG_ARENA_YOUR_TEAM_ONLY           = 1124, // "Your group has members not in your arena team. Please regroup to join."
-    LANG_ARENA_NOT_ENOUGH_PLAYERS       = 1125, // "Your group does not have enough players to join this match."
-    LANG_ARENA_GOLD_WINS                = 1126, // "The Gold Team wins!"
-    LANG_ARENA_GREEN_WINS               = 1127, // "The Green Team wins!"
     LANG_BATTLEGROUND_PREMATURE_FINISH_WARNING = 1128,   // The battleground will end soon, because there aren't enough players. Get more ppl or win already!
     LANG_BG_GROUP_OFFLINE_MEMBER        = 1129, // "Your group has an offline member. Please remove him before joining."
     LANG_BG_GROUP_MIXED_FACTION         = 1130, // "Your group has players from the opposing faction. You can't join the battleground as a group."
@@ -702,8 +658,8 @@
     LANG_BG_GROUP_MEMBER_DESERTER       = 1133, // "Someone in your party is Deserter. You can't join as group."
     LANG_BG_GROUP_MEMBER_NO_FREE_QUEUE_SLOTS = 1134, // "Someone in your party is already in three battleground queues. You cannot join as group."
 
-    LANG_CANNOT_TELE_TO_BG              = 1135, // "You cannot teleport to a battleground or arena map."
-    LANG_CANNOT_SUMMON_TO_BG            = 1136, // "You cannot summon players to a battleground or arena map."
+    LANG_CANNOT_TELE_TO_BG              = 1135, // "You cannot teleport to a battleground map."
+    LANG_CANNOT_SUMMON_TO_BG            = 1136, // "You cannot summon players to a battleground map."
     LANG_CANNOT_GO_TO_BG_GM             = 1137, // "You must be in GM mode to teleport to a player in a battleground."
     LANG_CANNOT_GO_TO_BG_FROM_BG        = 1138, // "You cannot teleport to a battleground from another battleground. Please leave the current battleground first."
 
diff --git a/src/game/Level1.cpp b/src/game/Level1.cpp
--- a/src/game/Level1.cpp
+++ b/src/game/Level1.cpp
@@ -760,7 +760,7 @@
 
         Map* pMap = m_session->GetPlayer()->GetMap();
 
-        if(pMap->IsBattleGroundOrArena())
+        if(pMap->IsBattleGround())
         {
             // cannot summon to bg
             PSendSysMessage(LANG_CANNOT_SUMMON_TO_BG,chr->GetName());
@@ -852,7 +852,7 @@
     if (chr)
     {
         Map* cMap = chr->GetMap();
-        if(cMap->IsBattleGroundOrArena())
+        if(cMap->IsBattleGround())
         {
             // only allow if gm mode is on
             if (!_player->isGameMaster())
@@ -2054,7 +2054,7 @@
     }
 
     MapEntry const * me = sMapStore.LookupEntry(tele->mapId);
-    if(!me || me->IsBattleGroundOrArena())
+    if(!me || me->IsBattleGround())
     {
         SendSysMessage(LANG_CANNOT_TELE_TO_BG);
         SetSentErrorMessage(true);
@@ -2372,7 +2372,7 @@
     }
 
     MapEntry const * me = sMapStore.LookupEntry(tele->mapId);
-    if(!me || me->IsBattleGroundOrArena())
+    if(!me || me->IsBattleGround())
     {
         SendSysMessage(LANG_CANNOT_TELE_TO_BG);
         SetSentErrorMessage(true);
@@ -2441,7 +2441,7 @@
     }
 
     MapEntry const * me = sMapStore.LookupEntry(tele->mapId);
-    if(!me || me->IsBattleGroundOrArena())
+    if(!me || me->IsBattleGround())
     {
         SendSysMessage(LANG_CANNOT_TELE_TO_BG);
         SetSentErrorMessage(true);
diff --git a/src/game/Level3.cpp b/src/game/Level3.cpp
--- a/src/game/Level3.cpp
+++ b/src/game/Level3.cpp
@@ -3967,28 +3967,6 @@
     return true;
 }
 
-bool ChatHandler::HandleModifyArenaCommand(const char * args)
-{ /* [TRINITYROLLBACK]
-    if (!*args)
-        return false;
-
-    Player *target = getSelectedPlayer();
-    if(!target)
-    {
-        SendSysMessage(LANG_PLAYER_NOT_FOUND);
-        SetSentErrorMessage(true);
-        return false;
-    }
-
-    int32 amount = (uint32)atoi(args);
-
-    target->ModifyArenaPoints(amount);
-
-    PSendSysMessage(LANG_COMMAND_MODIFY_ARENA, target->GetName(), target->GetArenaPoints());
-*/
-    return true;  
-} 
-
 bool ChatHandler::HandleReviveCommand(const char* args)
 {
     Player* SelectedPlayer = NULL;
@@ -4296,7 +4274,7 @@
             ChatHandler(chr).PSendSysMessage(LANG_YOURS_EXPLORE_SET_NOTHING,GetName());
     }
 
-    for (uint8 i=0; i<128; i++)
+    for (uint8 i=0; i<64; i++)
     {
         if (flag != 0)
         {
@@ -7112,12 +7090,6 @@
     return true;
 }
 
-bool ChatHandler::HandleFlushArenaPointsCommand(const char * /*args*/)
-{
-    sBattleGroundMgr.DistributeArenaPoints();
-    return true;
-}
-
 bool ChatHandler::HandleModifyGenderCommand(const char *args)
 {
     if(!*args)
diff --git a/src/game/Map.cpp b/src/game/Map.cpp
--- a/src/game/Map.cpp
+++ b/src/game/Map.cpp
@@ -827,7 +827,7 @@
 
     // Don't unload grids if it's battleground, since we may have manually added GOs,creatures, those doesn't load from DB at grid re-load !
     // This isn't really bother us, since as soon as we have instanced BG-s, the whole map unloads as the BG gets ended
-    if (IsBattleGroundOrArena())
+    if (IsBattleGround())
         return;
 
     for (GridRefManager<NGridType>::iterator i = GridRefManager<NGridType>::begin(); i != GridRefManager<NGridType>::end(); )
diff --git a/src/game/Map.h b/src/game/Map.h
--- a/src/game/Map.h
+++ b/src/game/Map.h
@@ -232,8 +232,6 @@
         bool IsRaid() const { return i_mapEntry && i_mapEntry->IsRaid(); }
         bool IsHeroic() const { return i_spawnMode == DIFFICULTY_HEROIC; }
         bool IsBattleGround() const { return i_mapEntry && i_mapEntry->IsBattleGround(); }
-        bool IsBattleArena() const { return i_mapEntry && i_mapEntry->IsBattleArena(); }
-        bool IsBattleGroundOrArena() const { return i_mapEntry && i_mapEntry->IsBattleGroundOrArena(); }
 
         void AddObjectToRemoveList(WorldObject *obj);
         void AddObjectToSwitchList(WorldObject *obj, bool on);
diff --git a/src/game/MapInstanced.cpp b/src/game/MapInstanced.cpp
--- a/src/game/MapInstanced.cpp
+++ b/src/game/MapInstanced.cpp
@@ -143,7 +143,7 @@
             uint32 NewInstanceId = 0;                       // instanceId of the resulting map
             Player* player = (Player*)obj;
 
-            if(IsBattleGroundOrArena())
+            if(IsBattleGround())
             {
                 // instantiate or find existing bg map for player
                 // the instance id is set in battlegroundid
@@ -243,7 +243,7 @@
     sLog.outDebug("MapInstanced::CreateBattleGround: map bg %d for %d created.", InstanceId, GetId());
 
     BattleGroundMap *map = new BattleGroundMap(GetId(), GetGridExpiry(), InstanceId);
-    assert(map->IsBattleGroundOrArena());
+    assert(map->IsBattleGround());
 
     m_InstancedMaps[InstanceId] = map;
     return map;
diff --git a/src/game/MiscHandler.cpp b/src/game/MiscHandler.cpp
--- a/src/game/MiscHandler.cpp
+++ b/src/game/MiscHandler.cpp
@@ -751,10 +751,6 @@
     if (GetPlayer()->isAlive())
         return;
 
-    // do not allow corpse reclaim in arena
-    if (GetPlayer()->InArena())
-        return;
-
     // body not released yet
     if(!GetPlayer()->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
         return;
diff --git a/src/game/ObjectMgr.cpp b/src/game/ObjectMgr.cpp
--- a/src/game/ObjectMgr.cpp
+++ b/src/game/ObjectMgr.cpp
@@ -124,7 +124,6 @@
     m_ItemTextId        = 1;
     m_mailid            = 1;
     m_guildId           = 1;
-    m_arenaTeamId       = 1;
     m_auctionid         = 1;
 
     mGuildBankTabPrice.resize(GUILD_BANK_MAX_TABS);
@@ -214,15 +213,6 @@
         pPPlayerInfo->unLevel = Player::GetUInt32ValueFromArray(tdata,UNIT_FIELD_LEVEL);
         pPPlayerInfo->unfield = Player::GetUInt32ValueFromArray(tdata,UNIT_FIELD_BYTES_0);
 
-   /* [ TrinityRollback ]     
-        pPPlayerInfo->unArenaInfoId0 = Player::GetUInt32ValueFromArray(tdata,PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 0 * 6);
-        pPPlayerInfo->unArenaInfoId1 = Player::GetUInt32ValueFromArray(tdata,PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 1 * 6);
-        pPPlayerInfo->unArenaInfoId2 = Player::GetUInt32ValueFromArray(tdata,PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 2 * 6);
-
-        pPPlayerInfo->unArenaInfoSlot0 = Player::GetUInt32ValueFromArray(tdata,PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 0 * 6 + 5);
-        pPPlayerInfo->unArenaInfoSlot1 = Player::GetUInt32ValueFromArray(tdata,PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 1 * 6 + 5);
-        pPPlayerInfo->unArenaInfoSlot2 = Player::GetUInt32ValueFromArray(tdata,PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 2 * 6 + 5);  */
-
         pPPlayerInfo->unClass = (uint32)fields[3].GetUInt32();
         m_mPlayerInfoMap[fields[0].GetUInt32()] = pPPlayerInfo;
     }
@@ -298,47 +288,6 @@
     mGuildMap.erase(Id);
 }
 
-/* [TRINITY ROLLBACK]
-
-ArenaTeam* ObjectMgr::GetArenaTeamById(const uint32 arenateamid) const
-{
-    ArenaTeamMap::const_iterator itr = mArenaTeamMap.find(arenateamid);
-    if (itr != mArenaTeamMap.end())
-        return itr->second;
-
-    return NULL;
-}
-
-ArenaTeam* ObjectMgr::GetArenaTeamByName(const std::string& arenateamname) const
-{
-    for(ArenaTeamMap::const_iterator itr = mArenaTeamMap.begin(); itr != mArenaTeamMap.end(); ++itr)
-        if (itr->second->GetName() == arenateamname)
-            return itr->second;
-
-    return NULL;
-}
-
-ArenaTeam* ObjectMgr::GetArenaTeamByCaptain(uint64 const& guid) const
-{
-    for(ArenaTeamMap::const_iterator itr = mArenaTeamMap.begin(); itr != mArenaTeamMap.end(); ++itr)
-        if (itr->second->GetCaptain() == guid)
-            return itr->second;
-
-    return NULL;
-}
-
-void ObjectMgr::AddArenaTeam(ArenaTeam* arenaTeam)
-{
-    mArenaTeamMap[arenaTeam->GetId()] = arenaTeam;
-}
-
-void ObjectMgr::RemoveArenaTeam(uint32 Id)
-{
-    mArenaTeamMap.erase(Id);
-}
-
-*/ 
-
 CreatureInfo const* ObjectMgr::GetCreatureTemplate(uint32 id)
 {
     return sCreatureStorage.LookupEntry<CreatureInfo>(id);
@@ -1428,300 +1377,6 @@
     loader.Load(sItemStorage);
     sLog.outString( ">> Loaded %u item prototypes", sItemStorage.RecordCount );
     sLog.outString();
-
-    // check data correctness
-    for(uint32 i = 1; i < sItemStorage.MaxEntry; ++i)
-    {
-        ItemPrototype const* proto = sItemStorage.LookupEntry<ItemPrototype >(i);
-        ItemEntry const *dbcitem = sItemStore.LookupEntry(i);
-        if(!proto)
-        {
-            /* to many errors, and possible not all items really used in game
-            if (dbcitem)
-                sLog.outErrorDb("Item (Entry: %u) doesn't exists in DB, but must exist.",i);
-            */
-            continue;
-        }
-
-        if(dbcitem)
-        {
-            if(proto->InventoryType != dbcitem->InventoryType)
-            {
-                sLog.outErrorDb("Item (Entry: %u) not correct %u inventory type, must be %u (still using DB value).",i,proto->InventoryType,dbcitem->InventoryType);
-                // It safe let use InventoryType from DB
-            }
-
-            if(proto->DisplayInfoID != dbcitem->DisplayId)
-            {
-                sLog.outErrorDb("Item (Entry: %u) not correct %u display id, must be %u (using it).",i,proto->DisplayInfoID,dbcitem->DisplayId);
-                const_cast<ItemPrototype*>(proto)->DisplayInfoID = dbcitem->DisplayId;
-            }
-            if(proto->Sheath != dbcitem->Sheath)
-            {
-                sLog.outErrorDb("Item (Entry: %u) not correct %u sheath, must be %u  (using it).",i,proto->Sheath,dbcitem->Sheath);
-                const_cast<ItemPrototype*>(proto)->Sheath = dbcitem->Sheath;
-            }
-        }
-        else
-        {
-            sLog.outErrorDb("Item (Entry: %u) not correct (not listed in list of existed items).",i);
-        }
-
-        if(proto->Class >= MAX_ITEM_CLASS)
-        {
-            sLog.outErrorDb("Item (Entry: %u) has wrong Class value (%u)",i,proto->Class);
-            const_cast<ItemPrototype*>(proto)->Class = ITEM_CLASS_JUNK;
-        }
-
-        if(proto->SubClass >= MaxItemSubclassValues[proto->Class])
-        {
-            sLog.outErrorDb("Item (Entry: %u) has wrong Subclass value (%u) for class %u",i,proto->SubClass,proto->Class);
-            const_cast<ItemPrototype*>(proto)->SubClass = 0;// exist for all item classes
-        }
-
-        if(proto->Quality >= MAX_ITEM_QUALITY)
-        {
-            sLog.outErrorDb("Item (Entry: %u) has wrong Quality value (%u)",i,proto->Quality);
-            const_cast<ItemPrototype*>(proto)->Quality = ITEM_QUALITY_NORMAL;
-        }
-
-        if(proto->BuyCount <= 0)
-        {
-            sLog.outErrorDb("Item (Entry: %u) has wrong BuyCount value (%u), set to default(1).",i,proto->BuyCount);
-            const_cast<ItemPrototype*>(proto)->BuyCount = 1;
-        }
-
-        if(proto->InventoryType >= MAX_INVTYPE)
-        {
-            sLog.outErrorDb("Item (Entry: %u) has wrong InventoryType value (%u)",i,proto->InventoryType);
-            const_cast<ItemPrototype*>(proto)->InventoryType = INVTYPE_NON_EQUIP;
-        }
-
-        if(proto->RequiredSkill >= MAX_SKILL_TYPE)
-        {
-            sLog.outErrorDb("Item (Entry: %u) has wrong RequiredSkill value (%u)",i,proto->RequiredSkill);
-            const_cast<ItemPrototype*>(proto)->RequiredSkill = 0;
-        }
-
-        if(!(proto->AllowableClass & CLASSMASK_ALL_PLAYABLE))
-        {
-            sLog.outErrorDb("Item (Entry: %u) not have in `AllowableClass` any playable classes (%u) and can't be equipped.",i,proto->AllowableClass);
-        }
-
-        if(!(proto->AllowableRace & RACEMASK_ALL_PLAYABLE))
-        {
-            sLog.outErrorDb("Item (Entry: %u) not have in `AllowableRace` any playable races (%u) and can't be equipped.",i,proto->AllowableRace);
-        }
-
-        if(proto->RequiredSpell && !sSpellStore.LookupEntry(proto->RequiredSpell))
-        {
-            sLog.outErrorDb("Item (Entry: %u) have wrong (non-existed) spell in RequiredSpell (%u)",i,proto->RequiredSpell);
-            const_cast<ItemPrototype*>(proto)->RequiredSpell = 0;
-        }
-
-        if(proto->RequiredReputationRank >= MAX_REPUTATION_RANK)
-            sLog.outErrorDb("Item (Entry: %u) has wrong reputation rank in RequiredReputationRank (%u), item can't be used.",i,proto->RequiredReputationRank);
-
-        if(proto->RequiredReputationFaction)
-        {
-            if(!sFactionStore.LookupEntry(proto->RequiredReputationFaction))
-            {
-                sLog.outErrorDb("Item (Entry: %u) has wrong (not existing) faction in RequiredReputationFaction (%u)",i,proto->RequiredReputationFaction);
-                const_cast<ItemPrototype*>(proto)->RequiredReputationFaction = 0;
-            }
-
-            if(proto->RequiredReputationRank == MIN_REPUTATION_RANK)
-                sLog.outErrorDb("Item (Entry: %u) has min. reputation rank in RequiredReputationRank (0) but RequiredReputationFaction > 0, faction setting is useless.",i);
-        }
-        else if(proto->RequiredReputationRank > MIN_REPUTATION_RANK)
-            sLog.outErrorDb("Item (Entry: %u) has RequiredReputationFaction ==0 but RequiredReputationRank > 0, rank setting is useless.",i);
-
-        if(proto->Stackable==0)
-        {
-            sLog.outErrorDb("Item (Entry: %u) has wrong value in stackable (%u), replace by default 1.",i,proto->Stackable);
-            const_cast<ItemPrototype*>(proto)->Stackable = 1;
-        }
-        else if(proto->Stackable > 255)
-        {
-            sLog.outErrorDb("Item (Entry: %u) has too large value in stackable (%u), replace by hardcoded upper limit (255).",i,proto->Stackable);
-            const_cast<ItemPrototype*>(proto)->Stackable = 255;
-        }
-
-        for (int j = 0; j < 10; j++)
-        {
-            // for ItemStatValue != 0
-            if(proto->ItemStat[j].ItemStatValue && proto->ItemStat[j].ItemStatType >= MAX_ITEM_MOD)
-            {
-                sLog.outErrorDb("Item (Entry: %u) has wrong stat_type%d (%u)",i,j+1,proto->ItemStat[j].ItemStatType);
-                const_cast<ItemPrototype*>(proto)->ItemStat[j].ItemStatType = 0;
-            }
-        }
-
-        for (int j = 0; j < 5; j++)
-        {
-            if(proto->Damage[j].DamageType >= MAX_SPELL_SCHOOL)
-            {
-                sLog.outErrorDb("Item (Entry: %u) has wrong dmg_type%d (%u)",i,j+1,proto->Damage[j].DamageType);
-                const_cast<ItemPrototype*>(proto)->Damage[j].DamageType = 0;
-            }
-        }
-
-        // special format
-        if(proto->Spells[0].SpellId == SPELL_ID_GENERIC_LEARN)
-        {
-            // spell_1
-            if(proto->Spells[0].SpellTrigger != ITEM_SPELLTRIGGER_ON_USE)
-            {
-                sLog.outErrorDb("Item (Entry: %u) has wrong item spell trigger value in spelltrigger_%d (%u) for special learning format",i,0+1,proto->Spells[0].SpellTrigger);
-                const_cast<ItemPrototype*>(proto)->Spells[0].SpellId = 0;
-                const_cast<ItemPrototype*>(proto)->Spells[0].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-                const_cast<ItemPrototype*>(proto)->Spells[1].SpellId = 0;
-                const_cast<ItemPrototype*>(proto)->Spells[1].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-            }
-
-            // spell_2 have learning spell
-            if(proto->Spells[1].SpellTrigger != ITEM_SPELLTRIGGER_LEARN_SPELL_ID)
-            {
-                sLog.outErrorDb("Item (Entry: %u) has wrong item spell trigger value in spelltrigger_%d (%u) for special learning format.",i,1+1,proto->Spells[1].SpellTrigger);
-                const_cast<ItemPrototype*>(proto)->Spells[0].SpellId = 0;
-                const_cast<ItemPrototype*>(proto)->Spells[1].SpellId = 0;
-                const_cast<ItemPrototype*>(proto)->Spells[1].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-            }
-            else if(!proto->Spells[1].SpellId)
-            {
-                sLog.outErrorDb("Item (Entry: %u) not has expected spell in spellid_%d in special learning format.",i,1+1);
-                const_cast<ItemPrototype*>(proto)->Spells[0].SpellId = 0;
-                const_cast<ItemPrototype*>(proto)->Spells[1].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-            }
-            else
-            {
-                SpellEntry const* spellInfo = sSpellStore.LookupEntry(proto->Spells[1].SpellId);
-                if(!spellInfo)
-                {
-                    sLog.outErrorDb("Item (Entry: %u) has wrong (not existing) spell in spellid_%d (%u)",i,1+1,proto->Spells[1].SpellId);
-                    const_cast<ItemPrototype*>(proto)->Spells[0].SpellId = 0;
-                    const_cast<ItemPrototype*>(proto)->Spells[1].SpellId = 0;
-                    const_cast<ItemPrototype*>(proto)->Spells[1].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-                }
-                // allowed only in special format
-                else if(proto->Spells[1].SpellId==SPELL_ID_GENERIC_LEARN)
-                {
-                    sLog.outErrorDb("Item (Entry: %u) has broken spell in spellid_%d (%u)",i,1+1,proto->Spells[1].SpellId);
-                    const_cast<ItemPrototype*>(proto)->Spells[0].SpellId = 0;
-                    const_cast<ItemPrototype*>(proto)->Spells[1].SpellId = 0;
-                    const_cast<ItemPrototype*>(proto)->Spells[1].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-                }
-            }
-
-            // spell_3*,spell_4*,spell_5* is empty
-            for (int j = 2; j < 5; j++)
-            {
-                if(proto->Spells[j].SpellTrigger != ITEM_SPELLTRIGGER_ON_USE)
-                {
-                    sLog.outErrorDb("Item (Entry: %u) has wrong item spell trigger value in spelltrigger_%d (%u)",i,j+1,proto->Spells[j].SpellTrigger);
-                    const_cast<ItemPrototype*>(proto)->Spells[j].SpellId = 0;
-                    const_cast<ItemPrototype*>(proto)->Spells[j].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-                }
-                else if(proto->Spells[j].SpellId != 0)
-                {
-                    sLog.outErrorDb("Item (Entry: %u) has wrong spell in spellid_%d (%u) for learning special format",i,j+1,proto->Spells[j].SpellId);
-                    const_cast<ItemPrototype*>(proto)->Spells[j].SpellId = 0;
-                }
-            }
-        }
-        // normal spell list
-        else
-        {
-            for (int j = 0; j < 5; j++)
-            {
-                if(proto->Spells[j].SpellTrigger >= MAX_ITEM_SPELLTRIGGER || proto->Spells[j].SpellTrigger == ITEM_SPELLTRIGGER_LEARN_SPELL_ID)
-                {
-                    sLog.outErrorDb("Item (Entry: %u) has wrong item spell trigger value in spelltrigger_%d (%u)",i,j+1,proto->Spells[j].SpellTrigger);
-                    const_cast<ItemPrototype*>(proto)->Spells[j].SpellId = 0;
-                    const_cast<ItemPrototype*>(proto)->Spells[j].SpellTrigger = ITEM_SPELLTRIGGER_ON_USE;
-                }
-
-                if(proto->Spells[j].SpellId)
-                {
-                    SpellEntry const* spellInfo = sSpellStore.LookupEntry(proto->Spells[j].SpellId);
-                    if(!spellInfo)
-                    {
-                        sLog.outErrorDb("Item (Entry: %u) has wrong (not existing) spell in spellid_%d (%u)",i,j+1,proto->Spells[j].SpellId);
-                        const_cast<ItemPrototype*>(proto)->Spells[j].SpellId = 0;
-                    }
-                    // allowed only in special format
-                    else if(proto->Spells[j].SpellId==SPELL_ID_GENERIC_LEARN)
-                    {
-                        sLog.outErrorDb("Item (Entry: %u) has broken spell in spellid_%d (%u)",i,j+1,proto->Spells[j].SpellId);
-                        const_cast<ItemPrototype*>(proto)->Spells[j].SpellId = 0;
-                    }
-                }
-            }
-        }
-
-        if(proto->Bonding >= MAX_BIND_TYPE)
-            sLog.outErrorDb("Item (Entry: %u) has wrong Bonding value (%u)",i,proto->Bonding);
-
-        if(proto->PageText && !sPageTextStore.LookupEntry<PageText>(proto->PageText))
-            sLog.outErrorDb("Item (Entry: %u) has non existing first page (Id:%u)", i,proto->PageText);
-
-        if(proto->LockID && !sLockStore.LookupEntry(proto->LockID))
-            sLog.outErrorDb("Item (Entry: %u) has wrong LockID (%u)",i,proto->LockID);
-
-        if(proto->Sheath >= MAX_SHEATHETYPE)
-        {
-            sLog.outErrorDb("Item (Entry: %u) has wrong Sheath (%u)",i,proto->Sheath);
-            const_cast<ItemPrototype*>(proto)->Sheath = SHEATHETYPE_NONE;
-        }
-
-        if(proto->RandomProperty && !sItemRandomPropertiesStore.LookupEntry(GetItemEnchantMod(proto->RandomProperty)))
-        {
-            sLog.outErrorDb("Item (Entry: %u) has unknown (wrong or not listed in `item_enchantment_template`) RandomProperty (%u)",i,proto->RandomProperty);
-            const_cast<ItemPrototype*>(proto)->RandomProperty = 0;
-        }
-
-        if(proto->RandomSuffix && !sItemRandomSuffixStore.LookupEntry(GetItemEnchantMod(proto->RandomSuffix)))
-        {
-            sLog.outErrorDb("Item (Entry: %u) has wrong RandomSuffix (%u)",i,proto->RandomSuffix);
-            const_cast<ItemPrototype*>(proto)->RandomSuffix = 0;
-        }
-
-        if(proto->ItemSet && !sItemSetStore.LookupEntry(proto->ItemSet))
-        {
-            sLog.outErrorDb("Item (Entry: %u) have wrong ItemSet (%u)",i,proto->ItemSet);
-            const_cast<ItemPrototype*>(proto)->ItemSet = 0;
-        }
-
-        if(proto->Area && !GetAreaEntryByAreaID(proto->Area))
-            sLog.outErrorDb("Item (Entry: %u) has wrong Area (%u)",i,proto->Area);
-
-        if(proto->Map && !sMapStore.LookupEntry(proto->Map))
-            sLog.outErrorDb("Item (Entry: %u) has wrong Map (%u)",i,proto->Map);
-
-        if(proto->TotemCategory && !sTotemCategoryStore.LookupEntry(proto->TotemCategory))
-            sLog.outErrorDb("Item (Entry: %u) has wrong TotemCategory (%u)",i,proto->TotemCategory);
-
-        for (int j = 0; j < 3; j++)
-        {
-            if(proto->Socket[j].Color && (proto->Socket[j].Color & SOCKET_COLOR_ALL) != proto->Socket[j].Color)
-            {
-                sLog.outErrorDb("Item (Entry: %u) has wrong socketColor_%d (%u)",i,j+1,proto->Socket[j].Color);
-                const_cast<ItemPrototype*>(proto)->Socket[j].Color = 0;
-            }
-        }
-
-        if(proto->GemProperties && !sGemPropertiesStore.LookupEntry(proto->GemProperties))
-            sLog.outErrorDb("Item (Entry: %u) has wrong GemProperties (%u)",i,proto->GemProperties);
-
-        if(proto->FoodType >= MAX_PET_DIET)
-        {
-            sLog.outErrorDb("Item (Entry: %u) has wrong FoodType value (%u)",i,proto->FoodType);
-            const_cast<ItemPrototype*>(proto)->FoodType = 0;
-        }
-    }
-
-    // this DBC used currently only for check item templates in DB.
-    sItemStore.Clear();
 }
 
 void ObjectMgr::LoadPetLevelInfo()
@@ -2846,14 +2501,6 @@
             // warning
         }
 
-        if(qinfo->CharTitleId && !sCharTitlesStore.LookupEntry(qinfo->CharTitleId))
-        {
-            sLog.outErrorDb("Quest %u has `CharTitleId` = %u but CharTitle Id %u does not exist, quest can't be rewarded with title.",
-                qinfo->GetQuestId(),qinfo->GetCharTitleId(),qinfo->GetCharTitleId());
-            qinfo->CharTitleId = 0;
-            // quest can't reward this title
-        }
-
         if(qinfo->SrcItemId)
         {
             if(!sItemStorage.LookupEntry<ItemPrototype>(qinfo->SrcItemId))
@@ -5073,13 +4720,6 @@
         delete result;
     }
 
-    result = CharacterDatabase.Query("SELECT MAX(arenateamid) FROM arena_team");
-    if (result)
-    {
-        m_arenaTeamId = (*result)[0].GetUInt32()+1;
-        delete result;
-    }
-
     result = CharacterDatabase.Query( "SELECT MAX(guildid) FROM guild" );
     if (result)
     {
@@ -5088,16 +4728,6 @@
     }
 }
 
-uint32 ObjectMgr::GenerateArenaTeamId()
-{
-    if(m_arenaTeamId>=0xFFFFFFFE)
-    {
-        sLog.outError("Arena team ids overflow!! Can't continue, shutting down server. ");
-        World::StopNow(ERROR_EXIT_CODE);
-    }
-    return m_arenaTeamId++;
-}
-
 uint32 ObjectMgr::GenerateGuildId()
 {
     if(m_guildId>=0xFFFFFFFE)
diff --git a/src/game/ObjectMgr.h b/src/game/ObjectMgr.h
--- a/src/game/ObjectMgr.h
+++ b/src/game/ObjectMgr.h
@@ -57,7 +57,6 @@
 
 class Group;
 class Guild;
-class ArenaTeam;
 class Path;
 class TransportPath;
 class Item;
@@ -223,13 +222,7 @@
     uint32 unfield;
     uint32 unLevel;
     uint8 unClass;
-//Arena
-    uint32 unArenaInfoId0;
-    uint32 unArenaInfoId1;
-    uint32 unArenaInfoId2;
-    uint32 unArenaInfoSlot0;
-    uint32 unArenaInfoSlot1;
-    uint32 unArenaInfoSlot2;
+
 }CachePlayerInfo, *PCachePlayerInfo;
 typedef UNORDERED_MAP<uint32, PCachePlayerInfo> CachePlayerInfoMap;
 
@@ -300,8 +293,6 @@
 
         typedef UNORDERED_MAP<uint32, Guild *> GuildMap;
 
-        typedef UNORDERED_MAP<uint32, ArenaTeam*> ArenaTeamMap;
-
         typedef UNORDERED_MAP<uint32, Quest*> QuestMap;
 
         typedef UNORDERED_MAP<uint32, AreaTrigger> AreaTriggerMap;
@@ -339,15 +330,6 @@
         void AddGuild(Guild* guild);
         void RemoveGuild(uint32 Id);
 
-      /*[TRINITYROLLBACK] 
-	    ArenaTeam* GetArenaTeamById(const uint32 arenateamid) const;
-        ArenaTeam* GetArenaTeamByName(const std::string& arenateamname) const;
-        ArenaTeam* GetArenaTeamByCaptain(uint64 const& guid) const;
-        void AddArenaTeam(ArenaTeam* arenaTeam);
-        void RemoveArenaTeam(uint32 Id);
-        ArenaTeamMap::iterator GetArenaTeamMapBegin() { return mArenaTeamMap.begin(); }
-        ArenaTeamMap::iterator GetArenaTeamMapEnd()   { return mArenaTeamMap.end(); } */
-
         static CreatureInfo const *GetCreatureTemplate( uint32 id );
         CreatureModelInfo const *GetCreatureModelInfo( uint32 modelid );
         CreatureModelInfo const* GetCreatureModelRandomGender(uint32 display_id);
@@ -479,7 +461,6 @@
         }
 
         void LoadGuilds();
-//[TRINITYROLLBACK]        void LoadArenaTeams();
         void LoadGroups();
         void LoadQuests();
         void LoadQuestRelations()
@@ -581,7 +562,6 @@
         uint32 GenerateMailID();
         uint32 GenerateItemTextID();
         uint32 GeneratePetNumber();
-        uint32 GenerateArenaTeamId();
         uint32 GenerateGuildId();
 
         void LoadPlayerInfoInCache();
@@ -793,7 +773,6 @@
         uint32 m_auctionid;
         uint32 m_mailid;
         uint32 m_ItemTextId;
-        uint32 m_arenaTeamId;
         uint32 m_guildId;
         uint32 m_hiPetNumber;
 
@@ -817,7 +796,6 @@
 
         GroupSet            mGroupSet;
         GuildMap            mGuildMap;
-        ArenaTeamMap        mArenaTeamMap;
 
         ItemMap             mItems;
 
diff --git a/src/game/Opcodes.cpp b/src/game/Opcodes.cpp
--- a/src/game/Opcodes.cpp
+++ b/src/game/Opcodes.cpp
@@ -867,7 +867,6 @@
     /*0x344*/ { "SMSG_MOVE_UNSET_CAN_FLY",          STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x345*/ { "CMSG_MOVE_SET_CAN_FLY_ACK",        STATUS_LOGGEDIN, &WorldSession::HandleMoveFlyModeChangeAckOpcode},
     /*0x346*/ { "CMSG_MOVE_SET_FLY",                STATUS_LOGGEDIN, &WorldSession::HandleMovementOpcodes           },
-    /*0x347*/ { "CMSG_SOCKET_GEMS",                 STATUS_LOGGEDIN, &WorldSession::HandleSocketOpcode              },
     /*0x359*/ { "MSG_MOVE_START_ASCEND",            STATUS_LOGGEDIN, &WorldSession::HandleMovementOpcodes           },
     /*0x35A*/ { "MSG_MOVE_STOP_ASCEND",             STATUS_LOGGEDIN, &WorldSession::HandleMovementOpcodes           },
     /*0x35C*/ { "CMSG_LFG_SET_AUTOJOIN",            STATUS_AUTHED,   &WorldSession::HandleLfgAutoJoinOpcode         },
@@ -892,9 +891,7 @@
     /*0x373*/ { "SMSG_TITLE_EARNED",                STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x374*/ { "CMSG_SET_TITLE",                   STATUS_LOGGEDIN, &WorldSession::HandleChooseTitleOpcode         },
     /*0x375*/ { "CMSG_CANCEL_MOUNT_AURA",           STATUS_LOGGEDIN, &WorldSession::HandleDismountOpcode            },
-    /*0x376*/ { "SMSG_ARENA_ERROR",                 STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
-//[TRINITYROLLBACK]    /*0x377*/ { "MSG_INSPECT_ARENA_TEAMS",          STATUS_LOGGEDIN, &WorldSession::HandleInspectArenaStatsOpcode   },
     /*0x378*/ { "SMSG_DEATH_RELEASE_LOC",           STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x379*/ { "CMSG_CANCEL_TEMP_ENCHANTMENT",     STATUS_LOGGEDIN, &WorldSession::HandleCancelTempItemEnchantmentOpcode},
     /*0x37A*/ { "SMSG_FORCED_DEATH_UPDATE",         STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x37B*/ { "CMSG_CHEAT_SET_HONOR_CURRENCY",    STATUS_NEVER,    &WorldSession::Handle_NULL                     },
@@ -897,8 +894,7 @@
     /*0x378*/ { "SMSG_DEATH_RELEASE_LOC",           STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x379*/ { "CMSG_CANCEL_TEMP_ENCHANTMENT",     STATUS_LOGGEDIN, &WorldSession::HandleCancelTempItemEnchantmentOpcode},
     /*0x37A*/ { "SMSG_FORCED_DEATH_UPDATE",         STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
     /*0x37B*/ { "CMSG_CHEAT_SET_HONOR_CURRENCY",    STATUS_NEVER,    &WorldSession::Handle_NULL                     },
-    /*0x37C*/ { "CMSG_CHEAT_SET_ARENA_CURRENCY",    STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x37D*/ { "MSG_MOVE_SET_FLIGHT_SPEED_CHEAT",  STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x37E*/ { "MSG_MOVE_SET_FLIGHT_SPEED",        STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x37F*/ { "MSG_MOVE_SET_FLIGHT_BACK_SPEED_CHEAT",STATUS_NEVER, &WorldSession::Handle_NULL                     },
@@ -1044,7 +1040,6 @@
     /*0x40B*/ { "CMSG_SET_GRANTABLE_LEVELS",        STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x40C*/ { "CMSG_GRANT_LEVEL",                 STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x40D*/ { "CMSG_REFER_A_FRIEND",              STATUS_NEVER,    &WorldSession::Handle_NULL                     },
-    /*0x40E*/ { "MSG_GM_CHANGE_ARENA_RATING",       STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x40F*/ { "CMSG_DECLINE_CHANNEL_INVITE",      STATUS_LOGGEDIN, &WorldSession::HandleChannelDeclineInvite      },
     /*0x410*/ { "CMSG_GROUPACTION_THROTTLED",       STATUS_NEVER,    &WorldSession::Handle_NULL                     },
     /*0x411*/ { "SMSG_OVERRIDE_LIGHT",              STATUS_NEVER,    &WorldSession::Handle_ServerSide               },
diff --git a/src/game/Opcodes.h b/src/game/Opcodes.h
--- a/src/game/Opcodes.h
+++ b/src/game/Opcodes.h
@@ -875,23 +875,5 @@
     SMSG_MOVE_UNSET_CAN_FLY                         = 0x344,
     CMSG_MOVE_SET_CAN_FLY_ACK                       = 0x345,
     CMSG_MOVE_SET_FLY                               = 0x346,
-    CMSG_SOCKET_GEMS                                = 0x347,
-    CMSG_ARENA_TEAM_CREATE                          = 0x348,
-    SMSG_ARENA_TEAM_COMMAND_RESULT                  = 0x349,
-    UMSG_UPDATE_ARENA_TEAM_OBSOLETE                 = 0x34A,
-    CMSG_ARENA_TEAM_QUERY                           = 0x34B,
-    SMSG_ARENA_TEAM_QUERY_RESPONSE                  = 0x34C,
-    CMSG_ARENA_TEAM_ROSTER                          = 0x34D,
-    SMSG_ARENA_TEAM_ROSTER                          = 0x34E,
-    CMSG_ARENA_TEAM_INVITE                          = 0x34F,
-    SMSG_ARENA_TEAM_INVITE                          = 0x350,
-    CMSG_ARENA_TEAM_ACCEPT                          = 0x351,
-    CMSG_ARENA_TEAM_DECLINE                         = 0x352,
-    CMSG_ARENA_TEAM_LEAVE                           = 0x353,
-    CMSG_ARENA_TEAM_REMOVE                          = 0x354,
-    CMSG_ARENA_TEAM_DISBAND                         = 0x355,
-    CMSG_ARENA_TEAM_LEADER                          = 0x356,
-    SMSG_ARENA_TEAM_EVENT                           = 0x357,
-    CMSG_BATTLEMASTER_JOIN_ARENA                    = 0x358,
     MSG_MOVE_START_ASCEND                           = 0x359,
     MSG_MOVE_STOP_ASCEND                            = 0x35A,
@@ -896,6 +878,5 @@
     MSG_MOVE_START_ASCEND                           = 0x359,
     MSG_MOVE_STOP_ASCEND                            = 0x35A,
-    SMSG_ARENA_TEAM_STATS                           = 0x35B,
     CMSG_LFG_SET_AUTOJOIN                           = 0x35C,
     CMSG_LFG_CLEAR_AUTOJOIN                         = 0x35D,
     CMSG_LFM_SET_AUTOFILL                           = 0x35E,
@@ -922,9 +903,7 @@
     SMSG_TITLE_EARNED                               = 0x373,
     CMSG_SET_TITLE                                  = 0x374,
     CMSG_CANCEL_MOUNT_AURA                          = 0x375,
-    SMSG_ARENA_ERROR                                = 0x376,
-    MSG_INSPECT_ARENA_TEAMS                         = 0x377,
     SMSG_DEATH_RELEASE_LOC                          = 0x378,
     CMSG_CANCEL_TEMP_ENCHANTMENT                    = 0x379,
     SMSG_FORCED_DEATH_UPDATE                        = 0x37A,
     CMSG_CHEAT_SET_HONOR_CURRENCY                   = 0x37B,
@@ -927,8 +906,7 @@
     SMSG_DEATH_RELEASE_LOC                          = 0x378,
     CMSG_CANCEL_TEMP_ENCHANTMENT                    = 0x379,
     SMSG_FORCED_DEATH_UPDATE                        = 0x37A,
     CMSG_CHEAT_SET_HONOR_CURRENCY                   = 0x37B,
-    CMSG_CHEAT_SET_ARENA_CURRENCY                   = 0x37C,
     MSG_MOVE_SET_FLIGHT_SPEED_CHEAT                 = 0x37D,
     MSG_MOVE_SET_FLIGHT_SPEED                       = 0x37E,
     MSG_MOVE_SET_FLIGHT_BACK_SPEED_CHEAT            = 0x37F,
@@ -1074,7 +1052,6 @@
     CMSG_SET_GRANTABLE_LEVELS                       = 0x40B,
     CMSG_GRANT_LEVEL                                = 0x40C,
     CMSG_REFER_A_FRIEND                             = 0x40D,
-    MSG_GM_CHANGE_ARENA_RATING                      = 0x40E,
     CMSG_DECLINE_CHANNEL_INVITE                     = 0x40F,
     CMSG_GROUPACTION_THROTTLED                      = 0x410,
     SMSG_OVERRIDE_LIGHT                             = 0x411,
diff --git a/src/game/Pet.cpp b/src/game/Pet.cpp
--- a/src/game/Pet.cpp
+++ b/src/game/Pet.cpp
@@ -522,5 +522,5 @@
             SetUInt32Value( UNIT_DYNAMIC_FLAGS, 0x00 );
             RemoveFlag (UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
 
-             //lose happiness when died and not in BG/Arena
+             //lose happiness when died and not in BG
             MapEntry const* mapEntry = sMapStore.LookupEntry(GetMapId());
@@ -526,5 +526,5 @@
             MapEntry const* mapEntry = sMapStore.LookupEntry(GetMapId());
-            if(!mapEntry || (mapEntry->map_type != MAP_ARENA && mapEntry->map_type != MAP_BATTLEGROUND))
+            if(!mapEntry || mapEntry->map_type != MAP_BATTLEGROUND)
                 ModifyPower(POWER_HAPPINESS, -HAPPINESS_LEVEL_SIZE);
 
             SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISABLE_ROTATE);
diff --git a/src/game/PetitionsHandler.cpp b/src/game/PetitionsHandler.cpp
--- a/src/game/PetitionsHandler.cpp
+++ b/src/game/PetitionsHandler.cpp
@@ -31,12 +31,6 @@
 #include "GossipDef.h"
 #include "SocialMgr.h"
 
-/*enum PetitionType // dbc data
-{
-    PETITION_TYPE_GUILD      = 1,
-    PETITION_TYPE_ARENA_TEAM = 3
-};*/
-
 // Charters ID in item_template
 #define GUILD_CHARTER               5863
 #define GUILD_CHARTER_COST          1000                    // 10 S
@@ -40,12 +34,6 @@
 // Charters ID in item_template
 #define GUILD_CHARTER               5863
 #define GUILD_CHARTER_COST          1000                    // 10 S
-#define ARENA_TEAM_CHARTER_2v2      23560
-#define ARENA_TEAM_CHARTER_2v2_COST 800000                  // 80 G
-#define ARENA_TEAM_CHARTER_3v3      23561
-#define ARENA_TEAM_CHARTER_3v3_COST 1200000                 // 120 G
-#define ARENA_TEAM_CHARTER_5v5      23562
-#define ARENA_TEAM_CHARTER_5v5_COST 2000000                 // 200 G
 
 void WorldSession::HandlePetitionBuyOpcode(WorldPacket & recv_data)
 {
@@ -107,44 +95,6 @@
         cost = GUILD_CHARTER_COST;
         type = 9;
     }
-    else
-    {
-  /*[TRINITYROLLBACK]      
-      // TODO: find correct opcode
-        if(_player->getLevel() < sWorld.getConfig(CONFIG_MAX_PLAYER_LEVEL))
-        {
-            SendNotification(LANG_ARENA_ONE_TOOLOW, sWorld.getConfig(CONFIG_MAX_PLAYER_LEVEL));
-            return;
-        }
-
-        switch(unk10)
-        {
-            case 1:
-                charterid = ARENA_TEAM_CHARTER_2v2;
-                cost = ARENA_TEAM_CHARTER_2v2_COST;
-                type = 2;                                   // 2v2
-                break;
-            case 2:
-                charterid = ARENA_TEAM_CHARTER_3v3;
-                cost = ARENA_TEAM_CHARTER_3v3_COST;
-                type = 3;                                   // 3v3
-                break;
-            case 3:
-                charterid = ARENA_TEAM_CHARTER_5v5;
-                cost = ARENA_TEAM_CHARTER_5v5_COST;
-                type = 5;                                   // 5v5
-                break;
-            default:
-                sLog.outDebug("unknown selection at buy petition: %u", unk10);
-                return;
-        }
-
-        if(_player->GetArenaTeamId(unk10-1))
-        {
-            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, name, "", ERR_ALREADY_IN_ARENA_TEAM);
-            return;
-        } */
-    }
 
     if(type == 9)
     {
@@ -159,20 +109,6 @@
             return;
         }
     }
-    else
-    {
-      /*[TRINITYROLLBACK]
-	    if(objmgr.GetArenaTeamByName(name))
-        {
-            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, name, "", ERR_ARENA_TEAM_NAME_EXISTS_S);
-            return;
-        }
-        if(objmgr.IsReservedName(name) || !ObjectMgr::IsValidCharterName(name))
-        {
-            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, name, "", ERR_ARENA_TEAM_NAME_INVALID);
-            return;
-        } */
-    }
 
     ItemPrototype const *pProto = objmgr.GetItemPrototype(charterid);
     if(!pProto)
@@ -201,9 +137,9 @@
         return;
 
     charter->SetUInt32Value(ITEM_FIELD_ENCHANTMENT, charter->GetGUIDLow());
-    // ITEM_FIELD_ENCHANTMENT is guild/arenateam id
+    // ITEM_FIELD_ENCHANTMENT is guild id
     // ITEM_FIELD_ENCHANTMENT+1 is current signatures count (showed on item)
     charter->SetState(ITEM_CHANGED, _player);
     _player->SendNewItem(charter, 1, true, false);
 
     // a petition is invalid, if both the owner and the type matches
@@ -205,10 +141,8 @@
     // ITEM_FIELD_ENCHANTMENT+1 is current signatures count (showed on item)
     charter->SetState(ITEM_CHANGED, _player);
     _player->SendNewItem(charter, 1, true, false);
 
     // a petition is invalid, if both the owner and the type matches
-    // we checked above, if this player is in an arenateam, so this must be
-    // datacorruption
     QueryResult *result = CharacterDatabase.PQuery("SELECT petitionguid FROM petition WHERE ownerguid = '%u'  AND type = '%u'", _player->GetGUIDLow(), type);
 
     std::ostringstream ssInvalidPetitionGUIDs;
@@ -342,7 +276,7 @@
     WorldPacket data(SMSG_PETITION_QUERY_RESPONSE, (4+8+name.size()+1+1+4*13));
     data << GUID_LOPART(petitionguid);                      // guild/team guid (in Trinity always same as GUID_LOPART(petition guid)
     data << ownerguid;                                      // charter owner guid
-    data << name;                                           // name (guild/arena team)
+    data << name;                                           // name (guild team)
     data << uint8(0);                                       // 1
     if(type == 9)
     {
@@ -350,12 +284,6 @@
         data << uint32(9);
         data << uint32(0);                                  // bypass client - side limitation, a different value is needed here for each petition
     }
-    else
-    {
-        data << type-1;
-        data << type-1;
-        data << type;                                       // bypass client - side limitation, a different value is needed here for each petition
-    }
     data << uint32(0);                                      // 5
     data << uint32(0);                                      // 6
     data << uint32(0);                                      // 7
@@ -365,10 +293,7 @@
     data << uint32(0);                                      // 11
     data << uint32(0);                                      // 13 count of next strings?
     data << uint32(0);                                      // 14
-    if(type == 9)
-        data << uint32(0);                                  // 15 0 - guild, 1 - arena team
-    else
-        data << uint32(1);
+
     SendPacket(&data);
 }
 
@@ -416,21 +341,7 @@
             SendGuildCommandResult(GUILD_CREATE_S, newname, GUILD_NAME_INVALID);
             return;
         }
-    }
-    else
-    {
-      /*[TRINITYROLLBACK]  
-	    if(objmgr.GetArenaTeamByName(newname))
-        {
-            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, newname, "", ERR_ARENA_TEAM_NAME_EXISTS_S);
-            return;
-        }
-        if(objmgr.IsReservedName(newname) || !ObjectMgr::IsValidCharterName(newname))
-        {
-            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, newname, "", ERR_ARENA_TEAM_NAME_INVALID);
-            return;
-        } */
-    }
+	}
 
     std::string db_newname = newname;
     CharacterDatabase.escape_string(db_newname);
@@ -483,11 +394,7 @@
     // not let enemies sign guild charter
     if(!sWorld.getConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD) && GetPlayer()->GetTeam() != objmgr.GetPlayerTeamByGUID(ownerguid))
     {
- /*[TRINITYROLLBACK]    
-    if(type != 9)
-            SendArenaTeamCommandResult(ERR_ARENA_TEAM_INVITE_SS, "", "", ERR_ARENA_TEAM_NOT_ALLIED);
-        else */
-            SendGuildCommandResult(GUILD_CREATE_S, "", GUILD_NOT_ALLIED);
+        SendGuildCommandResult(GUILD_CREATE_S, "", GUILD_NOT_ALLIED);
         return;
     }
 
@@ -491,32 +398,8 @@
         return;
     }
 
-    if(type != 9)
-    { /*[TRINITYROLLBACK]
-        if(_player->getLevel() < sWorld.getConfig(CONFIG_MAX_PLAYER_LEVEL))
-        {
-            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, "", _player->GetName(), ERR_ARENA_TEAM_PLAYER_TO_LOW);
-            return;
-        }
-
-        uint8 slot = ArenaTeam::GetSlotByType(type);
-        if(slot >= MAX_ARENA_SLOT)
-            return;
-
-        if(_player->GetArenaTeamId(slot))
-        {
-            SendArenaTeamCommandResult(ERR_ARENA_TEAM_INVITE_SS, "", _player->GetName(), ERR_ALREADY_IN_ARENA_TEAM_S);
-            return;
-        }
-
-        if(_player->GetArenaTeamIdInvited())
-        {
-            SendArenaTeamCommandResult(ERR_ARENA_TEAM_INVITE_SS, "", _player->GetName(), ERR_ALREADY_INVITED_TO_ARENA_TEAM_S);
-            return;
-        } */
-    }
-    else
-    {
+	if(type != 9)
+	{
         if(_player->GetGuildId())
         {
             SendGuildCommandResult(GUILD_INVITE_S, _player->GetName(), ALREADY_IN_GUILD);
@@ -635,11 +518,8 @@
 
     if (!sWorld.getConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD) && GetPlayer()->GetTeam() != player->GetTeam() )
     {
-    /*[TRINITYROLLBACK]  
-	  if(type != 9)
-            SendArenaTeamCommandResult(ERR_ARENA_TEAM_INVITE_SS, "", "", ERR_ARENA_TEAM_NOT_ALLIED);
-        else */
+	  if(type == 9)
             SendGuildCommandResult(GUILD_CREATE_S, "", GUILD_NOT_ALLIED);
         return;
     }
 
@@ -642,34 +522,8 @@
             SendGuildCommandResult(GUILD_CREATE_S, "", GUILD_NOT_ALLIED);
         return;
     }
 
-    if(type != 9)
-    {/*[TRINITYROLLBACK]
-        if(player->getLevel() < sWorld.getConfig(CONFIG_MAX_PLAYER_LEVEL))
-        {
-            // player is too low level to join an arena team
-            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, player->GetName(), "", ERR_ARENA_TEAM_PLAYER_TO_LOW);
-            return;
-        }
-
-        uint8 slot = ArenaTeam::GetSlotByType(type);
-        if(slot >= MAX_ARENA_SLOT)
-            return;
-
-        if(player->GetArenaTeamId(slot))
-        {
-            // player is already in an arena team
-            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, player->GetName(), "", ERR_ALREADY_IN_ARENA_TEAM_S);
-            return;
-        }
-
-        if(player->GetArenaTeamIdInvited())
-        {
-            SendArenaTeamCommandResult(ERR_ARENA_TEAM_INVITE_SS, "", _player->GetName(), ERR_ALREADY_INVITED_TO_ARENA_TEAM_S);
-            return;
-        } */
-    }
-    else
+    if(type == 9)
     {
         if(player->GetGuildId())
         {
@@ -754,22 +608,6 @@
             return;
         }
     }
-    else
-    {
-  /* [TRINITYROLLBACK]    
-     uint8 slot = ArenaTeam::GetSlotByType(type);
-        if(slot >= MAX_ARENA_SLOT)
-            return;
-
-        if(_player->GetArenaTeamId(slot))
-        {
-            //data.Initialize(SMSG_TURN_IN_PETITION_RESULTS, 4);
-            //data << (uint32)PETITION_TURN_ALREADY_IN_GUILD;                          // already in guild
-            //_player->GetSession()->SendPacket(&data);
-            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, name, "", ERR_ALREADY_IN_ARENA_TEAM);
-            return;
-        } */
-    }
 
     if(_player->GetGUIDLow() != ownerguidlo)
         return;
@@ -786,8 +624,7 @@
     //if(signs < sWorld.getConfig(CONFIG_MIN_PETITION_SIGNS))
     if(type == 9)
         count = sWorld.getConfig(CONFIG_MIN_PETITION_SIGNS);
-    else
-        count = type-1;
+
     if(signs < count)
     {
         data.Initialize(SMSG_TURN_IN_PETITION_RESULTS, 4);
@@ -806,16 +643,6 @@
             return;
         }
     }
-    else
-    {
-     /*[TRINITYROLLBACK]  
-	   if(objmgr.GetArenaTeamByName(name))
-        {
-            SendArenaTeamCommandResult(ERR_ARENA_TEAM_CREATE_S, name, "", ERR_ARENA_TEAM_NAME_EXISTS_S);
-            delete result;
-            return;
-        } */
-    }
 
     // and at last charter item check
     Item *item = _player->GetItemByGuid(petitionguid);
@@ -851,38 +678,6 @@
             result->NextRow();
         }
     }
-    else                                                    // or arena team
-    {
-      /*[TRINITYROLLBACK]  
-	    ArenaTeam* at = new ArenaTeam;
-        if(!at->Create(_player->GetGUID(), type, name))
-        {
-            sLog.outError("PetitionsHandler: arena team create failed.");
-            delete at;
-            delete result;
-            return;
-        }
-
-        CHECK_PACKET_SIZE(recv_data, 8+5*4);
-        uint32 icon, iconcolor, border, bordercolor, backgroud;
-        recv_data >> backgroud >> icon >> iconcolor >> border >> bordercolor;
-
-        at->SetEmblem(backgroud, icon, iconcolor, border, bordercolor);
-
-        // register team and add captain
-        objmgr.AddArenaTeam(at);
-        sLog.outDebug("PetitonsHandler: arena team added to objmrg");
-
-        // add members
-        for(uint8 i = 0; i < signs; ++i)
-        {
-            Field* fields = result->Fetch();
-            uint64 memberGUID = fields[0].GetUInt64();
-            sLog.outDebug("PetitionsHandler: adding arena member %u", GUID_LOPART(memberGUID));
-            at->AddMember(memberGUID);
-            result->NextRow();
-        } */
-    }
 
     delete result;
 
@@ -934,39 +729,14 @@
     WorldPacket data(SMSG_PETITION_SHOWLIST, 8+1+4*6);
     data << guid;                                           // npc guid
     data << count;                                          // count
-    if(count == 1)
-    {
-        data << uint32(1);                                  // index
-        data << uint32(GUILD_CHARTER);                      // charter entry
-        data << uint32(16161);                              // charter display id
-        data << uint32(GUILD_CHARTER_COST);                 // charter cost
-        data << uint32(0);                                  // unknown
-        data << uint32(9);                                  // required signs?
-    }
-    else
-    {
-        // 2v2
-        data << uint32(1);                                  // index
-        data << uint32(ARENA_TEAM_CHARTER_2v2);             // charter entry
-        data << uint32(16161);                              // charter display id
-        data << uint32(ARENA_TEAM_CHARTER_2v2_COST);        // charter cost
-        data << uint32(2);                                  // unknown
-        data << uint32(2);                                  // required signs?
-        // 3v3
-        data << uint32(2);                                  // index
-        data << uint32(ARENA_TEAM_CHARTER_3v3);             // charter entry
-        data << uint32(16161);                              // charter display id
-        data << uint32(ARENA_TEAM_CHARTER_3v3_COST);        // charter cost
-        data << uint32(3);                                  // unknown
-        data << uint32(3);                                  // required signs?
-        // 5v5
-        data << uint32(3);                                  // index
-        data << uint32(ARENA_TEAM_CHARTER_5v5);             // charter entry
-        data << uint32(16161);                              // charter display id
-        data << uint32(ARENA_TEAM_CHARTER_5v5_COST);        // charter cost
-        data << uint32(5);                                  // unknown
-        data << uint32(5);                                  // required signs?
-    }
+
+    data << uint32(1);                                  // index
+    data << uint32(GUILD_CHARTER);                      // charter entry
+    data << uint32(16161);                              // charter display id
+    data << uint32(GUILD_CHARTER_COST);                 // charter cost
+    data << uint32(0);                                  // unknown
+    data << uint32(9);                                  // required signs?
+
     //for(uint8 i = 0; i < count; i++)
     //{
     //    data << uint32(i);                      // index
diff --git a/src/game/Player.cpp b/src/game/Player.cpp
--- a/src/game/Player.cpp
+++ b/src/game/Player.cpp
@@ -139,6 +139,7 @@
    	ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race);
 	m_taximask[0] = rEntry->startingTaxiMask;
 
+ /* [TRINITYROLLBACK] useless?
     switch(race)
     {
         case RACE_HUMAN:    SetTaximaskNode(2);  break;     // Human
@@ -150,18 +151,7 @@
         case RACE_TAUREN:   SetTaximaskNode(22); break;     // Tauren
         case RACE_GNOME:    SetTaximaskNode(6);  break;     // Gnome
         case RACE_TROLL:    SetTaximaskNode(23); break;     // Troll
-        /* [TRINITYROLLBACK] case RACE_BLOODELF: SetTaximaskNode(82); break;     // Blood Elf
-        case RACE_DRAENEI:  SetTaximaskNode(94); break;     // Draenei */
-    }
-    // new continent starting masks (It will be accessible only at new map)
-    switch(Player::TeamForRace(race))
-    {
-        case ALLIANCE: SetTaximaskNode(100); break;
-        case HORDE:    SetTaximaskNode(99);  break;
-    }
-    // level dependent taxi hubs
-    if(level>=68)
-        SetTaximaskNode(213);                               //Shattered Sun Staging Area
+    } */
 }
 
 void PlayerTaxi::LoadTaxiMask(const char* data)
@@ -183,7 +173,7 @@
     if(all)
     {
         for (uint8 i=0; i<TaxiMaskSize; i++)
-            data << uint32(sTaxiNodesMask[i]);              // all existed nodes
+            data << sTaxiNodesMask[i];              // all existed nodes
     }
     else
     {
@@ -317,7 +307,6 @@
     m_total_honor_points = 0;
 
     m_GuildIdInvited = 0;
-    m_ArenaTeamIdInvited = 0;
 
     m_atLoginFlags = AT_LOGIN_NONE;
 
@@ -1211,7 +1200,6 @@
             else
             {
                 // use area updates as well
-                // needed for free far all arenas for example
                 uint32 newarea = GetAreaId();
                 if( m_areaUpdateId != newarea )
                     UpdateArea(newarea);
@@ -1541,7 +1529,7 @@
 
     // don't let enter battlegrounds without assigned battleground id (for example through areatrigger)...
     // don't let gm level > 1 either
-    if(!InBattleGround() && mEntry->IsBattleGroundOrArena())
+    if(!InBattleGround() && mEntry->IsBattleGround())
         return false;
 
     // 449 - Champions' Hall (Alliance) // 450 - Hall of Legends (Horde)
@@ -3042,32 +3030,6 @@
         removeSpell(itr2->second.spell, disabled);
 }
 
-void Player::RemoveArenaSpellCooldowns()
-{
-    // remove cooldowns on spells that has < 15 min CD
-    SpellCooldowns::iterator itr, next;
-    // iterate spell cooldowns
-    for(itr = m_spellCooldowns.begin();itr != m_spellCooldowns.end(); itr = next)
-    {
-        next = itr;
-        ++next;
-        SpellEntry const * entry = sSpellStore.LookupEntry(itr->first);
-        // check if spellentry is present and if the cooldown is less than 15 mins
-        if( entry &&
-            entry->RecoveryTime <= 15 * MINUTE * 1000 &&
-            entry->CategoryRecoveryTime <= 15 * MINUTE * 1000 )
-        {
-            // notify player
-            WorldPacket data(SMSG_CLEAR_COOLDOWN, (4+8));
-            data << uint32(itr->first);
-            data << GetGUID();
-            GetSession()->SendPacket(&data);
-            // remove cooldown
-            m_spellCooldowns.erase(itr);
-        }
-    }
-}
-
 void Player::RemoveAllSpellCooldown()
 {
     if(!m_spellCooldowns.empty())
@@ -3558,29 +3520,6 @@
             guild->DelMember(guid);
     }
 
-    // remove from arena teams
- /* [TRINITYROLLBACK]   uint32 at_id = GetArenaTeamIdFromDB(playerguid,ARENA_TEAM_2v2);
-    if(at_id != 0)
-    {
-        ArenaTeam * at = objmgr.GetArenaTeamById(at_id);
-        if(at)
-            at->DelMember(playerguid);
-    }
-    at_id = GetArenaTeamIdFromDB(playerguid,ARENA_TEAM_3v3);
-    if(at_id != 0)
-    {
-        ArenaTeam * at = objmgr.GetArenaTeamById(at_id);
-        if(at)
-            at->DelMember(playerguid);
-    }
-    at_id = GetArenaTeamIdFromDB(playerguid,ARENA_TEAM_5v5);
-    if(at_id != 0)
-    {
-        ArenaTeam * at = objmgr.GetArenaTeamById(at_id);
-        if(at)
-            at->DelMember(playerguid);
-    } */
-
     // the player was uninvited already on logout so just remove from group
     QueryResult *resultGroup = CharacterDatabase.PQuery("SELECT leaderGuid FROM group_member WHERE memberGuid='%u'", guid);
     if(resultGroup)
@@ -4192,7 +4131,7 @@
     // Special handle for battleground maps
     BattleGround *bg = sBattleGroundMgr.GetBattleGround(GetBattleGroundId());
 
-    if(bg && (bg->GetTypeID() == BATTLEGROUND_AB || bg->GetTypeID() == BATTLEGROUND_EY || bg->GetTypeID() == BATTLEGROUND_AV))
+    if(bg && (bg->GetTypeID() == BATTLEGROUND_AB || bg->GetTypeID() == BATTLEGROUND_AV))
         ClosestGrave = bg->GetClosestGraveYard(GetPositionX(), GetPositionY(), GetPositionZ(), GetTeam());
     else
         ClosestGrave = objmgr.GetClosestGraveYard( GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId(), GetTeam() );
@@ -4391,19 +4330,26 @@
 
 float Player::GetMeleeCritFromAgility()
 {
-    uint32 level = getLevel();
-    uint32 pclass = getClass();
-
-    if (level>GT_MAX_LEVEL) level = GT_MAX_LEVEL;
-
-    GtChanceToMeleeCritBaseEntry const *critBase  = sGtChanceToMeleeCritBaseStore.LookupEntry(pclass-1);
-    GtChanceToMeleeCritEntry     const *critRatio = sGtChanceToMeleeCritStore.LookupEntry((pclass-1)*GT_MAX_LEVEL + level-1);
-    if (critBase==NULL || critRatio==NULL)
-        return 0.0f;
-
-    float crit=critBase->base + GetStat(STAT_AGILITY)*critRatio->ratio;
-    return crit*100.0f;
+  // from mangos 3462 for 1.12
+  float val=0,classrate = 0;
+    // critical
+    switch(getClass())
+    {
+        case CLASS_PALADIN: classrate = 19.77; break;
+        case CLASS_SHAMAN:  classrate = 19.7;  break;
+        case CLASS_MAGE:    classrate = 19.44; break;
+        case CLASS_ROGUE:   classrate = 29.0;  break;
+        case CLASS_HUNTER:  classrate = 53.0;  break;       // in 2.0.x = 33
+        case CLASS_PRIEST:
+        case CLASS_WARLOCK:
+        case CLASS_DRUID:
+        case CLASS_WARRIOR:
+        default:            classrate = 20.0; break;
+    }
+
+    val = GetStat(STAT_AGILITY)/classrate;
+  return val;
 }
 
 float Player::GetDodgeFromAgility()
 {
@@ -4406,7 +4352,23 @@
 }
 
 float Player::GetDodgeFromAgility()
 {
+	 // from mangos 3462 for 1.12
+	float val=0,classrate=0;
+
+	//dodge
+    if(getClass() == CLASS_HUNTER) classrate = 26.5;
+    else if(getClass() == CLASS_ROGUE)  classrate = 14.5;
+    else classrate = 20;
+    ///*+(Defense*0,04);
+    if (getRace() == RACE_NIGHTELF)
+        val = GetStat(STAT_AGILITY)/classrate + 1;
+    else
+        val = GetStat(STAT_AGILITY)/classrate;
+
+	return val;
+
+  /* [TRINITYROLLBACK]
     // Table for base dodge values
     float dodge_base[MAX_CLASSES] = {
          0.0075f,   // Warrior
@@ -4447,8 +4409,8 @@
         return 0.0f;
 
     float dodge=dodge_base[pclass-1] + GetStat(STAT_AGILITY) * dodgeRatio->ratio * crit_to_dodge[pclass-1];
-    return dodge*100.0f;
+    return dodge*100.0f; */
 }
 
 float Player::GetSpellCritFromIntellect()
 {
@@ -4451,19 +4413,74 @@
 }
 
 float Player::GetSpellCritFromIntellect()
 {
-    uint32 level = getLevel();
-    uint32 pclass = getClass();
-
-    if (level>GT_MAX_LEVEL) level = GT_MAX_LEVEL;
-
-    GtChanceToSpellCritBaseEntry const *critBase  = sGtChanceToSpellCritBaseStore.LookupEntry(pclass-1);
-    GtChanceToSpellCritEntry     const *critRatio = sGtChanceToSpellCritStore.LookupEntry((pclass-1)*GT_MAX_LEVEL + level-1);
-    if (critBase==NULL || critRatio==NULL)
-        return 0.0f;
-
-    float crit=critBase->base + GetStat(STAT_INTELLECT)*critRatio->ratio;
-    return crit*100.0f;
+   // Chance to crit is computed from INT and LEVEL as follows:
+    //   chance = base + INT / (rate0 + rate1 * LEVEL)
+    // The formula keeps the crit chance at %5 on every level unless the player
+    // increases his intelligence by other means (enchants, buffs, talents, ...)
+
+	//[TRINITYROLLBACK] from mangos 3462 for 1.12 MUST BE CHECKED
+	float val=0;
+
+    static const struct
+    {
+        float base;
+        float rate0, rate1;
+    }
+    crit_data[MAX_CLASSES] =
+    {
+        {                                                   //  0: unused
+            0,0,10
+        },
+        {                                                   //  1: warrior
+            0,0,10
+        },
+        {                                                   //  2: paladin
+            3.70, 14.77, 0.65
+        },
+        {                                                   //  3: hunter
+            0,0,10
+        },
+        {                                                   //  4: rogue
+            0,0,10
+        },
+        {                                                   //  5: priest
+            2.97, 10.03, 0.82
+        },
+        {                                                   //  6: unused
+            0,0,10
+        },
+        {                                                   //  7: shaman
+            3.54, 11.51, 0.80
+        },
+        {                                                   //  8: mage
+            3.70, 14.77, 0.65
+        },
+        {                                                   //  9: warlock
+            3.18, 11.30, 0.82
+        },
+        {                                                   // 10: unused
+            0,0,10
+        },
+        {                                                   // 11: druid
+            3.33, 12.41, 0.79
+        }
+    };
+    float crit_chance;
+
+    // only players use intelligence for critical chance computations
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        int my_class = getClass();
+        float crit_ratio = crit_data[my_class].rate0 + crit_data[my_class].rate1*getLevel();
+        crit_chance = crit_data[my_class].base + GetStat(STAT_INTELLECT) / crit_ratio;
+    }
+    else
+        crit_chance = m_baseSpellCritChance;
+
+    crit_chance = crit_chance > 0.0 ? crit_chance : 0.0;
+
+    return crit_chance;
 }
 
 float Player::OCTRegenHPPerSpirit()
@@ -6085,17 +6102,6 @@
     else
         return 0;
 }
-/* [TRINITYROLLBACK]
-uint32 Player::GetArenaTeamIdFromDB(uint64 guid, uint8 type)
-{
-    QueryResult *result = CharacterDatabase.PQuery("SELECT arena_team_member.arenateamid FROM arena_team_member JOIN arena_team ON arena_team_member.arenateamid = arena_team.arenateamid WHERE guid='%u' AND type='%u' LIMIT 1", GUID_LOPART(guid), type);
-    if(!result)
-        return 0;
-
-    uint32 id = (*result)[0].GetUInt32();
-    delete result;
-    return id;
-} */
 
 uint32 Player::GetZoneIdFromDB(uint64 guid)
 {
@@ -6141,18 +6147,10 @@
 
     AreaTableEntry const* area = GetAreaEntryByAreaID(newArea);
 
-    if(area && (area->flags & AREA_FLAG_ARENA))
-    {
-        if(!isGameMaster())
-            SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_FFA_PVP);
-    }
-    else
-    {
-        // remove ffa flag only if not ffapvp realm
-        // removal in sanctuaries and capitals is handled in zone update
-        if(HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_FFA_PVP) && !sWorld.IsFFAPvPRealm())
-            RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_FFA_PVP);
-    }
+    // remove ffa flag only if not ffapvp realm
+    // removal in sanctuaries and capitals is handled in zone update
+    if(HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_FFA_PVP) && !sWorld.IsFFAPvPRealm())
+        RemoveFlag(PLAYER_FLAGS, PLAYER_FLAGS_FFA_PVP);
 
     UpdateAreaDependentAuras(newArea);
 }
@@ -6437,9 +6435,6 @@
     ApplyItemEquipSpell(item,apply);
     ApplyEnchantment(item, apply);
 
-    if(proto->Socket[0].Color)                              //only (un)equipping of items with sockets can influence metagems, so no need to waste time with normal items
-        CorrectMetaGemEnchants(slot, apply);
-
     sLog.outDebug("_ApplyItemMods complete.");
 }
 
@@ -8012,16 +8007,6 @@
             count += pBag->GetItemCount(item,skipItem);
     }
 
-    if(skipItem && skipItem->GetProto()->GemProperties)
-    {
-        for(int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; i++)
-        {
-            Item *pItem = GetItemByPos( INVENTORY_SLOT_BAG_0, i );
-            if( pItem && pItem != skipItem && pItem->GetProto()->Socket[0].Color )
-                count += pItem->GetGemCountWithID(item);
-        }
-    }
-
     if(inBankAlso)
     {
         for(int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; i++)
@@ -8037,15 +8022,6 @@
                 count += pBag->GetItemCount(item,skipItem);
         }
 
-        if(skipItem && skipItem->GetProto()->GemProperties)
-        {
-            for(int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; i++)
-            {
-                Item* pItem = GetItemByPos( INVENTORY_SLOT_BAG_0, i );
-                if( pItem && pItem != skipItem && pItem->GetProto()->Socket[0].Color )
-                    count += pItem->GetGemCountWithID(item);
-            }
-        }
     }
 
     return count;
@@ -8374,20 +8350,6 @@
             return pItem;
     }
 
-    ItemPrototype const *pProto = objmgr.GetItemPrototype(item);
-    if (pProto && pProto->GemProperties)
-    {
-        for(int i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; i++)
-        {
-            pItem = GetItemByPos( INVENTORY_SLOT_BAG_0, i );
-            if( pItem && pItem->GetProto()->Socket[0].Color )
-            {
-                if (pItem->GetGemCountWithID(item) > 0 )
-                    return pItem;
-            }
-        }
-    }
-
     return NULL;
 }
 
@@ -8417,36 +8379,6 @@
     return EQUIP_ERR_OK;
 }
 
-bool Player::HasItemTotemCategory( uint32 TotemCategory ) const
-{
-    Item *pItem;
-    for(uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
-    {
-        pItem = GetItemByPos( INVENTORY_SLOT_BAG_0, i );
-        if( pItem && IsTotemCategoryCompatiableWith(pItem->GetProto()->TotemCategory,TotemCategory ))
-            return true;
-    }
-    for(uint8 i = KEYRING_SLOT_START; i < KEYRING_SLOT_END; ++i)
-    {
-        pItem = GetItemByPos( INVENTORY_SLOT_BAG_0, i );
-        if( pItem && IsTotemCategoryCompatiableWith(pItem->GetProto()->TotemCategory,TotemCategory ))
-            return true;
-    }
-    for(uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
-    {
-        if(Bag *pBag = (Bag*)GetItemByPos( INVENTORY_SLOT_BAG_0, i ))
-        {
-            for(uint32 j = 0; j < pBag->GetBagSize(); ++j)
-            {
-                pItem = GetItemByPos( i, j );
-                if( pItem && IsTotemCategoryCompatiableWith(pItem->GetProto()->TotemCategory,TotemCategory ))
-                    return true;
-            }
-        }
-    }
-    return false;
-}
-
 uint8 Player::_CanStoreItem_InSpecificSlot( uint8 bag, uint8 slot, ItemPosCountVec &dest, ItemPrototype const *pProto, uint32& count, bool swap, Item* pSrcItem ) const
 {
     Item* pItem2 = GetItemByPos( bag, slot );
@@ -9260,8 +9192,7 @@
 
             // do not allow equipping gear except weapons, offhands, projectiles, relics in
             // - combat
-            // - in-progress arenas
             if( !pProto->CanChangeEquipStateInCombat() )
             {
                 if( isInCombat() )
                     return EQUIP_ERR_NOT_IN_COMBAT;
@@ -9264,11 +9195,7 @@
             if( !pProto->CanChangeEquipStateInCombat() )
             {
                 if( isInCombat() )
                     return EQUIP_ERR_NOT_IN_COMBAT;
-
-                if(BattleGround* bg = GetBattleGround())
-                    if( bg->isArena() && bg->GetStatus() == STATUS_IN_PROGRESS )
-                        return EQUIP_ERR_NOT_DURING_ARENA_MATCH;
             }
 
             if(isInCombat()&& pProto->Class == ITEM_CLASS_WEAPON && m_weaponChangeTimer != 0)
@@ -9306,15 +9233,6 @@
                 if(!enchantEntry)
                     continue;
 
-                /*
-				ItemPrototype const* pGem = objmgr.GetItemPrototype(enchantEntry->GemID);
-                if(pGem && (pGem->Flags & ITEM_FLAGS_UNIQUE_EQUIPPED))
-                {
-                    Item* tItem = GetItemOrItemWithGemEquipped(enchantEntry->GemID);
-                    if(tItem && (!swap || tItem->GetSlot() != eslot ))
-                        return EQUIP_ERR_ITEM_UNIQUE_EQUIPABLE;
-                }
-				*/
             }
 
             // check unique-equipped special item classes
@@ -9400,8 +9318,7 @@
 
     // do not allow unequipping gear except weapons, offhands, projectiles, relics in
     // - combat
-    // - in-progress arenas
     if( !pProto->CanChangeEquipStateInCombat() )
     {
         if( isInCombat() )
             return EQUIP_ERR_NOT_IN_COMBAT;
@@ -9404,11 +9321,7 @@
     if( !pProto->CanChangeEquipStateInCombat() )
     {
         if( isInCombat() )
             return EQUIP_ERR_NOT_IN_COMBAT;
-
-        if(BattleGround* bg = GetBattleGround())
-            if( bg->isArena() && bg->GetStatus() == STATUS_IN_PROGRESS )
-                return EQUIP_ERR_NOT_DURING_ARENA_MATCH;
     }
 
     if(!swap && pItem->IsBag() && !((Bag*)pItem)->IsEmpty())
@@ -10040,7 +9953,7 @@
 
         // Use SetInt16Value to prevent set high part to FFFF for negative value
         SetInt16Value( PLAYER_VISIBLE_ITEM_1_PROPERTIES + (slot * MAX_VISIBLE_ITEM_OFFSET), 0, pItem->GetItemRandomPropertyId());
-        SetUInt32Value(PLAYER_VISIBLE_ITEM_1_PROPERTIES + 1 + (slot * MAX_VISIBLE_ITEM_OFFSET), pItem->GetItemSuffixFactor());
+        // [TRINITYROLLBACK] SetUInt32Value(PLAYER_VISIBLE_ITEM_1_PROPERTIES + 1 + (slot * MAX_VISIBLE_ITEM_OFFSET), pItem->GetItemSuffixFactor());
     }
     else
     {
@@ -10125,6 +10031,5 @@
                         pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_0);
                         pItem->ClearEnchantment(PROP_ENCHANTMENT_SLOT_1);
-                    }
                 }
             }
 
@@ -11180,8 +11085,9 @@
                 else if (item->GetSlot() == EQUIPMENT_SLOT_RANGED)
                     HandleStatModifier(UNIT_MOD_DAMAGE_RANGED, TOTAL_VALUE, float(enchant_amount), apply);
                 break;
-            case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
-                if(enchant_spell_id)
+            /* case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+             [TRINITYROLLBACK] to rewrite [?]
+			   if(enchant_spell_id)
                 {
                     if(apply)
                     {
@@ -11248,7 +11154,7 @@
                             }
                         }
                     }
-                }
+                } 
 
                 sLog.outDebug("Adding %u to stat nb %u",enchant_amount,enchant_spell_id);
                 switch (enchant_spell_id)
@@ -11283,6 +11189,7 @@
                 }
                 break;
             }
+			*/
             case ITEM_ENCHANTMENT_TYPE_TOTEM:               // Shaman Rockbiter Weapon
             {
                 if(getClass() == CLASS_SHAMAN)
@@ -11923,13 +11829,6 @@
     // Give player extra money if GetRewOrReqMoney > 0 and get ReqMoney if negative
     ModifyMoney( pQuest->GetRewOrReqMoney() );
 
-    // title reward
-    if(pQuest->GetCharTitleId())
-    {
-        if(CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(pQuest->GetCharTitleId()))
-            SetTitle(titleEntry);
-    }
-
     // Send reward mail
     if(pQuest->GetRewMailTemplateId())
     {
@@ -13128,41 +13027,6 @@
     delete result;
 }
 
-void Player::_LoadArenaTeamInfo(QueryResult *result)
-{ /* [TRINITYROLLBACK]
-    // arenateamid, played_week, played_season, personal_rating
-    memset((void*)&m_uint32Values[PLAYER_FIELD_ARENA_TEAM_INFO_1_1], 0, sizeof(uint32)*18);
-    if (!result)
-        return;
-
-    do
-    {
-        Field *fields = result->Fetch();
-
-        uint32 arenateamid     = fields[0].GetUInt32();
-        uint32 played_week     = fields[1].GetUInt32();
-        uint32 played_season   = fields[2].GetUInt32();
-        uint32 personal_rating = fields[3].GetUInt32();
-
-        ArenaTeam* aTeam = objmgr.GetArenaTeamById(arenateamid);
-        if(!aTeam)
-        {
-            sLog.outError("FATAL: couldn't load arenateam %u", arenateamid);
-            continue;
-        }
-        uint8  arenaSlot = aTeam->GetSlot();
-
-        m_uint32Values[PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + arenaSlot * 6]     = arenateamid;      // TeamID
-        m_uint32Values[PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + arenaSlot * 6 + 1] = ((aTeam->GetCaptain() == GetGUID()) ? (uint32)0 : (uint32)1); // Captain 0, member 1
-        m_uint32Values[PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + arenaSlot * 6 + 2] = played_week;      // Played Week
-        m_uint32Values[PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + arenaSlot * 6 + 3] = played_season;    // Played Season
-        m_uint32Values[PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + arenaSlot * 6 + 4] = 0;                // Unk
-        m_uint32Values[PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + arenaSlot * 6 + 5] = personal_rating;  // Personal Rating
-
-    }while (result->NextRow());
-    delete result; */
-}
-
 bool Player::LoadPositionFromDB(uint32& mapid, float& x,float& y,float& z,float& o, bool& in_flight, uint64 guid)
 {
     QueryResult *result = CharacterDatabase.PQuery("SELECT position_x,position_y,position_z,orientation,map,taxi_path FROM characters WHERE guid = '%u'",GUID_LOPART(guid));
@@ -13216,37 +13080,6 @@
 
 uint32 Player::GetUInt32ValueFromDB(uint16 index, uint64 guid)
 {
-    // todo: cleanup in this, move to a separate function. [TRINITYROLLBACK]
-/*    if(    index == PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 0 * 6 + 5 
-        || index == PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 1 * 6 + 5
-        || index == PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 2 * 6 + 5
-        || index == PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (0 * 6)
-        || index == PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (1 * 6)
-        || index == PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (2 * 6)
-        || index == UNIT_FIELD_LEVEL)
-    {
-        CachePlayerInfoMap::iterator _iter = objmgr.m_mPlayerInfoMap.find(GUID_LOPART(guid));
-        if(_iter != objmgr.m_mPlayerInfoMap.end())
-        {
-            switch(index)
-            {
-            case (PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 0 * 6 + 5):
-                return _iter->second->unArenaInfoSlot0;
-            case (PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 1 * 6 + 5):
-                return _iter->second->unArenaInfoSlot1;
-            case (PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + 2 * 6 + 5):
-                return _iter->second->unArenaInfoSlot2;
-            case (PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (0 * 6)):
-                return _iter->second->unArenaInfoId0;
-            case (PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (1 * 6)):
-                return _iter->second->unArenaInfoId1;
-            case (PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + (2 * 6)):
-                return _iter->second->unArenaInfoId2;
-            case (UNIT_FIELD_LEVEL):
-                return _iter->second->unLevel;
-            }
-        }
-    } */
     Tokens data;
     if(!LoadValuesArrayFromDB(data,guid))
         return 0;
@@ -13356,30 +13189,6 @@
 
     _LoadGroup(holder->GetResult(PLAYER_LOGIN_QUERY_LOADGROUP));
 
-  /*  _LoadArenaTeamInfo(holder->GetResult(PLAYER_LOGIN_QUERY_LOADARENAINFO));  [TRINITYROLLBACK]
-
-    uint32 arena_currency = GetUInt32Value(PLAYER_FIELD_ARENA_CURRENCY) + fields[33].GetUInt32();
-    if (arena_currency > sWorld.getConfig(CONFIG_MAX_ARENA_POINTS))
-        arena_currency = sWorld.getConfig(CONFIG_MAX_ARENA_POINTS);
-
-    SetUInt32Value(PLAYER_FIELD_ARENA_CURRENCY, arena_currency);
-
-    // check arena teams integrity
-    for(uint32 arena_slot = 0; arena_slot < MAX_ARENA_SLOT; ++arena_slot)
-    {
-        uint32 arena_team_id = GetArenaTeamId(arena_slot);
-        if(!arena_team_id)
-            continue;
-
-        if(ArenaTeam * at = objmgr.GetArenaTeamById(arena_team_id))
-            if(at->HaveMember(GetGUID()))
-                continue;
-
-        // arena team not exist or not member, cleanup fields
-        for(int j =0; j < 6; ++j)
-            SetUInt32Value(PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + arena_slot * 6 + j, 0);
-    } */
-
 	m_highest_rank = fields[33].GetUInt32();
 	m_standing = fields[34].GetUInt32();
 	m_rating = fields[35].GetFloat();
@@ -14265,13 +14074,6 @@
                 {
                     // learn rewarded spell if unknown
                     learnQuestRewardedSpells(pQuest);
-
-                    // set rewarded title if any
-                    if(pQuest->GetCharTitleId())
-                    {
-                        if(CharTitlesEntry const* titleEntry = sCharTitlesStore.LookupEntry(pQuest->GetCharTitleId()))
-                            SetTitle(titleEntry);
-                    }
                 }
 
                 sLog.outDebug("Quest status is {%u} for quest {%u} for player (GUID: %u)", questStatusData.m_status, quest_id, GetGUIDLow());
@@ -14774,7 +14576,7 @@
     // players aren't saved on battleground maps
     uint32 mapid = IsBeingTeleported() ? GetTeleportDest().mapid : GetMapId();
     const MapEntry * me = sMapStore.LookupEntry(mapid);
-    if(!me || me->IsBattleGroundOrArena())
+    if(!me || me->IsBattleGround())
         return;
 
     int is_save_resting = HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING) ? 1 : 0;
@@ -14822,5 +14624,5 @@
     bool save_to_dest = false;
     if(IsBeingTeleported())
     {
-        // don't save to battlegrounds or arenas
+        // don't save to battlegrounds
         const MapEntry *entry = sMapStore.LookupEntry(GetTeleportDest().mapid);
@@ -14826,5 +14628,5 @@
         const MapEntry *entry = sMapStore.LookupEntry(GetTeleportDest().mapid);
-        if(entry && entry->map_type != MAP_BATTLEGROUND && entry->map_type != MAP_ARENA)
+        if(entry && entry->map_type != MAP_BATTLEGROUND)
             save_to_dest = true;
     }
 
@@ -16698,7 +16500,11 @@
                                                            //slot to be excluded while counting
 bool Player::EnchantmentFitsRequirements(uint32 enchantmentcondition, int8 slot)
 {
-    if(!enchantmentcondition)
+   return true;
+
+   /* [TRINITYROLLBACK] to rewrite [?]
+
+	if(!enchantmentcondition)
         return true;
 
     SpellItemEnchantmentConditionEntry const *Condition = sSpellItemEnchantmentConditionStore.LookupEntry(enchantmentcondition);
@@ -16740,13 +16546,6 @@
 
                 //uint8 GemColor = gemProperty->color;
 
-                /*
-				for(uint8 b = 0, tmpcolormask = 1; b < 4; b++, tmpcolormask <<= 1)
-                {
-                    if(tmpcolormask & GemColor)
-                        ++curcount[b];
-                }
-				*/
             }
         }
     }
@@ -16779,87 +16578,10 @@
 
     sLog.outDebug("Checking Condition %u, there are %u Meta Gems, %u Red Gems, %u Yellow Gems and %u Blue Gems, Activate:%s", enchantmentcondition, curcount[0], curcount[1], curcount[2], curcount[3], activate ? "yes" : "no");
 
-    return activate;
-}
-
-void Player::CorrectMetaGemEnchants(uint8 exceptslot, bool apply)
-{
-                                                            //cycle all equipped items
-    for(uint32 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
-    {
-        //enchants for the slot being socketed are handled by Player::ApplyItemMods
-        if(slot == exceptslot)
-            continue;
-
-        Item* pItem = GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
-
-        if(!pItem || !pItem->GetProto()->Socket[0].Color)
-            continue;
-
-        for(uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
-        {
-            uint32 enchant_id = pItem->GetEnchantmentId(EnchantmentSlot(enchant_slot));
-            if(!enchant_id)
-                continue;
-
-            SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
-            if(!enchantEntry)
-                continue;
-
-			/*
-            uint32 condition = enchantEntry->EnchantmentCondition;
-            if(condition)
-            {
-                                                            //was enchant active with/without item?
-                bool wasactive = EnchantmentFitsRequirements(condition, apply ? exceptslot : -1);
-                                                            //should it now be?
-                if(wasactive ^ EnchantmentFitsRequirements(condition, apply ? -1 : exceptslot))
-                {
-                    // ignore item gem conditions
-                                                            //if state changed, (dis)apply enchant
-                    ApplyEnchantment(pItem,EnchantmentSlot(enchant_slot),!wasactive,true,true);
-                }
-            }
-			*/
-        }
-    }
-}
-
-                                                            //if false -> then toggled off if was on| if true -> toggled on if was off AND meets requirements
-void Player::ToggleMetaGemsActive(uint8 exceptslot, bool apply)
-{
-    //cycle all equipped items
-    for(int slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
-    {
-        //enchants for the slot being socketed are handled by WorldSession::HandleSocketOpcode(WorldPacket& recv_data)
-        if(slot == exceptslot)
-            continue;
-
-        Item *pItem = GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
-
-        if(!pItem || !pItem->GetProto()->Socket[0].Color)   //if item has no sockets or no item is equipped go to next item
-            continue;
-
-        //cycle all (gem)enchants
-        for(uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT+3; ++enchant_slot)
-        {
-            uint32 enchant_id = pItem->GetEnchantmentId(EnchantmentSlot(enchant_slot));
-            if(!enchant_id)                                 //if no enchant go to next enchant(slot)
-                continue;
-
-            SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
-            if(!enchantEntry)
-                continue;
-
-            //only metagems to be (de)activated, so only enchants with condition
-            //uint32 condition = enchantEntry->EnchantmentCondition;
-            //if(condition)
-            //    ApplyEnchantment(pItem,EnchantmentSlot(enchant_slot), apply);
-        }
-    }
+    return activate; */
 }
 
 void Player::LeaveBattleground(bool teleportToEntryPoint)
 {
     if(BattleGround *bg = GetBattleGround())
     {
@@ -16860,10 +16582,10 @@
 }
 
 void Player::LeaveBattleground(bool teleportToEntryPoint)
 {
     if(BattleGround *bg = GetBattleGround())
     {
-        bool need_debuf = bg->isBattleGround() && !isGameMaster() && (bg->GetStatus() == STATUS_IN_PROGRESS) && sWorld.getConfig(CONFIG_BATTLEGROUND_CAST_DESERTER);
+        bool need_debuf = !isGameMaster() && (bg->GetStatus() == STATUS_IN_PROGRESS) && sWorld.getConfig(CONFIG_BATTLEGROUND_CAST_DESERTER);
 
         bg->RemovePlayerAtLeave(GetGUID(), teleportToEntryPoint, true);
 
@@ -17640,15 +17362,6 @@
     return sBattleGroundMgr.GetBattleGround(GetBattleGroundId());
 }
 
-bool Player::InArena() const
-{
-    BattleGround *bg = GetBattleGround();
-    if(!bg || !bg->isArena())
-        return false;
-
-    return true;
-}
-
 bool Player::GetBGAccessByLevel(uint32 bgTypeId) const
 {
     // get a template bg instead of running one
@@ -18498,25 +18211,6 @@
            );
 }
 
-bool Player::HasTitle(uint32 bitIndex)
-{/* [TRINITYROLLBACK
-    if (bitIndex > 128)
-        return false;
-
-    uint32 fieldIndexOffset = bitIndex/32;
-    uint32 flag = 1 << (bitIndex%32);
-    return HasFlag(PLAYER__FIELD_KNOWN_TITLES+fieldIndexOffset, flag); */
-	return false; //yehonal workaround
-}
-
-void Player::SetTitle(CharTitlesEntry const* title)
-{/* [TRINITYROLLBACK]
-    uint32 fieldIndexOffset = title->bit_index/32;
-    uint32 flag = 1 << (title->bit_index%32);
-    SetFlag(PLAYER__FIELD_KNOWN_TITLES+fieldIndexOffset, flag); */
-}
-
-
 /*-----------------------TRINITY--------------------------*/
 bool Player::isTotalImmunity()
 {
diff --git a/src/game/Player.h b/src/game/Player.h
--- a/src/game/Player.h
+++ b/src/game/Player.h
@@ -814,7 +814,6 @@
     PLAYER_LOGIN_QUERY_LOADSPELLCOOLDOWNS       = 15,
     PLAYER_LOGIN_QUERY_LOADDECLINEDNAMES        = 16,
     PLAYER_LOGIN_QUERY_LOADGUILD                = 17,
-    PLAYER_LOGIN_QUERY_LOADARENAINFO            = 18,
 
     MAX_PLAYER_LOGIN_QUERY
 };
@@ -1088,7 +1087,6 @@
         uint8 CanUnequipItem( uint16 src, bool swap ) const;
         uint8 CanBankItem( uint8 bag, uint8 slot, ItemPosCountVec& dest, Item *pItem, bool swap, bool not_loading = true ) const;
         uint8 CanUseItem( Item *pItem, bool not_loading = true ) const;
-        bool HasItemTotemCategory( uint32 TotemCategory ) const;
         bool CanUseItem( ItemPrototype const *pItem );
         uint8 CanUseAmmo( uint32 item ) const;
         Item* StoreNewItem( ItemPosCountVec const& pos, uint32 item, bool update,int32 randomPropertyId = 0 );
@@ -1463,7 +1461,6 @@
         void SendCooldownEvent(SpellEntry const *spellInfo);
         void ProhibitSpellScholl(SpellSchoolMask idSchoolMask, uint32 unTimeMs );
         void RemoveSpellCooldown(uint32 spell_id) { m_spellCooldowns.erase(spell_id); }
-        void RemoveArenaSpellCooldowns();
         void RemoveAllSpellCooldown();
         void _LoadSpellCooldowns(QueryResult *result);
         void _SaveSpellCooldowns();
@@ -1785,8 +1782,6 @@
         void _ApplyItemBonuses(ItemPrototype const *proto,uint8 slot,bool apply);
         void _ApplyAmmoBonuses();
         bool EnchantmentFitsRequirements(uint32 enchantmentcondition, int8 slot);
-        void ToggleMetaGemsActive(uint8 exceptslot, bool apply);
-        void CorrectMetaGemEnchants(uint8 slot, bool apply);
         void InitDataForForm(bool reapplyMods = false);
 
         void ApplyItemEquipSpell(Item *item, bool apply, bool form_change = false);
@@ -1815,7 +1810,6 @@
         bool InBattleGround() const { return m_bgBattleGroundID != 0; }
         uint32 GetBattleGroundId() const    { return m_bgBattleGroundID; }
         BattleGround* GetBattleGround() const;
-        bool InArena() const;
 
         static uint32 GetMinLevelForBattleGroundQueueId(uint32 queue_id);
         static uint32 GetMaxLevelForBattleGroundQueueId(uint32 queue_id);
@@ -2091,9 +2085,6 @@
         WorldLocation& GetTeleportDest() { return m_teleport_dest; }
 
         DeclinedName const* GetDeclinedNames() const { return m_declinedname; }
-        bool HasTitle(uint32 bitIndex);
-        bool HasTitle(CharTitlesEntry const* title) { return HasTitle(title->bit_index); }
-        void SetTitle(CharTitlesEntry const* title);
 
     protected:
 
@@ -2154,7 +2145,6 @@
         void _LoadFriendList(QueryResult *result);
         bool _LoadHomeBind(QueryResult *result);
         void _LoadDeclinedNames(QueryResult *result);
-        void _LoadArenaTeamInfo(QueryResult *result);
 
         /*********************************************************/
         /***                   SAVE SYSTEM                     ***/
@@ -2215,7 +2205,6 @@
         QuestStatusMap mQuestStatus;
 
         uint32 m_GuildIdInvited;
-        uint32 m_ArenaTeamIdInvited;
 
         PlayerMails m_mail;
         PlayerSpellMap m_spells;
diff --git a/src/game/SharedDefines.h b/src/game/SharedDefines.h
--- a/src/game/SharedDefines.h
+++ b/src/game/SharedDefines.h
@@ -361,8 +361,6 @@
 #define SPELL_ATTR_EX4_UNK13                      0x00002000            // 13
 #define SPELL_ATTR_EX4_UNK14                      0x00004000            // 14
 #define SPELL_ATTR_EX4_UNK15                      0x00008000            // 15
-#define SPELL_ATTR_EX4_NOT_USABLE_IN_ARENA        0x00010000            // 16 not usable in arena
-#define SPELL_ATTR_EX4_USABLE_IN_ARENA            0x00020000            // 17 usable in arena
 #define SPELL_ATTR_EX4_UNK18                      0x00040000            // 18
 #define SPELL_ATTR_EX4_UNK19                      0x00080000            // 19
 #define SPELL_ATTR_EX4_UNK20                      0x00100000            // 20
@@ -2153,7 +2151,6 @@
     CHAR_DELETE_FAILED                                     = 0x3A,
     CHAR_DELETE_FAILED_LOCKED_FOR_TRANSFER                 = 0x3A,/// UNSURE
     CHAR_DELETE_FAILED_GUILD_LEADER                        = 0x3A,/// UNSURE
-    CHAR_DELETE_FAILED_ARENA_CAPTAIN                       = 0x3A,/// UNSURE
 
     CHAR_LOGIN_IN_PROGRESS                                 = 0x3B,
     CHAR_LOGIN_SUCCESS                                     = 0x3C,
diff --git a/src/game/SocialMgr.cpp b/src/game/SocialMgr.cpp
--- a/src/game/SocialMgr.cpp
+++ b/src/game/SocialMgr.cpp
@@ -232,7 +232,7 @@
 
 void SocialMgr::MakeFriendStatusPacket(FriendsResult result, uint32 guid, WorldPacket *data)
 {
-    data->Initialize(SMSG_FRIEND_STATUS, 5);
+    data->Initialize(SMSG_FRIEND_STATUS, 9);
     *data << uint8(result);
     *data << uint64(guid);
 }
@@ -244,7 +244,8 @@
     WorldPacket data;
     MakeFriendStatusPacket(result, friend_guid, &data);
     GetFriendInfo(player, friend_guid, fi);
-    switch(result)
+    /*[TRINITYROLLBACK] useless ?
+	switch(result)
     {
         case FRIEND_ADDED_OFFLINE:
         case FRIEND_ADDED_ONLINE:
@@ -261,7 +262,7 @@
             data << uint32(fi.Level);
             data << uint32(fi.Class);
             break;
-    }
+    } */
 
     if(broadcast)
         BroadcastToFriendListers(player, &data);
diff --git a/src/game/Spell.cpp b/src/game/Spell.cpp
--- a/src/game/Spell.cpp
+++ b/src/game/Spell.cpp
@@ -3532,15 +3532,6 @@
         if(!((Player*)m_caster)->InBattleGround())
             return SPELL_FAILED_ONLY_BATTLEGROUNDS;
 
-    // do not allow spells to be cast in arenas
-    // - with greater than 15 min CD without SPELL_ATTR_EX4_USABLE_IN_ARENA flag
-    // - with SPELL_ATTR_EX4_NOT_USABLE_IN_ARENA flag
-    if( (m_spellInfo->AttributesEx4 & SPELL_ATTR_EX4_NOT_USABLE_IN_ARENA) ||
-        GetSpellRecoveryTime(m_spellInfo) > 15 * MINUTE * 1000 && !(m_spellInfo->AttributesEx4 & SPELL_ATTR_EX4_USABLE_IN_ARENA) )
-        if(MapEntry const* mapEntry = sMapStore.LookupEntry(m_caster->GetMapId()))
-            if(mapEntry->IsBattleArena())
-                return SPELL_FAILED_NOT_IN_ARENA;
-
     // zone check
     if(!IsSpellAllowedInLocation(m_spellInfo,m_caster->GetMapId(),m_caster->GetZoneId(),m_caster->GetAreaId()))
         return SPELL_FAILED_REQUIRES_AREA;
diff --git a/src/game/SpellAuraDefines.h b/src/game/SpellAuraDefines.h
--- a/src/game/SpellAuraDefines.h
+++ b/src/game/SpellAuraDefines.h
@@ -258,7 +258,6 @@
     SPELL_AURA_MOD_RANGED_ATTACK_POWER_OF_STAT_PERCENT = 212,
     SPELL_AURA_MOD_RAGE_FROM_DAMAGE_DEALT = 213,
     SPELL_AURA_214 = 214,
-    SPELL_AURA_ARENA_PREPARATION = 215,
     SPELL_AURA_HASTE_SPELLS = 216,
     SPELL_AURA_217 = 217,
     SPELL_AURA_HASTE_RANGED = 218,
diff --git a/src/game/SpellAuras.cpp b/src/game/SpellAuras.cpp
--- a/src/game/SpellAuras.cpp
+++ b/src/game/SpellAuras.cpp
@@ -268,7 +268,6 @@
     &Aura::HandleAuraModRangedAttackPowerOfStatPercent,     //212 SPELL_AURA_MOD_RANGED_ATTACK_POWER_OF_STAT_PERCENT
     &Aura::HandleNoImmediateEffect,                         //213 SPELL_AURA_MOD_RAGE_FROM_DAMAGE_DEALT implemented in Player::RewardRage
     &Aura::HandleNULL,                                      //214 Tamed Pet Passive
-    &Aura::HandleArenaPreparation,                          //215 SPELL_AURA_ARENA_PREPARATION
     &Aura::HandleModCastingSpeed,                           //216 SPELL_AURA_HASTE_SPELLS
     &Aura::HandleUnused,                                    //217                                   unused
     &Aura::HandleAuraModRangedHaste,                        //218 SPELL_AURA_HASTE_RANGED
@@ -3565,12 +3541,6 @@
                         {
                             break;
                         }
-                        case BATTLEGROUND_EY:
-                        {
-                           if(GetId() == 34976)
-                                bg->EventPlayerDroppedFlag(((Player*)m_target));
-                            break;
-                        }
                     }
                 }
             }
@@ -5853,7 +5823,6 @@
                 {
                     // Get tick number
                     int32 tick = (m_maxduration - m_duration) / m_modifier.periodictime;
-                    // Default case (not on arenas)
                     if (tick == 0)
                     {
                         (*i)->GetModifier()->m_amount = m_modifier.m_amount;
@@ -5862,36 +5831,6 @@
                         m_isPeriodic = false;
                     }
                     return;
-                    //**********************************************
-                    // Code commended since arena patch not added
-                    // This feature uses only in arenas
-                    //**********************************************
-                    // Here need increase mana regen per tick (6 second rule)
-                    // on 0 tick -   0  (handled in 2 second)
-                    // on 1 tick - 166% (handled in 4 second)
-                    // on 2 tick - 133% (handled in 6 second)
-                    // Not need update after 3 tick
-                    /*
-                    if (tick > 3)
-                        return;
-                    // Apply bonus for 0 - 3 tick
-                    switch (tick)
-                    {
-                        case 0:   // 0%
-                            (*i)->GetModifier()->m_amount = m_modifier.m_amount = 0;
-                            break;
-                        case 1:   // 166%
-                            (*i)->GetModifier()->m_amount = m_modifier.m_amount * 5 / 3;
-                            break;
-                        case 2:   // 133%
-                            (*i)->GetModifier()->m_amount = m_modifier.m_amount * 4 / 3;
-                            break;
-                        default:  // 100% - normal regen
-                            (*i)->GetModifier()->m_amount = m_modifier.m_amount;
-                            break;
-                    }
-                    ((Player*)m_target)->UpdateManaRegen();
-                    return;*/
                 }
             }
             return;
@@ -6121,15 +6060,3 @@
         }
     }
 }
-
-void Aura::HandleArenaPreparation(bool apply, bool Real)
-{
-    if(!Real)
-        return;
-
-    if(apply)
-        m_target->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PREPARATION);
-    else
-        m_target->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PREPARATION);
-}
-
diff --git a/src/game/SpellAuras.h b/src/game/SpellAuras.h
--- a/src/game/SpellAuras.h
+++ b/src/game/SpellAuras.h
@@ -206,7 +206,6 @@
         void HandleSchoolAbsorb(bool apply, bool Real);
         void HandlePreventFleeing(bool apply, bool Real);
         void HandleManaShield(bool apply, bool Real);
-        void HandleArenaPreparation(bool apply, bool Real);
 
         virtual ~Aura();
 
diff --git a/src/game/SpellEffects.cpp b/src/game/SpellEffects.cpp
--- a/src/game/SpellEffects.cpp
+++ b/src/game/SpellEffects.cpp
@@ -2872,17 +2872,6 @@
                 return;
             }
         }
-        else if (goInfo->type == GAMEOBJECT_TYPE_FLAGSTAND)
-        {
-            //isAllowUseBattleGroundObject() already called in CanCast()
-            // in battleground check
-            if(BattleGround *bg = player->GetBattleGround())
-            {
-                if(bg->GetTypeID() == BATTLEGROUND_EY)
-                    bg->EventPlayerClickedOnFlag(player, gameObjTarget);
-                return;
-            }
-        }
         // handle outdoor pvp object opening, return true if go was registered for handling
         // these objects must have been spawned by outdoorpvp!
         else if(gameObjTarget->GetGOInfo()->type == GAMEOBJECT_TYPE_GOOBER && sOutdoorPvPMgr.HandleOpenGo(player, gameObjTarget->GetGUID()))
diff --git a/src/game/SpellHandler.cpp b/src/game/SpellHandler.cpp
--- a/src/game/SpellHandler.cpp
+++ b/src/game/SpellHandler.cpp
@@ -84,15 +84,6 @@
         return;
     }
 
-    // only allow conjured consumable, bandage, poisons (all should have the 2^21 item flag set in DB)
-    if( proto->Class == ITEM_CLASS_CONSUMABLE &&
-        !(proto->Flags & ITEM_FLAGS_USEABLE_IN_ARENA) &&
-        pUser->InArena())
-    {
-        pUser->SendEquipError(EQUIP_ERR_NOT_DURING_ARENA_MATCH,pItem,NULL);
-        return;
-    }
-
     if (pUser->isInCombat())
     {
         for(int i = 0; i < 5; ++i)
diff --git a/src/game/SpellMgr.h b/src/game/SpellMgr.h
--- a/src/game/SpellMgr.h
+++ b/src/game/SpellMgr.h
@@ -344,7 +344,6 @@
     SPELL_FAILED_PLAY_TIME                      = 0x93,
     SPELL_FAILED_REPUTATION                     = 0x94,
     SPELL_FAILED_MIN_SKILL                      = 0x95,
-    SPELL_FAILED_NOT_IN_ARENA                   = 0x96,
     SPELL_FAILED_NOT_ON_SHAPESHIFT              = 0x97,
     SPELL_FAILED_NOT_ON_STEALTHED               = 0x98,
     SPELL_FAILED_NOT_ON_DAMAGE_IMMUNE           = 0x99,
@@ -360,7 +359,6 @@
     SPELL_FAILED_PARTIAL_PLAYTIME               = 0xA3,
     SPELL_FAILED_NO_PLAYTIME                    = 0xA4,
     SPELL_FAILED_NOT_IN_BATTLEGROUND            = 0xA5,
-    SPELL_FAILED_ONLY_IN_ARENA                  = 0xA6,
     SPELL_FAILED_TARGET_LOCKED_TO_RAID_INSTANCE = 0xA7,
     SPELL_FAILED_UNKNOWN                        = 0xA8,
 };
diff --git a/src/game/TradeHandler.cpp b/src/game/TradeHandler.cpp
--- a/src/game/TradeHandler.cpp
+++ b/src/game/TradeHandler.cpp
@@ -128,7 +128,6 @@
 
     WorldPacket data(SMSG_TRADE_STATUS_EXTENDED, (100));    // guess size
     data << (uint8 ) 1;                                     // can be different (only seen 0 and 1)
-    data << (uint32) 0;                                     // added in 2.4.0, this value must be equal to value from TRADE_STATUS_OPEN_WINDOW status packet (different value for different players to block multiple trades?)
     data << (uint32) TRADE_SLOT_COUNT;                      // trade slots count/number?, = next field in most cases
     data << (uint32) TRADE_SLOT_COUNT;                      // trade slots count/number?, = prev field in most cases
     data << (uint32) _player->pTrader->tradeGold;           // trader gold
diff --git a/src/game/Unit.cpp b/src/game/Unit.cpp
--- a/src/game/Unit.cpp
+++ b/src/game/Unit.cpp
@@ -4415,22 +4415,6 @@
     }
 }
 
-void Unit::RemoveArenaAuras(bool onleave)
-{
-    // in join, remove positive buffs, on end, remove negative
-    // used to remove positive visible auras in arenas
-    for(AuraMap::iterator iter = m_Auras.begin(); iter != m_Auras.end();)
-    {
-        if ( !(iter->second->GetSpellProto()->AttributesEx4 & (1<<21)) // don't remove stances, shadowform, pally/hunter auras
-            && !iter->second->IsPassive()                               // don't remove passive auras
-            && (!(iter->second->GetSpellProto()->Attributes & SPELL_ATTR_UNAFFECTED_BY_INVULNERABILITY) || !(iter->second->GetSpellProto()->Attributes & SPELL_ATTR_UNK8))   // not unaffected by invulnerability auras or not having that unknown flag (that seemed the most probable)
-            && (iter->second->IsPositive() ^ onleave))                   // remove positive buffs on enter, negative buffs on leave
-            RemoveAura(iter);
-        else
-            ++iter;
-    }
-}
-
 void Unit::RemoveAllAurasOnDeath()
 {
     // used just after dieing to remove all visible auras
diff --git a/src/game/Unit.h b/src/game/Unit.h
--- a/src/game/Unit.h
+++ b/src/game/Unit.h
@@ -521,7 +521,7 @@
     UNIT_NPC_FLAG_SPIRITGUIDE           = 0x00008000,       // guessed
     UNIT_NPC_FLAG_INNKEEPER             = 0x00010000,       // 100%
     UNIT_NPC_FLAG_BANKER                = 0x00020000,       // 100%
-    UNIT_NPC_FLAG_PETITIONER            = 0x00040000,       // 100% 0xC0000 = guild petitions, 0x40000 = arena team petitions
+    UNIT_NPC_FLAG_PETITIONER            = 0x00040000,       // 100% 0xC0000 = guild petitions
     UNIT_NPC_FLAG_TABARDDESIGNER        = 0x00080000,       // 100%
     UNIT_NPC_FLAG_BATTLEMASTER          = 0x00100000,       // 100%
     UNIT_NPC_FLAG_AUCTIONEER            = 0x00200000,       // 100%
@@ -1152,7 +1152,6 @@
         void RemoveMovementImpairingAuras();
 
         void RemoveAllAuras();
-        void RemoveArenaAuras(bool onleave = false);
         void RemoveAllAurasOnDeath();
         void DelayAura(uint32 spellId, uint32 effindex, int32 delaytime);
 
diff --git a/src/game/World.cpp b/src/game/World.cpp
--- a/src/game/World.cpp
+++ b/src/game/World.cpp
@@ -718,27 +718,6 @@
         m_configs[CONFIG_START_HONOR_POINTS] = m_configs[CONFIG_MAX_HONOR_POINTS];
     }
 
-    m_configs[CONFIG_MAX_ARENA_POINTS] = sConfig.GetIntDefault("MaxArenaPoints", 5000);
-    if(m_configs[CONFIG_MAX_ARENA_POINTS] < 0)
-    {
-        sLog.outError("MaxArenaPoints (%i) can't be negative. Set to 0.",m_configs[CONFIG_MAX_ARENA_POINTS]);
-        m_configs[CONFIG_MAX_ARENA_POINTS] = 0;
-    }
-
-    m_configs[CONFIG_START_ARENA_POINTS] = sConfig.GetIntDefault("StartArenaPoints", 0);
-    if(m_configs[CONFIG_START_ARENA_POINTS] < 0)
-    {
-        sLog.outError("StartArenaPoints (%i) must be in range 0..MaxArenaPoints(%u). Set to %u.",
-            m_configs[CONFIG_START_ARENA_POINTS],m_configs[CONFIG_MAX_ARENA_POINTS],0);
-        m_configs[CONFIG_START_ARENA_POINTS] = 0;
-    }
-    else if(m_configs[CONFIG_START_ARENA_POINTS] > m_configs[CONFIG_MAX_ARENA_POINTS])
-    {
-        sLog.outError("StartArenaPoints (%i) must be in range 0..MaxArenaPoints(%u). Set to %u.",
-            m_configs[CONFIG_START_ARENA_POINTS],m_configs[CONFIG_MAX_ARENA_POINTS],m_configs[CONFIG_MAX_ARENA_POINTS]);
-        m_configs[CONFIG_START_ARENA_POINTS] = m_configs[CONFIG_MAX_ARENA_POINTS];
-    }
-
     m_configs[CONFIG_ALL_TAXI_PATHS] = sConfig.GetBoolDefault("AllFlightPaths", false);
 
     m_configs[CONFIG_INSTANCE_IGNORE_LEVEL] = sConfig.GetBoolDefault("Instance.IgnoreLevel", false);
@@ -903,11 +882,6 @@
     m_configs[CONFIG_LISTEN_RANGE_TEXTEMOTE] = sConfig.GetIntDefault("ListenRange.TextEmote", 25);
     m_configs[CONFIG_LISTEN_RANGE_YELL]      = sConfig.GetIntDefault("ListenRange.Yell", 300);
 
-    m_configs[CONFIG_ARENA_MAX_RATING_DIFFERENCE] = sConfig.GetIntDefault("Arena.MaxRatingDifference", 0);
-    m_configs[CONFIG_ARENA_RATING_DISCARD_TIMER] = sConfig.GetIntDefault("Arena.RatingDiscardTimer",300000);
-    m_configs[CONFIG_ARENA_AUTO_DISTRIBUTE_POINTS] = sConfig.GetBoolDefault("Arena.AutoDistributePoints", false);
-    m_configs[CONFIG_ARENA_AUTO_DISTRIBUTE_INTERVAL_DAYS] = sConfig.GetIntDefault("Arena.AutoDistributeInterval", 7);
-
     m_configs[CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER] = sConfig.GetIntDefault("BattleGround.PrematureFinishTimer", 0);
     m_configs[CONFIG_INSTANT_LOGOUT] = sConfig.GetIntDefault("InstantLogout", SEC_MODERATOR);
 
@@ -1278,9 +1252,6 @@
     sLog.outString( "Loading Guilds..." );
     objmgr.LoadGuilds();
 
-    sLog.outString( "Loading ArenaTeams..." );
- //[TRINITYROLLBACK]   objmgr.LoadArenaTeams();
-
     sLog.outString( "Loading Groups..." );
     objmgr.LoadGroups();
 
@@ -1380,7 +1351,6 @@
     ///- Initialize Battlegrounds
     sLog.outString( "Starting BattleGround System" );
     sBattleGroundMgr.CreateInitialBattleGrounds();
-    sBattleGroundMgr.InitAutomaticArenaPointDistribution();
 
     ///- Initialize outdoor pvp
     sLog.outString( "Starting Outdoor PvP System" );
diff --git a/src/game/World.h b/src/game/World.h
--- a/src/game/World.h
+++ b/src/game/World.h
@@ -110,8 +110,6 @@
     CONFIG_START_PLAYER_MONEY,
     CONFIG_MAX_HONOR_POINTS,
     CONFIG_START_HONOR_POINTS,
-    CONFIG_MAX_ARENA_POINTS,
-    CONFIG_START_ARENA_POINTS,
     CONFIG_INSTANCE_IGNORE_LEVEL,
     CONFIG_INSTANCE_IGNORE_RAID,
     CONFIG_BATTLEGROUND_CAST_DESERTER,
@@ -179,10 +177,6 @@
     CONFIG_LISTEN_RANGE_SAY,
     CONFIG_LISTEN_RANGE_TEXTEMOTE,
     CONFIG_LISTEN_RANGE_YELL,
-    CONFIG_ARENA_MAX_RATING_DIFFERENCE,
-    CONFIG_ARENA_RATING_DISCARD_TIMER,
-    CONFIG_ARENA_AUTO_DISTRIBUTE_POINTS,
-    CONFIG_ARENA_AUTO_DISTRIBUTE_INTERVAL_DAYS,
     CONFIG_BATTLEGROUND_PREMATURE_FINISH_TIMER,
 
     CONFIG_MAX_WHO,
diff --git a/src/game/WorldSession.h b/src/game/WorldSession.h
--- a/src/game/WorldSession.h
+++ b/src/game/WorldSession.h
@@ -177,5 +177,5 @@
         void SendDoFlight( uint16 MountId, uint32 path, uint32 pathNode = 0 );
         bool SendLearnNewTaxiNode( Creature* unit );
 
-        // Guild/Arena Team
+        // Guild
         void SendGuildCommandResult(uint32 typecmd, const std::string& str, uint32 cmdresult);
@@ -181,6 +181,3 @@
         void SendGuildCommandResult(uint32 typecmd, const std::string& str, uint32 cmdresult);
-        void SendArenaTeamCommandResult(uint32 team_action, const std::string& team, const std::string& player, uint32 error_id);
-        void BuildArenaTeamEventPacket(WorldPacket *data, uint8 eventid, uint8 str_count, const std::string& str1, const std::string& str2, const std::string& str3);
-        void SendNotInArenaTeamPacket(uint8 type);
         void SendPetitionShowList( uint64 guid );
         void SendSaveGuildEmblem( uint32 msg );
@@ -185,6 +182,6 @@
         void SendPetitionShowList( uint64 guid );
         void SendSaveGuildEmblem( uint32 msg );
-        void SendBattleGroundOrArenaJoinError(uint8 err);
+        void SendBattleGroundJoinError(uint8 err);
 
         // Looking For Group
         // TRUE values set by client sending CMSG_LFG_SET_AUTOJOIN and CMSG_LFM_CLEAR_AUTOFILL before player login
@@ -561,7 +558,6 @@
         void HandleBattleGroundPlayerPortOpcode( WorldPacket &recv_data );
         void HandleBattleGroundListOpcode( WorldPacket &recv_data );
         void HandleBattleGroundLeaveOpcode( WorldPacket &recv_data );
-        void HandleBattleGroundArenaJoin( WorldPacket &recv_data );
         void HandleBattleGroundReportAFK( WorldPacket &recv_data );
 
         void HandleWardenDataOpcode(WorldPacket& recv_data);
@@ -583,18 +579,6 @@
         void HandleWhoisOpcode(WorldPacket& recv_data);
         void HandleResetInstancesOpcode(WorldPacket& recv_data);
 
-        // Arena Team
-  /*[TRINITYROLLBACK]      void HandleInspectArenaStatsOpcode(WorldPacket& recv_data);
-        void HandleArenaTeamQueryOpcode(WorldPacket& recv_data);
-        void HandleArenaTeamRosterOpcode(WorldPacket& recv_data);
-        void HandleArenaTeamAddMemberOpcode(WorldPacket& recv_data);
-        void HandleArenaTeamInviteAcceptOpcode(WorldPacket& recv_data);
-        void HandleArenaTeamInviteDeclineOpcode(WorldPacket& recv_data);
-        void HandleArenaTeamLeaveOpcode(WorldPacket& recv_data);
-        void HandleArenaTeamRemoveFromTeamOpcode(WorldPacket& recv_data);
-        void HandleArenaTeamDisbandOpcode(WorldPacket& recv_data);
-        void HandleArenaTeamPromoteToCaptainOpcode(WorldPacket& recv_data); */
-
         void HandleAreaSpiritHealerQueryOpcode(WorldPacket& recv_data);
         void HandleAreaSpiritHealerQueueOpcode(WorldPacket& recv_data);
         void HandleDismountOpcode(WorldPacket& recv_data);
@@ -602,9 +586,6 @@
         void HandleReportSpamOpcode(WorldPacket& recv_data);
         void HandleRequestPetInfoOpcode(WorldPacket& recv_data);
 
-        // Socket gem
-        void HandleSocketOpcode(WorldPacket& recv_data);
-
         void HandleCancelTempItemEnchantmentOpcode(WorldPacket& recv_data);
 
         void HandleChannelEnableVoiceOpcode(WorldPacket & recv_data);
diff --git a/src/shared/Database/DBCEnums.h b/src/shared/Database/DBCEnums.h
--- a/src/shared/Database/DBCEnums.h
+++ b/src/shared/Database/DBCEnums.h
@@ -43,6 +43,5 @@
     AREA_FLAG_UNK3             = 0x00000010,                // unknown
     AREA_FLAG_SLAVE_CAPITAL2   = 0x00000020,                // slave capital city flag?
     AREA_FLAG_UNK4             = 0x00000040,                // many zones have this flag
-    AREA_FLAG_ARENA            = 0x00000080,                // arena, both instanced and world arenas
     AREA_FLAG_CAPITAL          = 0x00000100,                // main capital city flag
     AREA_FLAG_CITY             = 0x00000200,                // only for one zone named "City" (where it located?)
@@ -47,6 +46,5 @@
     AREA_FLAG_CAPITAL          = 0x00000100,                // main capital city flag
     AREA_FLAG_CITY             = 0x00000200,                // only for one zone named "City" (where it located?)
-    AREA_FLAG_OUTLAND          = 0x00000400,                // outland zones? (only Eye of the Storm not have this flag, but have 0x00004000 flag)
     AREA_FLAG_SANCTUARY        = 0x00000800,                // sanctuary area (PvP disabled)
     AREA_FLAG_NEED_FLY         = 0x00001000,                // only Netherwing Ledge, Socrethar's Seat, Tempest Keep, The Arcatraz, The Botanica, The Mechanar, Sorrow Wing Point, Dragonspine Ridge, Netherwing Mines, Dragonmaw Base Camp, Dragonmaw Skyway
     AREA_FLAG_UNUSED1          = 0x00002000,                // not used now (no area/zones with this flag set in 2.4.2)
@@ -50,5 +48,4 @@
     AREA_FLAG_SANCTUARY        = 0x00000800,                // sanctuary area (PvP disabled)
     AREA_FLAG_NEED_FLY         = 0x00001000,                // only Netherwing Ledge, Socrethar's Seat, Tempest Keep, The Arcatraz, The Botanica, The Mechanar, Sorrow Wing Point, Dragonspine Ridge, Netherwing Mines, Dragonmaw Base Camp, Dragonmaw Skyway
     AREA_FLAG_UNUSED1          = 0x00002000,                // not used now (no area/zones with this flag set in 2.4.2)
-    AREA_FLAG_OUTLAND2         = 0x00004000,                // outland zones? (only Circle of Blood Arena not have this flag, but have 0x00000400 flag)
     AREA_FLAG_PVP              = 0x00008000,                // pvp objective area? (Death's Door also has this flag although it's no pvp object area)
@@ -54,5 +51,4 @@
     AREA_FLAG_PVP              = 0x00008000,                // pvp objective area? (Death's Door also has this flag although it's no pvp object area)
-    AREA_FLAG_ARENA_INSTANCE   = 0x00010000,                // used by instanced arenas only
     AREA_FLAG_UNUSED2          = 0x00020000,                // not used now (no area/zones with this flag set in 2.4.2)
     AREA_FLAG_UNK5             = 0x00040000,                // just used for Amani Pass, Hatchet Hills
     AREA_FLAG_LOWLEVEL         = 0x00100000                 // used for some starting areas with area_level <=15
@@ -78,7 +74,6 @@
     MAP_INSTANCE        = 1,
     MAP_RAID            = 2,
     MAP_BATTLEGROUND    = 3,
-    MAP_ARENA           = 4
 };
 
 enum AbilytyLearnType
diff --git a/src/shared/Database/DBCStores.cpp b/src/shared/Database/DBCStores.cpp
--- a/src/shared/Database/DBCStores.cpp
+++ b/src/shared/Database/DBCStores.cpp
@@ -38,5 +38,4 @@
 DBCStorage <AreaTriggerEntry> sAreaTriggerStore(AreaTriggerEntryfmt);
 DBCStorage <AuctionHouseEntry> sAuctionHouseStore(AuctionHouseEntryfmt);
 DBCStorage <BankBagSlotPricesEntry> sBankBagSlotPricesStore(BankBagSlotPricesEntryfmt);
-DBCStorage <BattlemasterListEntry> sBattlemasterListStore(BattlemasterListEntryfmt);
 DBCStorage <CharStartOutfitEntry> sCharStartOutfitStore(CharStartOutfitEntryfmt);
@@ -42,5 +41,4 @@
 DBCStorage <CharStartOutfitEntry> sCharStartOutfitStore(CharStartOutfitEntryfmt);
-DBCStorage <CharTitlesEntry> sCharTitlesStore(CharTitlesEntryfmt);
 DBCStorage <ChatChannelsEntry> sChatChannelsStore(ChatChannelsEntryfmt);
 DBCStorage <ChrClassesEntry> sChrClassesStore(ChrClassesEntryfmt);
 DBCStorage <ChrRacesEntry> sChrRacesStore(ChrRacesEntryfmt);
@@ -58,15 +56,4 @@
 DBCStorage <FactionEntry> sFactionStore(FactionEntryfmt);
 DBCStorage <FactionTemplateEntry> sFactionTemplateStore(FactionTemplateEntryfmt);
 
-DBCStorage <GemPropertiesEntry> sGemPropertiesStore(GemPropertiesEntryfmt);
-
-DBCStorage <GtCombatRatingsEntry>         sGtCombatRatingsStore(GtCombatRatingsfmt);
-DBCStorage <GtChanceToMeleeCritBaseEntry> sGtChanceToMeleeCritBaseStore(GtChanceToMeleeCritBasefmt);
-DBCStorage <GtChanceToMeleeCritEntry>     sGtChanceToMeleeCritStore(GtChanceToMeleeCritfmt);
-DBCStorage <GtChanceToSpellCritBaseEntry> sGtChanceToSpellCritBaseStore(GtChanceToSpellCritBasefmt);
-DBCStorage <GtChanceToSpellCritEntry>     sGtChanceToSpellCritStore(GtChanceToSpellCritfmt);
-DBCStorage <GtOCTRegenHPEntry>            sGtOCTRegenHPStore(GtOCTRegenHPfmt);
-DBCStorage <GtRegenHPPerSptEntry>         sGtRegenHPPerSptStore(GtRegenHPPerSptfmt);
-DBCStorage <GtRegenMPPerSptEntry>         sGtRegenMPPerSptStore(GtRegenMPPerSptfmt);
-DBCStorage <ItemEntry>                    sItemStore(Itemfmt);
 DBCStorage <ItemRandomPropertiesEntry> sItemRandomPropertiesStore(ItemRandomPropertiesfmt);
@@ -85,10 +69,9 @@
 DBCStorage <SkillLineEntry> sSkillLineStore(SkillLinefmt);
 DBCStorage <SkillLineAbilityEntry> sSkillLineAbilityStore(SkillLineAbilityfmt);
 
 DBCStorage <SoundEntriesEntry> sSoundEntriesStore(SoundEntriesfmt);
 
 DBCStorage <SpellItemEnchantmentEntry> sSpellItemEnchantmentStore(SpellItemEnchantmentfmt);
-DBCStorage <SpellItemEnchantmentConditionEntry> sSpellItemEnchantmentConditionStore(SpellItemEnchantmentConditionfmt);
 DBCStorage <SpellEntry> sSpellStore(SpellEntryfmt);
 SpellCategoryStore sSpellCategoryStore;
 PetFamilySpellsStore sPetFamilySpellsStore;
@@ -121,7 +104,6 @@
 TaxiPathNodesByPath sTaxiPathNodesByPath;
 
 static DBCStorage <TaxiPathNodeEntry> sTaxiPathNodeStore(TaxiPathNodeEntryfmt);
-DBCStorage <TotemCategoryEntry> sTotemCategoryStore(TotemCategoryEntryfmt);
 DBCStorage <WorldMapAreaEntry>  sWorldMapAreaStore(WorldMapAreaEntryfmt);
 DBCStorage <WorldSafeLocsEntry> sWorldSafeLocsStore(WorldSafeLocsEntryfmt);
 
@@ -380,7 +362,7 @@
     LoadDBC(availableDbcLocales,bar,bad_dbc_files,sTaxiPathNodeStore,        dbcPath,"TaxiPathNode.dbc");
     // Calculate path nodes count
     std::vector<uint32> pathLength;
-    pathLength.resize(pathCount);                           // 0 and some other indexes not used
+    pathLength.resize(pathCount+1);                           // 0 and some other indexes not used
     for(uint32 i = 1; i < sTaxiPathNodeStore.GetNumRows(); ++i)
         if(TaxiPathNodeEntry const* entry = sTaxiPathNodeStore.LookupEntry(i))
             ++pathLength[entry->path];
@@ -547,25 +529,6 @@
     return NULL;
 }
 
-bool IsTotemCategoryCompatiableWith(uint32 itemTotemCategoryId, uint32 requiredTotemCategoryId)
-{
-    if(requiredTotemCategoryId==0)
-        return true;
-    if(itemTotemCategoryId==0)
-        return false;
-
-    TotemCategoryEntry const* itemEntry = sTotemCategoryStore.LookupEntry(itemTotemCategoryId);
-    if(!itemEntry)
-        return false;
-    TotemCategoryEntry const* reqEntry = sTotemCategoryStore.LookupEntry(requiredTotemCategoryId);
-    if(!reqEntry)
-        return false;
-
-    if(itemEntry->categoryType!=reqEntry->categoryType)
-        return false;
-
-    return (itemEntry->categoryMask & reqEntry->categoryMask)==reqEntry->categoryMask;
-}
 
 void Zone2MapCoordinates(float& x,float& y,uint32 zone)
 {
diff --git a/src/shared/Database/DBCStores.h b/src/shared/Database/DBCStores.h
--- a/src/shared/Database/DBCStores.h
+++ b/src/shared/Database/DBCStores.h
@@ -136,6 +136,5 @@
 extern DBCStorage <AreaTriggerEntry>             sAreaTriggerStore;
 extern DBCStorage <AuctionHouseEntry>            sAuctionHouseStore;
 extern DBCStorage <BankBagSlotPricesEntry>       sBankBagSlotPricesStore;
-extern DBCStorage <BattlemasterListEntry>        sBattlemasterListStore;
 //extern DBCStorage <ChatChannelsEntry>           sChatChannelsStore; -- accessed using function, no usable index
 extern DBCStorage <CharStartOutfitEntry>         sCharStartOutfitStore;
@@ -140,6 +139,5 @@
 //extern DBCStorage <ChatChannelsEntry>           sChatChannelsStore; -- accessed using function, no usable index
 extern DBCStorage <CharStartOutfitEntry>         sCharStartOutfitStore;
-extern DBCStorage <CharTitlesEntry>              sCharTitlesStore;
 extern DBCStorage <ChrClassesEntry>              sChrClassesStore;
 extern DBCStorage <ChrRacesEntry>                sChrRacesStore;
 extern DBCStorage <CreatureDisplayInfoEntry>     sCreatureDisplayInfoStore;
@@ -150,12 +148,4 @@
 extern DBCStorage <EmotesTextEntry>              sEmotesTextStore;
 extern DBCStorage <FactionEntry>                 sFactionStore;
 extern DBCStorage <FactionTemplateEntry>         sFactionTemplateStore;
-extern DBCStorage <GemPropertiesEntry>           sGemPropertiesStore;
-
-extern DBCStorage <GtCombatRatingsEntry>         sGtCombatRatingsStore;
-extern DBCStorage <GtChanceToMeleeCritBaseEntry> sGtChanceToMeleeCritBaseStore;
-extern DBCStorage <GtChanceToMeleeCritEntry>     sGtChanceToMeleeCritStore;
-extern DBCStorage <GtChanceToSpellCritBaseEntry> sGtChanceToSpellCritBaseStore;
-extern DBCStorage <GtChanceToSpellCritEntry>     sGtChanceToSpellCritStore;
-extern DBCStorage <GtOCTRegenHPEntry>            sGtOCTRegenHPStore;
 //extern DBCStorage <GtOCTRegenMPEntry>            sGtOCTRegenMPStore; -- not used currently
@@ -161,6 +151,3 @@
 //extern DBCStorage <GtOCTRegenMPEntry>            sGtOCTRegenMPStore; -- not used currently
-extern DBCStorage <GtRegenHPPerSptEntry>         sGtRegenHPPerSptStore;
-extern DBCStorage <GtRegenMPPerSptEntry>         sGtRegenMPPerSptStore;
-extern DBCStorage <ItemEntry>                    sItemStore;
 //extern DBCStorage <ItemDisplayInfoEntry>      sItemDisplayInfoStore; -- not used currently
 extern DBCStorage <ItemRandomPropertiesEntry>    sItemRandomPropertiesStore;
@@ -178,7 +163,6 @@
 extern DBCStorage <SpellDurationEntry>           sSpellDurationStore;
 extern DBCStorage <SpellFocusObjectEntry>        sSpellFocusObjectStore;
 extern DBCStorage <SpellItemEnchantmentEntry>    sSpellItemEnchantmentStore;
-extern DBCStorage <SpellItemEnchantmentConditionEntry> sSpellItemEnchantmentConditionStore;
 extern SpellCategoryStore                        sSpellCategoryStore;
 extern PetFamilySpellsStore                      sPetFamilySpellsStore;
 extern DBCStorage <SpellRadiusEntry>             sSpellRadiusStore;
@@ -193,7 +177,6 @@
 extern TaxiMask                                  sTaxiNodesMask;
 extern TaxiPathSetBySource                       sTaxiPathSetBySource;
 extern TaxiPathNodesByPath                       sTaxiPathNodesByPath;
-extern DBCStorage <TotemCategoryEntry>           sTotemCategoryStore;
 //extern DBCStorage <WorldMapAreaEntry>           sWorldMapAreaStore; -- use Zone2MapCoordinates and Map2ZoneCoordinates
 extern DBCStorage <WorldSafeLocsEntry>           sWorldSafeLocsStore;
 
diff --git a/src/shared/Database/DBCStructure.h b/src/shared/Database/DBCStructure.h
--- a/src/shared/Database/DBCStructure.h
+++ b/src/shared/Database/DBCStructure.h
@@ -80,19 +80,5 @@
     uint32      price;
 };
 
-struct BattlemasterListEntry
-{
-    uint32      id;                                         // 0
-    uint32      mapid[3];                                   // 1-3 mapid
-                                                            // 4-8 unused
-    uint32      type;                                       // 9 (3 - BG, 4 - arena)
-    uint32      minlvl;                                     // 10
-    uint32      maxlvl;                                     // 11
-    uint32      maxplayersperteam;                          // 12
-                                                            // 13-14 unused
-    char*       name[16];                                   // 15-30
-                                                            // 31 string flag, unused
-                                                            // 32 unused
-};
 
 #define MAX_OUTFIT_ITEMS 12
@@ -97,6 +83,5 @@
 
 #define MAX_OUTFIT_ITEMS 12
-// #define MAX_OUTFIT_ITEMS 24                              // 12->24 in 3.0.x
 
 struct CharStartOutfitEntry
 {
@@ -110,16 +95,6 @@
     //uint32 Unknown3;                                      // 40
 };
 
-struct CharTitlesEntry
-{
-    uint32      ID;                                         // 0, title ids, for example in Quest::GetCharTitleId()
-    //uint32      unk1;                                     // 1 flags?
-    //char*       name[16];                                 // 2-17, unused
-                                                            // 18 string flag, unused
-    //char*       name2[16];                                // 19-34, unused
-                                                            // 35 string flag, unused
-    uint32      bit_index;                                  // 36 used in PLAYER_CHOSEN_TITLE and 1<<index in PLAYER__FIELD_KNOWN_TITLES
-};
 
 struct ChatChannelsEntry
 {
@@ -264,13 +239,5 @@
     bool IsContestedGuardFaction() const { return (factionFlags & FACTION_TEMPLATE_FLAG_CONTESTED_GUARD)!=0; }
 };
 
-struct GemPropertiesEntry
-{
-    uint32      ID;
-    uint32      spellitemenchantement;
-    uint32      color;
-};
-
-// All Gt* DBC store data for 100 levels, some by 100 per class/race
 #define GT_MAX_LEVEL    100
 
@@ -275,58 +242,5 @@
 #define GT_MAX_LEVEL    100
 
-struct GtCombatRatingsEntry
-{
-    float    ratio;
-};
-
-struct GtChanceToMeleeCritBaseEntry
-{
-    float    base;
-};
-
-struct GtChanceToMeleeCritEntry
-{
-    float    ratio;
-};
-
-struct GtChanceToSpellCritBaseEntry
-{
-    float    base;
-};
-
-struct GtChanceToSpellCritEntry
-{
-    float    ratio;
-};
-
-struct GtOCTRegenHPEntry
-{
-    float    ratio;
-};
-
-//struct GtOCTRegenMPEntry
-//{
-//    float    ratio;
-//};
-
-struct GtRegenHPPerSptEntry
-{
-    float    ratio;
-};
-
-struct GtRegenMPPerSptEntry
-{
-    float    ratio;
-};
-
-struct ItemEntry
-{
-   uint32 ID;
-   uint32 DisplayId;
-   uint32 InventoryType;
-   uint32 Sheath;
-};
-
 struct ItemDisplayInfoEntry
 {
     uint32      ID;
@@ -402,18 +306,8 @@
                                                             // 37 intro text flags
     uint32      multimap_id;                                // 38
 															// 39-42 unused
-	/*
-	not exists in 1.12
-    int32       entrance_map;                               // 117 map_id of entrance map
-    float       entrance_x;                                 // 118 entrance x coordinate (if exist single entry)
-    float       entrance_y;                                 // 119 entrance y coordinate (if exist single entry)
-    uint32 resetTimeRaid;                                   // 120
-    uint32 resetTimeHeroic;                                 // 121
-                                                            // 122-123
-    uint32      addon;                                      // 124 (0-original maps,1-tbc addon)
-	*/
     // Helpers
     uint32 Expansion() const { return 0;/*addon;*/ }
 
 
     bool IsDungeon() const { return map_type == MAP_INSTANCE || map_type == MAP_RAID; }
@@ -415,8 +309,8 @@
     // Helpers
     uint32 Expansion() const { return 0;/*addon;*/ }
 
 
     bool IsDungeon() const { return map_type == MAP_INSTANCE || map_type == MAP_RAID; }
-    bool Instanceable() const { return map_type == MAP_INSTANCE || map_type == MAP_RAID || map_type == MAP_BATTLEGROUND || map_type == MAP_ARENA; }
+    bool Instanceable() const { return map_type == MAP_INSTANCE || map_type == MAP_RAID || map_type == MAP_BATTLEGROUND; }
     bool IsRaid() const { return map_type == MAP_RAID; }
     bool IsBattleGround() const { return map_type == MAP_BATTLEGROUND; }
@@ -421,7 +315,5 @@
     bool IsRaid() const { return map_type == MAP_RAID; }
     bool IsBattleGround() const { return map_type == MAP_BATTLEGROUND; }
-    bool IsBattleArena() const { return map_type == MAP_ARENA; }
-    bool IsBattleGroundOrArena() const { return map_type == MAP_BATTLEGROUND || map_type == MAP_ARENA; }
     bool SupportsHeroicMode() const { return false; /*resetTimeHeroic && !resetTimeRaid;*/ }
     bool HasResetTime() const { return false; /* resetTimeHeroic || resetTimeRaid; */}
 
@@ -807,15 +690,6 @@
     //uint32      EnchantmentCondition;                       // not exists in 1.12 ?
 };
 
-struct SpellItemEnchantmentConditionEntry
-{
-    uint32  ID;
-    uint8   Color[5];
-    uint8   Comparator[5];
-    uint8   CompareColor[5];
-    uint32  Value[5];
-};
-
 struct StableSlotPricesEntry
 {
     uint32 Slot;
@@ -856,7 +730,7 @@
     float     x;                                            // 2
     float     y;                                            // 3
     float     z;                                            // 4
-    //char*     name[8];                                    // 5-12
+    char*     name[8];                                      // 5-12
                                                             // 13 string flags, unused
     uint32    horde_mount_type;                             // 14
     uint32    alliance_mount_type;                          // 15
@@ -882,15 +756,6 @@
     uint32    delay;
 };
 
-struct TotemCategoryEntry
-{
-    uint32    ID;                                           // 0
-    //char*   name[16];                                     // 1-16
-                                                            // 17 string flags, unused
-    uint32    categoryType;                                 // 18 (one for specialization)
-    uint32    categoryMask;                                 // 19 (compatibility mask for same type: different for totems, compatible from high to low for rods)
-};
-
 struct WorldMapAreaEntry
 {
     //uint32    ID;                                         // 0
@@ -960,7 +825,7 @@
 typedef std::vector<TaxiPathNode> TaxiPathNodeList;
 typedef std::vector<TaxiPathNodeList> TaxiPathNodesByPath;
 
-#define TaxiMaskSize 16
+#define TaxiMaskSize 8
 typedef uint32 TaxiMask[TaxiMaskSize];
 #endif
 
diff --git a/src/shared/Database/DBCfmt.cpp b/src/shared/Database/DBCfmt.cpp
--- a/src/shared/Database/DBCfmt.cpp
+++ b/src/shared/Database/DBCfmt.cpp
@@ -21,6 +21,6 @@
 
 // correct for 1.12
 const char AreaTableEntryfmt[]="iiinixxxxxissssssssxixxxx";
-const char AuctionHouseEntryfmt[]="niiixxxxxxxxx";
-const char AreaTriggerEntryfmt[]="niffffffff";
+const char AreaTriggerEntryfmt[]="niffffffff";                                       // new
+const char AuctionHouseEntryfmt[]="niiixxxxxxxxx";                                   // new                                    // new
 const char BankBagSlotPricesEntryfmt[]="ni";
@@ -26,4 +26,2 @@
 const char BankBagSlotPricesEntryfmt[]="ni";
-const char CharStartOutfitEntryfmt[]="diiiiiiiiiiiiixxxxxxxxxxxxxxxxxxxxxxxxxxx";
-const char ChatChannelsEntryfmt[]="iixssssssssxxxxxxxxxx";
 const char ChrClassesEntryfmt[]="nxxixssssssssixxx";
@@ -29,2 +27,6 @@
 const char ChrClassesEntryfmt[]="nxxixssssssssixxx";
+const char ChrRacesEntryfmt[]="nxixiixxixxxxxixissssssssxxxx";
+const char CharStartOutfitEntryfmt[]="diiiiiiiiiiiiixxxxxxxxxxxxxxxxxxxxxxxxxxx";    // new
+const char ChatChannelsEntryfmt[]="iixssssssssxxxxxxxxxx";                           // new
+const char CreatureDisplayInfofmt[]="nxxxxxxxxfxx";                                  // new
 const char CreatureFamilyfmt[]="nfifiiiissssssssxx";
@@ -30,2 +32,6 @@
 const char CreatureFamilyfmt[]="nfifiiiissssssssxx";
+const char CreatureSpellDatafmt[]="nxxxxxxxx";                                       // new
+const char DurabilityCostsfmt[]="niiiiiiiiiiiiiiiiiiiiiiiiiiiii";                    // new
+const char DurabilityQualityfmt[]="nf";                                              // new
+const char EmoteEntryfmt[]="nxixxxxxxxxxxxxxxxx";
 const char FactionEntryfmt[]="niiiiiiiiiiiiiiiiiissssssssxxxxxxxxxx";
@@ -31,3 +37,5 @@
 const char FactionEntryfmt[]="niiiiiiiiiiiiiiiiiissssssssxxxxxxxxxx";
+const char FactionTemplateEntryfmt[]="niiiiiiiiiiiii";
+const char ItemDisplayTemplateEntryfmt[]="ixxxxxxxxxxixxxxxxxxxxx";
 const char ItemRandomPropertiesfmt[]="nxiiixxxxxxxxxxx";
 const char ItemSetEntryfmt[]="dssssssssxxxxxxxxxxxxxxxxxxiiiiiiiiiiiiiiiiii";
@@ -32,5 +40,7 @@
 const char ItemRandomPropertiesfmt[]="nxiiixxxxxxxxxxx";
 const char ItemSetEntryfmt[]="dssssssssxxxxxxxxxxxxxxxxxxiiiiiiiiiiiiiiiiii";
-const char QuestSortEntryfmt[]="nxxxxxxxxx";
-const char MailTemplateEntryfmt[]="nxxxxxxxxx";
+const char LockEntryfmt[]="niiiiixxxiiiiixxxiixxxxxxxxxxxxxx";
+const char MailTemplateEntryfmt[]="nxxxxxxxxx";                                      // new
+const char MapEntryfmt[]="nxixssssssssxxxxxxxixxxxxxxxxxxxxxxxxxixxx";
+const char QuestSortEntryfmt[]="nxxxxxxxxx";                                         // new
 const char SkillLinefmt[]="nixssssssssxxxxxxxxxxi";
@@ -36,3 +46,14 @@
 const char SkillLinefmt[]="nixssssssssxxxxxxxxxxi";
-const char TaxiNodesEntryfmt[]="nifffxxxxxxxxxii";
+const char SkillLineAbilityfmt[]="niiiixxiiiiixxi";
+const char SoundEntriesfmt[]="nxxxxxxxxxxxxxxxxxxxxxxxxxxxx";	
+const char SpellCastTimefmt[]="nixx";
+const char SpellDurationfmt[]="niii";
+const char SpellEntryfmt[]="niixiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiifxixxiiiiiiiiiiiiiiiiiiiiiiiiiiiiffffffiiiiiiiiiiiiiiiiiiiiifffiiiiiiiiiiiifffixiixssssssssxssssssssxxxxxxxxxxxxxxxxxxxiiiiiiiiiixfffxxx";
+const char SpellFocusObjectfmt[]="nxxxxxxxxx";
+const char SpellItemEnchantmentfmt[]="niiiiiixxxiiissssssssxii";
+const char SpellRadiusfmt[]="nfxf";
+const char SpellRangefmt[]="nffixxxxxxxxxxxxxxxxxx";					 // new
+const char SpellShapeshiftfmt[]="nxxxxxxxxxxixx";                        // new
+const char StableSlotPricesfmt[] = "ni";                                 // new
+const char TalentEntryfmt[]="niiiiiiiixxxxixxixxxi";
 const char TalentTabEntryfmt[]="nxxxxxxxxxxxiix";
@@ -38,6 +59,4 @@
 const char TalentTabEntryfmt[]="nxxxxxxxxxxxiix";
-const char WorldSafeLocsEntryfmt[]="nifffxxxxxxxxx";
-const char WorldMapAreaEntryfmt[]="xinxffff";
-const char TalentEntryfmt[]="niiiiiiiixxxxixxixxxi";
+const char TaxiNodesEntryfmt[]="nifffssssssssxii";
 const char TaxiPathEntryfmt[]="niii";
 const char TaxiPathNodeEntryfmt[]="diiifffii";
@@ -42,11 +61,6 @@
 const char TaxiPathEntryfmt[]="niii";
 const char TaxiPathNodeEntryfmt[]="diiifffii";
-const char SpellFocusObjectfmt[]="nxxxxxxxxx";
-const char SpellItemEnchantmentfmt[]="niiiiiixxxiiissssssssxii";
-const char SpellShapeshiftfmt[]="nxxxxxxxxxxixx";
-const char SpellRangefmt[]="nffixxxxxxxxxxxxxxxxxx";
-const char MapEntryfmt[]="nxixssssssssxxxxxxxixxxxxxxxxxxxxxxxxxixxx";
-const char SpellEntryfmt[]="niixiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiifxixxiiiiiiiiiiiiiiiiiiiiiiiiiiiiffffffiiiiiiiiiiiiiiiiiiiiifffiiiiiiiiiiiifffixiixssssssssxssssssssxxxxxxxxxxxxxxxxxxxiiiiiiiiiixfffxxx";
-const char ChrRacesEntryfmt[]="nxixiixxixxxxxixissssssssxxxx";
+const char WorldMapAreaEntryfmt[]="xinxffff";
+const char WorldSafeLocsEntryfmt[]="nifffxxxxxxxxx";
 // endof correct for 1.12
 
@@ -51,42 +65,2 @@
 // endof correct for 1.12
 
-
-const char BattlemasterListEntryfmt[]="niiixxxxxiiiixxssssssssssssssssxx";
-// 3*12 new item fields in 3.0.x
-//const char CharStartOutfitEntryfmt[]="diiiiiiiiiiiiiiiiiiiiiiiiixxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
-const char CharTitlesEntryfmt[]="nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxi";
-// ChatChannelsEntryfmt, index not used (more compact store)
-//const char ChrClassesEntryfmt[]="nxixxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxix";
-const char CreatureDisplayInfofmt[]="nxxxxxxxxfxx";
-const char CreatureSpellDatafmt[]="nxxxxxxxx";
-const char DurabilityCostsfmt[]="niiiiiiiiiiiiiiiiiiiiiiiiiiiii";
-const char DurabilityQualityfmt[]="nf";
-const char EmoteEntryfmt[]="nxixxxxxxxxxxxxxxxx";
-const char FactionTemplateEntryfmt[]="niiiiiiiiiiiii";
-const char GemPropertiesEntryfmt[]="nixxi";
-const char GtCombatRatingsfmt[]="f";
-
-const char GtChanceToMeleeCritBasefmt[]="f";
-const char GtChanceToMeleeCritfmt[]="f";
-const char GtChanceToSpellCritBasefmt[]="f";
-const char GtChanceToSpellCritfmt[]="f";
-const char GtOCTRegenHPfmt[]="f";
-//const char GtOCTRegenMPfmt[]="f";
-const char GtRegenHPPerSptfmt[]="f";
-const char GtRegenMPPerSptfmt[]="f";
-const char Itemfmt[]="niii";
-//const char ItemDisplayTemplateEntryfmt[]="nxxxxxxxxxxixxxxxxxxxxx";
-//const char ItemCondExtCostsEntryfmt[]="xiii";
-const char ItemExtendedCostEntryfmt[]="niiiiiiiiiiiii";
-const char ItemRandomSuffixfmt[]="nxxxxxxxxxxxxxxxxxxiiiiii";
-const char LockEntryfmt[]="niiiiixxxiiiiixxxiixxxxxxxxxxxxxx";
-const char RandomPropertiesPointsfmt[]="niiiiiiiiiiiiiii";
-const char SkillLineAbilityfmt[]="niiiixxiiiiixxi";
-const char SoundEntriesfmt[]="nxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
-const char SpellCastTimefmt[]="nixx";
-const char SpellDurationfmt[]="niii";
-const char SpellItemEnchantmentConditionfmt[]="nbbbbbxxxxxbbbbbbbbbbiiiiiXXXXX";
-const char SpellRadiusfmt[]="nfxf";
-const char StableSlotPricesfmt[] = "ni";
-const char TotemCategoryEntryfmt[]="nxxxxxxxxxxxxxxxxxii";
-
diff --git a/src/trinitycore/trinitycore.conf.dist b/src/trinitycore/trinitycore.conf.dist
--- a/src/trinitycore/trinitycore.conf.dist
+++ b/src/trinitycore/trinitycore.conf.dist
@@ -1,1382 +1,1344 @@
-##########################################
-# Trinity Core worldd configuration file #
-##########################################
-ConfVersion=2009010301
-
-###################################################################################################################
-# CONNECTIONS AND DIRECTORIES
-#
-#    RealmID
-#        RealmID must match the realmlist inside the realmd database
-#
-#    DataDir
-#        Data directory setting.
-#        Important: DataDir needs to be quoted, as it is a string which may contain space characters.
-#        Example: "@prefix@/share/trinitycore"
-#
-#    LogsDir
-#        Logs directory setting.
-#        Important: Logs dir must exists, or all logs need to be disabled
-#        Default: "" - no log directory prefix, if used log names isn't absolute path
-#        then logs will be stored in current directory for run program.
-#
-#
-#    LoginDatabaseInfo
-#    WorldDatabaseInfo
-#    CharacterDatabaseInfo
-#        Database connection settings for the world server.
-#        Default: hostname;port;username;password;database
-#                 .;somenumber;username;password;database - use named pipes at Windows
-#                    Named pipes: mySQL required adding "enable-named-pipe" to [mysqld] section my.ini
-#                .;/path/to/unix_socket;username;password;database - use Unix sockets at Unix/Linux
-#                    Unix sockets: experimental, not tested
-#
-#    MaxPingTime
-#        Settings for maximum database-ping interval (minutes between pings)
-#
-#    WorldServerPort
-#        Default WorldServerPort
-#
-#    BindIP
-#        Bind World Server to IP/hostname
-#
-###################################################################################################################
-
-RealmID = 1
-DataDir = "."
-LogsDir = ""
-LoginDatabaseInfo     = "127.0.0.1;3306;trinity;trinity;realmd"
-WorldDatabaseInfo     = "127.0.0.1;3306;trinity;trinity;world"
-CharacterDatabaseInfo = "127.0.0.1;3306;trinity;trinity;characters"
-MaxPingTime = 30
-WorldServerPort = 8085
-BindIP = "0.0.0.0"
-
-###################################################################################################################
-# SCRIPTING SETTINGS
-#
-# Locale
-#     Setting for current (DBC) locale to use
-#
-# EventAI Error reporting
-# 0 - Only startup (Default)
-# 1 - Startup errors and Runtime event errors
-# 2 - Startup errors, Runtime event errors, and Creation errors
-###################################################################################################################
-
-Locale = 0
-EAIErrorLevel = 2
-
-###################################################################################################################
-# PERFORMANCE SETINGS
-#
-#    UseProcessors
-#        Used processors mask for multi-processors system (Used only at Windows)
-#        Default: 0 (selected by OS)
-#                 number (bitmask value of selected processors)
-#
-#    ProcessPriority
-#        Process priority setting (Used only at Windows)
-#        Default: 1 (HIGH)
-#                 0 (Normal)
-#
-#    Compression
-#        Compression level for update packages sent to client (1..9)
-#        Default: 1 (speed)
-#                 9 (best compression)
-#
-#    PlayerLimit
-#        Maximum number of players in the world. Excluding Mods, GM's and Admins
-#        Default: 100
-#                 0 (for infinite players)
-#                -1 (for Mods, GM's and Admins only)
-#                -2 (for GM's and Admins only)
-#                -3 (for Admins only)
-#
-#    SaveRespawnTimeImmediately
-#        Save respawn time for creatures at death and for gameobjects at use/open
-#        Default: 1 (save creature/gameobject respawn time without waiting grid unload)
-#                 0 (save creature/gameobject respawn time at grid unload)
-#
-#    MaxOverspeedPings
-#        Maximum overspeed ping count before player kick (minimum is 2, 0 used for disable check)
-#        Default: 2
-#
-#    GridUnload
-#        Unload grids (if you have lot memory you can disable it to speed up player move to new grids second time)
-#        Default: 1 (unload grids)
-#                 0 (do not unload grids)
-#
-#    SocketSelectTime
-#        Socket select time (in milliseconds)
-#        Default: 10000
-#
-#    GridCleanUpDelay
-#        Grid clean up delay (in milliseconds)
-#        Default: 300000 (5 min)
-#
-#    MapUpdateInterval
-#        Map update interval (in milliseconds)
-#        Default: 100
-#
-#    ChangeWeatherInterval
-#        Weather update interval (in milliseconds)
-#        Default: 600000 (10 min)
-#
-#    PlayerSaveInterval
-#        Player save interval (in milliseconds)
-#        Default: 900000 (15 min)
-#
-#    DisconnectToleranceInterval
-#        Tolerance for disconnected players before putting in the queue. (in seconds)
-#        Default: 0 (disabled)
-#
-#    vmap.enableLOS
-#    vmap.enableHeight
-#        Enable/Disable VMmap support for line of sight and height calculation
-#        Default: 1 (true)
-#                 0 (false)
-#
-#    vmap.ignoreMapIds
-#        Map id that will be ignored by VMaps
-#        List of ids with delimiter ','
-#        If more then one id is defined and spaces are included, the string has to be enclosed by "
-#        Example: "369,0,1,530"
-#
-#    vmap.ignoreSpellIds
-#        These spells are ignored for LoS calculation
-#        List of ids with delimiter ','
-#
-#    DetectPosCollision
-#        Check final move position, summon position, etc for visible collision with other objects or
-#        wall (wall only if vmaps are enabled)
-#        Default: 1 (enable, required more CPU power usage)
-#                 0 (disable, less nice position selection but will less CPU power usage)
-#
-#    TargetPosRecalculateRange
-#        Max distance from movement target point (+moving unit size) and targeted object (+size)
-#        after that new target movmeent point calculated. Max: melee attack range (5), min: contact range (0.5)
-#        More distance let have better performence, less distance let have more sensitive reaction at target move.
-#        Default: 1.5
-#
-#    UpdateUptimeInterval
-#        Update realm uptime period in minutes (for save data in 'uptime' table). Must be > 0
-#        Default: 10 (minutes)
-#
-#    MaxCoreStuckTime
-#        Periodically check if the process got freezed, if this is the case force crash after the specified
-#        amount of seconds. Must be > 0. Recommended > 10 secs if you use this.
-#        Default: 0 (Disabled)
-#
-#    AddonChannel
-#        Permit/disable the use of the addon channel through the server
-#        (some client side addons can stop work correctly with disabled addon channel)
-#        Default: 1 (permit addon channel)
-#                 0 (do not permit addon channel)
-#
-###################################################################################################################
-
-UseProcessors = 0
-ProcessPriority = 1
-Compression = 1
-PlayerLimit = 100
-SaveRespawnTimeImmediately = 1
-MaxOverspeedPings = 2
-GridUnload = 1
-SocketSelectTime = 10000
-GridCleanUpDelay = 300000
-MapUpdateInterval = 100
-ChangeWeatherInterval = 600000
-PlayerSaveInterval = 900000
-DisconnectToleranceInterval = 0
-vmap.enableLOS = 0
-vmap.enableHeight = 0
-vmap.ignoreMapIds = "369"
-vmap.ignoreSpellIds = "7720"
-DetectPosCollision = 1
-TargetPosRecalculateRange = 1.5
-UpdateUptimeInterval = 10
-MaxCoreStuckTime = 0
-AddonChannel = 1
-
-###################################################################################################################
-# SERVER LOGGING
-#
-#    LogSQL
-#        Enable logging of GM commands - all SQL code will be written to a log file
-#        All commands are written to a file: YYYY-MM-DD_logSQL.sql
-#        If a new day starts (00:00:00) then a new file is created - the old file will not be deleted.
-#        Default: 1 - Write SQL code to logfile
-#                 0 - Do not log
-#
-#    PidFile
-#        World daemon PID file
-#        Default: ""             - do not create PID file
-#                 "./worldd.pid" - create PID file (recommended name)
-#
-#    LogLevel
-#        Server console level of logging
-#        0 = Minimum; 1 = Basic&Error; 2 = Detail; 3 = Full/Debug
-#        Default: 3
-#
-#    LogTime
-#        Include time in server console output [hh:mm:ss]
-#        Default: 0 (no time)
-#                 1 (print time)
-#
-#    LogFile
-#        Logfile name
-#        Default: "Server.log"
-#                 "" - Empty name disable creating log file
-#
-#    LogTimestamp
-#        Logfile with timestamp of server start in name
-#        Default: 0 - no timestamp in name
-#                 1 - add timestamp in name in form Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
-#
-#    LogFileLevel
-#        Server file level of logging
-#        0 = Minimum; 1 = Error; 2 = Detail; 3 = Full/Debug
-#        Default: 0
-#
-#    LogFilter_TransportMoves
-#    LogFilter_CreatureMoves
-#    LogFilter_VisibilityChanges
-#        Log filters
-#        Default: 1 - not include with any log level
-#                 0 - include in log if log level permit
-#
-#    WorldLogFile
-#        Packet logging file for the worldserver
-#        Default: "world.log"
-#
-#    DBErrorLogFile
-#        Log file of DB errors detected at server run
-#        Default: "DBErrors.log"
-#
-#    CharLogFile
-#        Character operations logfile name
-#        Default: "Char.log"
-#                 "" - Empty name disable creating log file
-#
-#    CharLogTimestamp
-#        Logfile with timestamp of server start in name
-#        Default: 0 - no timestamp in name
-#                 1 - add timestamp in name in form Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
-#
-#    CharLogDump
-#        Write character dump before deleting in Char.log
-#        For restoration, cut character data from log starting from
-#        line == START DUMP == to line == END DUMP == (without its) in file and load it using loadpdump command
-#        Default: 0 - don't include dumping chars to log
-#                 1 - include dumping chars to log
-#
-#    GmLogFile
-#        Log file of gm commands
-#        Default: "gm_commands.log"
-#                 "" - Empty name for disable
-#
-#    GmLogTimestamp
-#        GM Logfile with timestamp of server start in name
-#        Default: 0 - no timestamp in name
-#                 1 - add timestamp in name in form Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
-#
-#    GmLogPerAccount
-#        GM Logfiles with GM account id (Note: logs not created if GmLogFile not set)
-#        Default: 0 - add gm log data to single log file
-#                 1 - add gm log data to account specific log files with name
-#                     in form Logname_#ID_YYYY-MM-DD_HH-MM-SS.Ext
-#                     or form Logname_#ID.Ext
-#
-#    RaLogFile
-#        Log file of RA commands
-#        Default: "Ra.log"
-#                 "" - Empty name for disable
-#
-#    LogColors
-#        Color for messages (format "normal_color details_color debug_color error_color")
-#        Colors: 0 - BLACK, 1 - RED, 2 - GREEN,  3 - BROWN, 4 - BLUE, 5 - MAGENTA, 6 -  CYAN, 7 - GREY,
-#                8 - YELLOW, 9 - LRED, 10 - LGREEN, 11 - LBLUE, 12 - LMAGENTA, 13 - LCYAN, 14 - WHITE
-#        Default: "" - none colors
-#        Example: "13 7 11 9"
-#
-###################################################################################################################
-
-LogSQL = 1
-PidFile = ""
-LogLevel = 1
-LogTime = 0
-LogFile = "Server.log"
-LogTimestamp = 0
-LogFileLevel = 0
-LogFilter_TransportMoves = 1
-LogFilter_CreatureMoves = 1
-LogFilter_VisibilityChanges = 1
-WorldLogFile = ""
-DBErrorLogFile = "db_errors.log"
-CharLogFile = "characters.log"
-CharLogTimestamp = 0
-CharLogDump = 0
-GmLogFile = "gm_commands.log"
-GmLogTimestamp = 0
-GmLogPerAccount = 0
-RaLogFile = "ra_commands.log"
-LogColors = ""
-
-###################################################################################################################
-# SERVER SETTINGS
-#
-#    GameType
-#        Server realm style
-#        0 = NORMAL;1 = PVP; 4 = NORMAL; 6 = RP; 8 = RPPVP
-#        also custom type: 16 FFA_PVP (free for all pvp mode like arena PvP in all zones except rest
-#        activated places and sanctuaries)
-#
-#    RealmZone
-#        Server realm zone (set allowed alphabet in character names/etc). See also Strict*Names options.
-#
-#    1 Development    - any language (Default)
-#    2 United States  - extended-Latin
-#    3 Oceanic        - extended-Latin
-#    4 Latin America  - extended-Latin
-#    5 Tournament     - basic-Latin at create, any at login
-#    6 Korea          - East-Asian
-#    7 Tournament     - basic-Latin at create, any at login
-#    8 English        - extended-Latin
-#    9 German         - extended-Latin
-#    10 French        - extended-Latin
-#    11 Spanish       - extended-Latin
-#    12 Russian       - Cyrillic
-#    13 Tournament    - basic-Latin at create, any at login
-#    14 Taiwan        - East-Asian
-#    15 Tournament    - basic-Latin at create, any at login
-#    16 China         - East-Asian
-#    17 CN1           - basic-Latin at create, any at login
-#    18 CN2           - basic-Latin at create, any at login
-#    19 CN3           - basic-Latin at create, any at login
-#    20 CN4           - basic-Latin at create, any at login
-#    21 CN5           - basic-Latin at create, any at login
-#    22 CN6           - basic-Latin at create, any at login
-#    23 CN7           - basic-Latin at create, any at login
-#    24 CN8           - basic-Latin at create, any at login
-#    25 Tournament    - basic-Latin at create, any at login
-#    26 Test Server   - any language
-#    27 Tournament    - basic-Latin at create, any at login
-#    28 QA Server     - any language
-#    29 CN9           - basic-Latin at create, any at login
-#
-#    Expansion
-#        Allow server use content from expansion
-#                 2 - check expansion 2 maps existence, and if client support expansion 2 and account have
-#                     expansion 2 setting then allow visit expansion 2 maps, allow create new class character)
-#        Default: 1 - check expansion 1 maps existence, and if client support expansion 1 and account have
-#                     expansion 1 setting then allow visit expansion 1 maps, allow create new races character)
-#                 0 - not check expansion maps existence, not allow wisit its, not allow create new race or new class
-#                     characters, ignore account expansion setting)
-#
-#    DBC.Locale
-#        DBC Language Settings
-#        0 = English; 1 = Korean; 2 = French; 3 = German; 4 = Chinese; 5 = Taiwanese; 6 = Spanish; 7 = Spanish Mexico
-#        8 = Russian; 255 = Auto Detect (Default)
-#
-#    DeclinedNames
-#    Allow russian clients to set and use declined names
-#    Default: 0 - do not use declined names, except when the Russian RealmZone is set
-#         1 - use declined names
-#
-#    StrictPlayerNames
-#        Limit player name to language specific symbols set, not allow create characters, and set rename request and disconnect at not allowed symbols name
-#        Default: 0 disable (but limited server timezone dependent client check)
-#                 1 basic latin characters  (strict)
-#                 2 realm zone specific (strict). See RealmZone setting.
-#                   Note: In any case if you want correctly see character name at client this client must have apporopriate fonts
-#                   (included in client by default, with active official localization or custom localization fonts in clientdir/Fonts).
-#                 3 basic latin characters + server timezone specific
-#
-#    StrictCharterNames
-#        Limit guild/arena team charter names to language specific symbols set, not allow create charters with allowed symbols in name
-#        Default: 0 disable
-#                 1 basic latin characters  (strict)
-#                 2 realm zone specific (strict). See RealmZone setting.
-#                   Note: In any case if you want correctly see character name at client this client must have apporopriate fonts
-#                   (included in client by default, with active official localization or custom localization fonts in clientdir/Fonts).
-#                 3 basic latin characters + server timezone specific
-#
-#    StrictPetNames
-#        Limit pet names to language specific symbols set
-#        Default: 0 disable
-#                 1 basic latin characters  (strict)
-#                 2 realm zone specific (strict). See RealmZone setting.
-#                   Note: In any case if you want correctly see character name at client this client must have apporopriate fonts
-#                   (included in client by default, with active official localization or custom localization fonts in clientdir/Fonts).
-#                 3 basic latin characters + server timezone specific
-#
-#    CharactersCreatingDisabled
-#        Disable characters creating for specific team or any (non-player accounts not affected)
-#        Default: 0 - enabled
-#                 1 - disabled only for Alliance
-#                 2 - disabled only for Horde
-#                 3 - disabled for both teams
-#
-#    MaxWhoListReturns
-#        Set the maximum number of players returned in the /who list and interface.
-#        Default: 49 (stable)
-#
-#    CharactersPerAccount
-#        Limit numbers of characters per account (at all realms).
-#        Note: this setting limit character creating at _current_ realm base at characters amount at all realms
-#        Default: 50
-#                The number must be >= CharactersPerRealm
-#
-#    CharactersPerRealm
-#        Limit numbers of characters for account at realm
-#        Default: 10 (client limitation)
-#                The number must be between 1 and 10
-#
-#    SkipCinematics
-#        Disable in-game script movie at first character's login(allows to prevent buggy intro in case of custom start location coordinates)
-#        Default: 0 - show intro for each new characrer
-#                 1 - show intro only for first character of selected race
-#                 2 - disable intro show in all cases
-#
-#    MaxPlayerLevel
-#        Max level that can be reached by player for experience (in range from 1 to 255).
-#        Change not recommended
-#        Default: 70
-#
-#    StartPlayerLevel
-#        Staring level that have character at creating (in range 1 to MaxPlayerLevel)
-#        Default: 1
-#
-#    StartPlayerMoney
-#        Amount of money that new players will start with.
-#        If you want to start with silver, use for example 100 (100 copper = 1 silver)
-#        Default: 0
-#
-#    MaxHonorPoints
-#        Max honor points that player can have.
-#        Default: 75000
-#
-#    StartHonorPoints
-#        Amount of honor that new players will start with
-#        Default: 0
-#
-#    MaxArenaPoints
-#        Max arena points that player can have.
-#        Default: 5000
-#
-#    StartArenaPoints
-#        Amount of arena points that new players will start with
-#        Default: 0
-#
-#    InstantLogout
-#        Enable or disable instant logout for security level (0..4) or high (NOT in combat/while dueling/while falling)
-#        Default: 1 (Mods/GMs/Admins)
-#
-#    DisableWaterBreath
-#        Disable/enable waterbreathing for security level (0..4) or high
-#        Default: 4 (None)
-#
-#    AllFlightPaths
-#        Players will start with all flight paths (Note: ALL flight paths, not only player's team)
-#        Default: 0 (true)
-#                 1 (false)
-#
-#    AlwaysMaxSkillForLevel
-#        Players will automatically gain max level dependent (weapon/defense) skill when logging in, leveling up etc.
-#        Default: 0 (true)
-#                 1 (false)
-#
-#    ActivateWeather
-#        Activate weather system
-#        Default: 1 (true)
-#                 0 (false)
-#
-#    Battleground.CastDeserter
-#        Cast or not Deserter spell at player who leave battleground in progress
-#        Default: 1 (true)
-#                 0 (false)
-#
-#    Battleground.QueueAnnouncer.Enable
-#        Enable queue announcer posting to chat
-#        Default: 1 (true)
-#                 0 (false)
-#
-#    Battleground.QueueAnnouncer.PlayerOnly
-#        Enable queue announcer posting to chat
-#        Default: 0 (false)
-#                 1 (true)
-#
-#   Battleground.PrematureReward
-#	 Reward players in case of prematurely finished BG
-#	 Default: 1 (true)
-#	 	  0 (false)
-#
-#    CastUnstuck
-#        Allow cast or not Unstuck spell at .start or client Help option use
-#        Default: 1 (true)
-#                 0 (false)
-#
-#    Instance.IgnoreLevel
-#        Ignore level requirement to enter instance
-#        Default: 0 (false)
-#                 1 (true)
-#
-#    Instance.IgnoreRaid
-#        Ignore raid requirement to enter instance
-#        Default: 0 (false)
-#                 1 (true)
-#
-#    Instance.ResetTimeHour
-#        The hour of the day (0-23) when the global instance resets occur.
-#        Default: 4
-#
-#    Instance.UnloadDelay
-#        Unload the instance map from memory after some time if no players are inside.
-#        Default: 1800000 (miliseconds, i.e 30 minutes)
-#                 0 (instance maps are kept in memory until they are reset)
-#
-#    Quests.LowLevelHideDiff
-#        Quest level difference to hide for player low level quests:
-#        if player_level > quest_level + LowLevelQuestsHideDiff then quest "!" mark not show for quest giver
-#        Default: 4
-#                -1 (show all available quests marks)
-#
-#    Quests.HighLevelHideDiff
-#        Quest level difference to hide for player high level quests:
-#        if player_level < quest_min_level - HighLevelQuestsHideDiff then quest "!" mark not show for quest giver
-#        Default: 7
-#                -1 (show all available quests marks)
-#
-#    MaxPrimaryTradeSkill
-#        Max count that player can learn the primary trade skill.
-#        Default: 2
-#        Max : 10
-#
-#    MinPetitionSigns
-#        Min signatures count to creating guild (0..9).
-#        Default: 9
-#
-#    MaxGroupXPDistance
-#        Max distance to creature for group memeber to get XP at creature death.
-#        Default: 74
-#
-#    MailDeliveryDelay
-#        Mail delivery delay time for item sending
-#        Default: 3600 sec (1 hour)
-#
-#    SkillChance.Prospecting
-#        For prospecting skillup not possible by default, but can be allowed as custom setting
-#        Default: 0 - no skilups
-#                 1 - skilups possible
-#
-#    Event.Announce
-#        Default: 0 (false)
-#                 1 (true)
-#
-#    BeepAtStart
-#        Beep at core start finished (mostly work only at Unix/Linux systems)
-#        Default: 1 (true)
-#                 0 (false)
-#
-#    Motd
-#        Message of the Day. Displayed at worldlogin for every user ('@' for a newline).
-#
-#    Server.LoginInfo
-#        Enable/disable sending server info (core version) on login.
-#        Default: 0 - disable
-#                 1 - enable
-#
-###################################################################################################################
-
-GameType = 1
-RealmZone = 1
-Expansion = 0
-DBC.Locale = 255
-DeclinedNames = 0
-StrictPlayerNames = 0
-StrictCharterNames = 0
-StrictPetNames = 0
-MaxWhoListReturns = 49
-CharactersCreatingDisabled = 0
-CharactersPerAccount = 50
-CharactersPerRealm = 10
-SkipCinematics = 0
-MaxPlayerLevel = 60
-StartPlayerLevel = 1
-StartPlayerMoney = 0
-MaxHonorPoints = 75000
-StartHonorPoints = 0
-MaxArenaPoints = 5000
-StartArenaPoints = 0
-InstantLogout = 1
-DisableWaterBreath = 4
-AllFlightPaths = 0
-AlwaysMaxSkillForLevel = 0
-ActivateWeather = 1
-Battleground.CastDeserter = 1
-Battleground.QueueAnnouncer.Enable = 1
-Battleground.QueueAnnouncer.PlayerOnly = 0
-Battleground.PrematureReward = 1
-CastUnstuck = 1
-Instance.IgnoreLevel = 0
-Instance.IgnoreRaid = 0
-Instance.ResetTimeHour = 4
-Instance.UnloadDelay = 1800000
-Quests.LowLevelHideDiff = 4
-Quests.HighLevelHideDiff = 7
-MaxPrimaryTradeSkill = 2
-MinPetitionSigns = 9
-MaxGroupXPDistance = 74
-MailDeliveryDelay = 3600
-SkillChance.Prospecting = 0
-Event.Announce = 0
-BeepAtStart = 1
-Motd = "Welcome to a Trinity Core server."
-Server.LoginInfo = 0
-
-###################################################################################################################
-# PLAYER INTERACTION
-#
-#    AllowTwoSide.Accounts
-#        Allow or not accounts to create characters in the 2 teams in any game type.
-#        Default: 0 (Not allowed)
-#                 1 (Allowed)
-#
-#    AllowTwoSide.Interaction.Chat
-#    AllowTwoSide.Interaction.Channel
-#    AllowTwoSide.Interaction.Group
-#    AllowTwoSide.Interaction.Guild
-#    AllowTwoSide.Interaction.Auction
-#    AllowTwoSide.Interaction.Mail
-#        Allow or not common :chat(say,yell);channel(chat)group(join)guild(join);merge all auction houses for players from
-#        different teams, send mail to different team.
-#        Default: 0 (Not allowed)
-#                 1 (Allowed)
-#
-#    AllowTwoSide.WhoList
-#        Allow or not show player from both team in who list.
-#        Default: 0 (Not allowed)
-#                 1 (Allowed)
-#
-#    AllowTwoSide.AddFriend
-#        Allow or not adding friends from other team in friend list.
-#        Default: 0 (Not allowed)
-#                 1 (Allowed)
-#
-#    AllowTwoSide.Trade
-#        Allow or not trading with other team in party.
-#        Default: 0 (Not allowed)
-#                 1 (Allowed)
-#
-#    TalentsInspecting
-#        Allow other players see character talents in inspect dialog (Characters in Gamemaster mode can
-#        inspect talents always)
-#        Default: 1 (allow)
-#                 0 (not allow)
-#
-###################################################################################################################
-
-AllowTwoSide.Accounts = 0
-AllowTwoSide.Interaction.Chat = 0
-AllowTwoSide.Interaction.Channel = 0
-AllowTwoSide.Interaction.Group = 0
-AllowTwoSide.Interaction.Guild = 0
-AllowTwoSide.Interaction.Auction = 0
-AllowTwoSide.Interaction.Mail = 0
-AllowTwoSide.WhoList = 0
-AllowTwoSide.AddFriend = 0
-AllowTwoSide.Trade = 0
-TalentsInspecting = 1
-
-###################################################################################################################
-# CREATURE SETTINGS
-#
-#    ThreatRadius
-#        Radius for creature to evade after being pulled away from combat start point
-#        If ThreatRadius is less than creature aggro radius then aggro radius will be used
-#        Default: 60 yards
-#
-#    Rate.Creature.Aggro
-#        Aggro radius percent or off.
-#        Default: 1   - 100%
-#                 1.5 - 150%
-#                 0   - off (0%)
-#
-#    CreatureFamilyAssistanceRadius
-#        Creature family assistance radius
-#        Default: 10
-#                 0   - off
-#
-#    CreatureFamilyAssistanceDelay
-#        Reaction time for creature assistance call
-#        Default: 1500 (1.5s)
-#
-#    WorldBossLevelDiff
-#        Difference for boss dynamic level with target
-#        Default: 3
-#
-#    Corpse.Decay.NORMAL
-#    Corpse.Decay.RARE
-#    Corpse.Decay.ELITE
-#    Corpse.Decay.RAREELITE
-#    Corpse.Decay.WORLDBOSS
-#        Seconds until creature corpse will decay without being looted or skinned.
-#        Default: 60, 300, 300, 300, 3600
-#
-#    Rate.Corpse.Decay.Looted
-#         Controls how long the creature corpse stays after it had been looted, as a multiplier of its Corpse.Decay.* config.
-#         Default: 0.5
-#
-#    Rate.Creature.Normal.Damage
-#    Rate.Creature.Elite.Elite.Damage
-#    Rate.Creature.Elite.RAREELITE.Damage
-#    Rate.Creature.Elite.WORLDBOSS.Damage
-#    Rate.Creature.Elite.RARE.Damage
-#        Creature Damage Rates.
-#        Examples: 2 - creatures will damage 2x, 1.7 - 1.7x.
-#
-#    Rate.Creature.Normal.SpellDamage
-#    Rate.Creature.Elite.Elite.SpellDamage
-#    Rate.Creature.Elite.RAREELITE.SpellDamage
-#    Rate.Creature.Elite.WORLDBOSS.SpellDamag
-#    Rate.Creature.Elite.RARE.SpellDamage
-#        Creature Spell Damage Rates.
-#        Examples: 2 - creatures will damage with spells 2x, 1.7 - 1.7x.
-#
-#    Rate.Creature.Normal.HP
-#    Rate.Creature.Elite.Elite.HP
-#    Rate.Creature.Elite.RAREELITE.HP
-#    Rate.Creature.Elite.WORLDBOSS.HP
-#    Rate.Creature.Elite.RARE.HP
-#        Creature Health Ammount Modifier.
-#        Examples: 2 - creatures have 2x health, 1.7 - 1.7x.
-#
-#    ListenRange.Say
-#        Distance from player to listen text that creature (or other world object) say
-#        Default: 25
-#
-#    ListenRange.TextEmote
-#        Distance from player to listen textemote that creature (or other world object) say
-#        Default: 25
-#
-#    ListenRange.Yell
-#        Distance from player to listen text that creature (or other world object) yell
-#        Default: 300
-#
-###################################################################################################################
-
-ThreatRadius = 60
-Rate.Creature.Aggro = 1
-CreatureFamilyAssistanceRadius = 10
-CreatureFamilyAssistanceDelay = 1500
-WorldBossLevelDiff = 3
-Corpse.Decay.NORMAL = 60
-Corpse.Decay.RARE = 300
-Corpse.Decay.ELITE = 300
-Corpse.Decay.RAREELITE = 300
-Corpse.Decay.WORLDBOSS = 3600
-Rate.Corpse.Decay.Looted = 0.5
-Rate.Creature.Normal.Damage = 1
-Rate.Creature.Elite.Elite.Damage = 1
-Rate.Creature.Elite.RAREELITE.Damage = 1
-Rate.Creature.Elite.WORLDBOSS.Damage = 1
-Rate.Creature.Elite.RARE.Damage = 1
-Rate.Creature.Normal.SpellDamage = 1
-Rate.Creature.Elite.Elite.SpellDamage = 1
-Rate.Creature.Elite.RAREELITE.SpellDamage = 1
-Rate.Creature.Elite.WORLDBOSS.SpellDamage = 1
-Rate.Creature.Elite.RARE.SpellDamage = 1
-Rate.Creature.Normal.HP = 1
-Rate.Creature.Elite.Elite.HP = 1
-Rate.Creature.Elite.RAREELITE.HP = 1
-Rate.Creature.Elite.WORLDBOSS.HP = 1
-Rate.Creature.Elite.RARE.HP = 1
-ListenRange.Say = 40
-ListenRange.TextEmote = 40
-ListenRange.Yell = 300
-
-###################################################################################################################
-# CHAT SETTINGS
-#
-#    ChatFakeMessagePreventing
-#        Chat protection from creating fake messages using a lot spaces (other invisible symbols),
-#        not applied to addon language messages, but can prevent working old addons
-#        that use normal languages for sending data to another clients.
-#        Default: 0 (disible fake messages preventing)
-#                 1 (enabled fake messages preventing)
-#
-#    ChatFlood.MessageCount
-#        Chat anti-flood protection, haste message count to activate protection
-#        Default: 10
-#                 0 (disible anti-flood protection)
-#
-#    ChatFlood.MessageDelay
-#        Chat anti-flood protection, minimum message delay to count message
-#        Default: 1 (in secs)
-#
-#    ChatFlood.MuteTime
-#        Chat anti-flood protection, mute time at activation flood protection (not saved)
-#        Default: 10 (in secs)
-#
-#    Channel.RestrictedLfg
-#        Restrict use LookupForGroup channel only registered in LFG tool players
-#        Default: 1 (allow join to channel only if active in LFG)
-#                 0 (allow join to channel in any time)
-#
-#    Channel.SilentlyGMJoin
-#        Silently join GM characters (security level > 1) to channels
-#        Default: 0 (join announcement in normal way)
-#                 1 (GM join without announcement)
-#
-###################################################################################################################
-
-ChatFakeMessagePreventing = 0
-ChatFlood.MessageCount = 10
-ChatFlood.MessageDelay = 1
-ChatFlood.MuteTime = 10
-Channel.RestrictedLfg = 1
-Channel.SilentlyGMJoin = 0
-
-###################################################################################################################
-# GAME MASTER SETTINGS
-#
-#    GM.LoginState
-#        GM mode at login
-#        Default: 2 (last save state)
-#                 0 (disable)
-#                 1 (enable)
-#
-#    GM.Chat
-#        GM chat mode at login
-#        Default: 2 (last save state)
-#                 0 (disable)
-#                 1 (enable)
-#
-#    GM.WhisperingTo
-#        Is GM accepting whispers from player by default or not.
-#        Default: 2 (last save state)
-#                 0 (disable)
-#                 1 (enable)
-#
-#    GM.InGMList
-#        Is GM showed in GM list (if visible) in non-GM state (.gmoff)
-#        Default: 0 (false)
-#                 1 (true)
-#
-#    GM.InWhoList
-#        Is GM showed in who list (if visible).
-#        Default: 0 (false)
-#                 1 (true)
-#
-#    GM.LogTrade
-#        Include GM trade and trade slot enchanting operations in GM log if it enable
-#        Default: 1 (include)
-#                 0 (not include)
-#
-#    GM.StartLevel
-#        GM starting level (1-255)
-#        Default: 1
-#
-###################################################################################################################
-
-GM.LoginState     = 2
-GM.Chat           = 2
-GM.WhisperingTo   = 2
-GM.InGMList       = 0
-GM.InWhoList      = 0
-GM.LogTrade       = 1
-GM.StartLevel     = 60
-
-###################################################################################################################
-# VISIBILITY AND RADIUSES
-#
-#    Visibility.GroupMode
-#        Group visibility modes
-#        Default: 0 (standard setting: only members from same group can 100% auto detect invisible player)
-#                 1 (raid members 100% auto detect invisible player from same raid)
-#                 2 (players from same team can 100% auto detect invisible player)
-#
-#    Visibility.Distance.Creature
-#    Visibility.Distance.Player
-#        Visibility distance for different in game object
-#        Max limited by active player zone: ~ 333
-#        Min limit dependent from objects
-#        Default: 132 (cell size)
-#        Min limit is max aggro radius (45) * Rate.Creature.Aggro
-#
-#    Visibility.Distance.Object
-#        Visible distance for gameobject, dynobject, bodies, corpses, bones
-#        Min limit is iteraction distance (5)
-#
-#    Visibility.Distance.InFlight
-#        Visible distance for player in flight
-#        Min limit is 0 (not show any objects)
-#
-#    Visibility.Distance.Grey.Unit
-#        Visibility grey distance for creatures/players (fast changing objects)
-#        addition to appropriate object type Visibility.Distance.* use in case visibility removing to
-#        object (except corpse around distences) If D is distance and G is grey distance then object
-#        make visible if distance to it <= D but make non visible if distance > D+G
-#        Default: 1 (yard)
-#
-#    Visibility.Distance.Grey.Object
-#        Visibility grey distance for dynobjects/gameobjects/corpses/creature bodies
-#        Default: 10 (yards)
-#
-#
-###################################################################################################################
-
-Visibility.GroupMode = 0
-Visibility.Distance.Creature      = 132
-Visibility.Distance.Player        = 132
-Visibility.Distance.Object        = 132
-Visibility.Distance.InFlight      = 132
-Visibility.Distance.Grey.Unit   = 1
-Visibility.Distance.Grey.Object = 10
-
-###################################################################################################################
-# SERVER RATES
-#
-#    Rate.Health
-#    Rate.Mana
-#    Rate.Rage.Income
-#    Rate.Rage.Loss
-#    Rate.Focus
-#    Rate.Loyalty
-#        Health and power regeneration and rage income from damage.
-#        Default: 1
-#
-#    Rate.Skill.Discovery
-#         Skill Discovery Rates
-#         Default: 1
-#
-#    Rate.Drop.Item.Poor
-#    Rate.Drop.Item.Normal
-#    Rate.Drop.Item.Uncommon
-#    Rate.Drop.Item.Rare
-#    Rate.Drop.Item.Epic
-#    Rate.Drop.Item.Legendary
-#    Rate.Drop.Item.Artifact
-#    Rate.Drop.Item.Referenced
-#    Rate.Drop.Money
-#         Drop rates (items by quality and money)
-#         Default: 1
-#
-#    Rate.Drop.Money
-#         Drop rates
-#         Default: 1
-#
-#    Rate.XP.Kill
-#    Rate.XP.Quest
-#    Rate.XP.Explore
-#        XP rates
-#        Default: 1
-#
-#    Rate.XP.PastLevel70
-#        XP needed per level past 70 (Rates below 1 not recommended)
-#        Default: 1
-#
-#    Rate.Rest.InGame
-#    Rate.Rest.Offline.InTavernOrCity
-#    Rate.Rest.Offline.InWilderness
-#        Resting points grow rates (1 - normal, 2 - double rate, 0.5 - half rate, etc) from standard values
-#
-#    Rate.Damage.Fall
-#        Damage after fall rate. (1 - standard, 2 - double damage, 0.5 - half damage, etc)
-#
-#    Rate.Auction.Time
-#    Rate.Auction.Deposit
-#    Rate.Auction.Cut
-#        Auction rates (auction time, deposit get at auction start, auction cut from price at auction end)
-#
-#    Rate.Honor
-#        Honor gain rate
-#
-#    Rate.Mining.Amount
-#    Rate.Mining.Next
-#        Mining Rates (Mining.Amount changes minimum/maximum usetimes of a deposit,
-#        Mining.Next changes chance to have next use of a deposit)
-#
-#    Rate.Talent
-#        Talent Point rates
-#        Default: 1
-#
-#    Rate.Reputation.Gain
-#         Reputation Gain rate
-#         Default: 1
-#
-#    Rate.InstanceResetTime
-#        Multiplier for the number of days in between global raid/heroic instance resets.
-#        Default: 1
-#
-#    SkillGain.Crafting
-#    SkillGain.Defense
-#    SkillGain.Gathering
-#    SkillGain.Weapon
-#         crafting/defense/gathering/weapon skills gain at skill grow (1,2,...)
-#         Default: 1
-#
-#    SkillChance.Orange
-#    SkillChance.Yellow
-#    SkillChance.Green
-#    SkillChance.Grey
-#        Skill chance values (0..100)
-#        Default: 100-75-25-0
-#
-#    SkillChance.MiningSteps
-#    SkillChance.SkinningSteps
-#         For skinning and Mining chance decrease with skill level.
-#         Default: 0  - no decrease
-#                  75 - in 2 times each 75 skill points
-#
-#    DurabilityLossChance.Damage
-#         Chance lost one from equiped items durability point at damage apply or receive.
-#         Default: 0.5 (100/0.5 = 200) Each 200 damage apply one from 19 possible equipped items
-#
-#    DurabilityLossChance.Absorb
-#         Chance lost one from armor items durability point at damage absorb.
-#         Default: 0.5 (100/0.5 = 200) Each 200 absorbs apply one from 15 possible armor equipped items
-#
-#    DurabilityLossChance.Parry
-#         Chance lost weapon durability point at parry.
-#         Default: 0.05 (100/0.05 = 2000) Each 2000 parry attacks main weapon lost point
-#
-#    DurabilityLossChance.Block
-#         Chance lost sheild durability point at damage block.
-#         Default: 0.05 (100/0.05 = 2000) Each 2000 partly or full blocked attacks shield lost point
-#
-#    Death.SicknessLevel
-#         Starting Character start gain sickness at spirit resurrection (1 min)
-#         Default: 11
-#                  -10 - character will have full time (10min) sickness at 1 level
-#                  maxplayerlevel+1 - chaarcter will not have sickess at any level
-#
-#    Death.CorpseReclaimDelay.PvP
-#    Death.CorpseReclaimDelay.PvE
-#         Enabled/disabled increase corpse reclaim delay at often PvP/PvE deaths
-#         Default: 1 (enabled)
-#                  0 (disabled)
-#
-###################################################################################################################
-
-Rate.Health = 1
-Rate.Mana = 1
-Rate.Rage.Income = 1
-Rate.Rage.Loss = 1
-Rate.Focus = 1
-Rate.Loyalty = 1
-Rate.Skill.Discovery = 1
-Rate.Drop.Item.Poor = 1
-Rate.Drop.Item.Normal = 1
-Rate.Drop.Item.Uncommon = 1
-Rate.Drop.Item.Rare = 1
-Rate.Drop.Item.Epic = 1
-Rate.Drop.Item.Legendary = 1
-Rate.Drop.Item.Artifact = 1
-Rate.Drop.Item.Referenced = 1
-Rate.Drop.Money = 1
-Rate.XP.Kill    = 1
-Rate.XP.Quest   = 1
-Rate.XP.Explore = 1
-Rate.XP.PastLevel70 = 1
-Rate.Rest.InGame = 1
-Rate.Rest.Offline.InTavernOrCity = 1
-Rate.Rest.Offline.InWilderness = 1
-Rate.Damage.Fall = 1
-Rate.Auction.Time = 1
-Rate.Auction.Deposit = 1
-Rate.Auction.Cut = 1
-Rate.Honor = 1
-Rate.Mining.Amount = 1
-Rate.Mining.Next   = 1
-Rate.Talent = 1
-Rate.Reputation.Gain = 1
-Rate.InstanceResetTime = 1
-SkillGain.Crafting = 1
-SkillGain.Defense = 1
-SkillGain.Gathering = 1
-SkillGain.Weapon = 1
-SkillChance.Orange = 100
-SkillChance.Yellow = 75
-SkillChance.Green  = 25
-SkillChance.Grey   = 0
-SkillChance.MiningSteps   = 0
-SkillChance.SkinningSteps = 0
-DurabilityLossChance.Damage = 0.5
-DurabilityLossChance.Absorb = 0.5
-DurabilityLossChance.Parry  = 0.05
-DurabilityLossChance.Block  = 0.05
-Death.SicknessLevel = 11
-Death.CorpseReclaimDelay.PvP = 1
-Death.CorpseReclaimDelay.PvE = 0
-
-###################################################################################################################
-#
-# Rated arena matches config
-#
-# MaxRatingDifference: the maximum rating difference between two groups in rated matches
-#             Default: 0 (disable, rating difference is discarded)
-#
-# RatingDiscardTimer: after the specified milliseconds has passed,
-#                     rating information will be discarded when selecting teams for matches
-#                     also initiates an update by this timer
-#             Default: 60000
-#
-# AutoDistributePoints: set if arena points should be distributed automatically, or by GM command
-#             Default: 0 (disable) (recommended): use gm command or sql query to distribute the points
-#                      1 (enable): arena points are distributed automatically
-#
-# AutoDistributeInterval: how often should the distribution take place
-#                         if automatic distribution is enabled
-#                         in days
-#             Default: 7 (weekly)
-#
-###################################################################################################################
-
-Arena.MaxRatingDifference = 0
-Arena.RatingDiscardTimer = 60000
-Arena.AutoDistributePoints = 0
-Arena.AutoDistributeInterval = 7
-
-###################################################################################################################
-#
-# Battleground config
-#
-# PrematureFinishTimer: the time to end the bg if there are less than minplayersperteam on one side
-#                       in milliseconds
-#              Default: 300000
-#                       0 - disable
-#
-###################################################################################################################
-
-BattleGround.PrematureFinishTimer = 300000
-
-
-###################################################################################################################
-#
-# NETWORK CONFIG
-#
-#    Network.Threads
-#         Number of threads for network, recommend 1 thread per 1000 connections.
-#         Default: 1
-#
-#    Network.OutKBuff
-#         The size of the output kernel buffer used ( SO_SNDBUF socket option, tcp manual ).
-#         Default: -1 (Use system default setting)
-#
-#    Network.OutUBuff
-#         Userspace buffer for output. This is amount of memory reserved per each connection.
-#         Default: 65536
-#
-#    Network.TcpNoDelay:
-#         TCP Nagle algorithm setting
-#         Default: 0 (enable Nagle algorithm, less traffic, more latency)
-#                  1 (TCP_NO_DELAY, disable Nagle algorithm, more traffic but less latency)
-#
-###################################################################################################################
-
-Network.Threads = 1
-Network.OutKBuff = -1
-Network.OutUBuff = 65536
-Network.TcpNodelay = 1
-
-###################################################################################################################
-# AUCTION HOUSE BOT SETTINGS
-# 
-#    AuctionHouseBot.EnableSeller
-#        Enable/Disable the part of AHBot that puts items up for auction
-#    Default 0 (disabled)
-#
-#    AuctionHouseBot.EnableBuyer
-#        Enable/Disable the part of AHBot that buys items from players
-#    Default 0 (disabled)
-#
-#    Auction House Bot character data
-#        AuctionHouseBot.Account is the account number (in realmd->account table) of the player you want to run as the auction bot.
-#         AuctionHouseBot.GUID is the GUID (in characters->characters table) of the player you want to run as the auction bot. 
-#    Default: 0 (Auction House Bot disabled)
-#
-#    AuctionHouseBot.VendorItems
-#        Include items that can be bought from vendors.
-#    Default 0
-#
-#    AuctionHouseBot.LootItems
-#        Include items that can be looted or fished for.
-#    Default 1
-#
-#    AuctionHouseBot.OtherItems
-#        Include misc. items.
-#    Default 0
-#
-#    AuctionHouseBot.Bonding_types
-#        Indicates which bonding types to allow seller to put up for auction
-#            No_Bind
-#             Default 1
-#            Bind_When_Picked_Up
-#             Default 0
-#            Bind_When_Equipped
-#             Default 1
-#            Bind_When_Use
-#             Default 1
-#            Bind_Quest_Item
-#             Default 0
-#              
-#    AuctionHouseBot.ItemsPerCycle
-#        Number of Items to Add/Remove from the AH during mass operations
-#    Default 200
-#
-#    AuctionHouseBot.UseBuyPriceForSeller
-#        Should the Seller use BuyPrice or SellPrice to determine Bid Prices
-#    Default 0 (use SellPrice)
-#
-#    AuctionHouseBot.UseBuyPriceForBuyer
-#        Should the Buyer use BuyPrice or SellPrice to determine Bid Prices
-#    Default 0 (use SellPrice)
-#
-#    All other settings have been moved to sql
-#
-###################################################################################################################
-
-AuctionHouseBot.EnableSeller = 0
-AuctionHouseBot.EnableBuyer = 0
-AuctionHouseBot.Account = 0
-AuctionHouseBot.GUID = 0
-AuctionHouseBot.VendorItems = 0
-AuctionHouseBot.LootItems = 1
-AuctionHouseBot.OtherItems = 0
-AuctionHouseBot.No_Bind = 1
-AuctionHouseBot.Bind_When_Picked_Up = 0
-AuctionHouseBot.Bind_When_Equipped = 1
-AuctionHouseBot.Bind_When_Use = 1
-AuctionHouseBot.Bind_Quest_Item = 0
-AuctionHouseBot.ItemsPerCycle = 200
-AuctionHouseBot.UseBuyPriceForSeller = 0
-AuctionHouseBot.UseBuyPriceForBuyer = 0
-
-###################################################################################################################
-# CONSOLE AND REMOTE ACCESS
-#
-#    Console.Enable
-#        Enable console
-#        Default: 1 - on
-#                 0 - off
-#
-#    Ra.Enable
-#        Enable remote console
-#        Default: 0 - off
-#                 1 - on
-#
-#    Ra.IP
-#        Default remote console ip address, use 0.0.0.0 for every address
-#
-#    Ra.Port
-#        Default remote console port
-#
-#    Ra.MinLevel
-#        Minimum level that's required to login,3 by default
-#
-#    Ra.Secure
-#        Kick client on wrong pass
-#
-###################################################################################################################
-
-Console.Enable = 1
-Ra.Enable = 0
-Ra.IP = 0.0.0.0
-Ra.Port = 3443
-Ra.MinLevel = 3
-Ra.Secure = 1
-
-###################################################################################################################
-# CUSTOM SERVER OPTIONS
-#
-#	PlayerStart.AllReputation
-#		Players will start with most of the high level reputations that are needed for items, mounts etc.
-#		If there are any reputation faction you want to be added, just tell me.
-#
-#	PlayerStart.AllSpells
-#		If enabled, players will start with all their class spells (not talents). Useful for instant 70 servers.
-#		You must import playercreateinfo_spell_custom.sql, it's included in the SQL folder.
-#		Default: 0 - off
-#				 1 - on
-#
-#	PlayerStart.MapsExplored
-#		Players will start with all maps explored if enabled
-#
-#	MusicInBattleground
-#		If enabled, "L70ETC - Power of the horde" will be played when BG starts ;)
-#
-#	HonorPointsAfterDuel
-#		The amount of honor points the duel winner will get after a duel.
-#		Default: 0 - disable
-#
-#	AlwaysMaxWeaponSkill
-#		Players will automatically gain max weapon/defense skill when logging in, leveling up etc.
-#
-#	PvPToken.Enable
-#		Enable/disable PvP Token System. Players will get a token after slaying another player that gives honor.
-#
-#	PvPToken.MapAllowType
-#		Where players can receive the pvp token
-#		4 - In all maps
-#		3 - In battlegrounds only
-#		2 - In FFA areas only (gurubashi arena etc)
-#		1 - In battlegrounds AND FFA areas only
-#
-#	PvPToken.ItemID
-#		The item players will get after killing someone if PvP Token system is enabled.
-#		Default: 29434 - Badge of justice
-#
-#	PvPToken.ItemCount
-#		Modify the item ID count - Default: 1
-#
-#	NoResetTalentsCost
-#		Enable or disable no cost when reseting talents
-#
-#   ForbiddenMaps
-#       map ids that users below SEC_GAMEMASTER cannot enter, with delimiter ','
-#       Default: ""
-#       example: "538,90"
-#       Note that it's HIGHLY DISCOURAGED to forbid starting maps (0, 1, 530)!
-#
-#   ShowKickInWorld
-#        determines wether a message is broadcasted to the entire server when a player gets kicked
-#        Default: 0
-#        1 = Enable
-#        0 = Disable
-#
-#   RecordUpdateTimeDiffInterval
-#        record update time diff to the log file
-#        update diff can be used as a criterion of performance
-#        diff < 300: good performance
-#        diff > 600: bad performance, may be caused by high cpu usage
-#        Default: 60000 (diff is written into log every 60000 ms or 1 minute.
-#        >0 = Interval
-#        0 = Disable
-#
-#   MinRecordUpdateTimeDiff
-#        only record update time diff which is greater than this value
-#
-#   PlayerStart.String
-#       If set to anything else than "", this string will be displayed to players when they login
-#       to a newly created character.
-#       Default: "" - send no text
-#
-###################################################################################################################
-
-PlayerStart.AllReputation = 0
-PlayerStart.AllSpells = 0
-PlayerStart.MapsExplored = 0
-MusicInBattleground = 0
-HonorPointsAfterDuel = 0
-AlwaysMaxWeaponSkill = 0
-PvPToken.Enable = 0
-PvPToken.MapAllowType = 4
-PvPToken.ItemID = 29434
-PvPToken.ItemCount = 1
-NoResetTalentsCost = 0
-ShowKickInWorld = 0
-RecordUpdateTimeDiffInterval = 60000
-MinRecordUpdateTimeDiff = 10
-PlayerStart.String = ""
+##########################################
+# Trinity Core worldd configuration file #
+##########################################
+ConfVersion=2009010301
+
+###################################################################################################################
+# CONNECTIONS AND DIRECTORIES
+#
+#    RealmID
+#        RealmID must match the realmlist inside the realmd database
+#
+#    DataDir
+#        Data directory setting.
+#        Important: DataDir needs to be quoted, as it is a string which may contain space characters.
+#        Example: "@prefix@/share/trinitycore"
+#
+#    LogsDir
+#        Logs directory setting.
+#        Important: Logs dir must exists, or all logs need to be disabled
+#        Default: "" - no log directory prefix, if used log names isn't absolute path
+#        then logs will be stored in current directory for run program.
+#
+#
+#    LoginDatabaseInfo
+#    WorldDatabaseInfo
+#    CharacterDatabaseInfo
+#        Database connection settings for the world server.
+#        Default: hostname;port;username;password;database
+#                 .;somenumber;username;password;database - use named pipes at Windows
+#                    Named pipes: mySQL required adding "enable-named-pipe" to [mysqld] section my.ini
+#                .;/path/to/unix_socket;username;password;database - use Unix sockets at Unix/Linux
+#                    Unix sockets: experimental, not tested
+#
+#    MaxPingTime
+#        Settings for maximum database-ping interval (minutes between pings)
+#
+#    WorldServerPort
+#        Default WorldServerPort
+#
+#    BindIP
+#        Bind World Server to IP/hostname
+#
+###################################################################################################################
+
+RealmID = 1
+DataDir = "."
+LogsDir = ""
+LoginDatabaseInfo     = "127.0.0.1;3306;trinity;trinity;realmd"
+WorldDatabaseInfo     = "127.0.0.1;3306;trinity;trinity;world"
+CharacterDatabaseInfo = "127.0.0.1;3306;trinity;trinity;characters"
+MaxPingTime = 30
+WorldServerPort = 8085
+BindIP = "0.0.0.0"
+
+###################################################################################################################
+# SCRIPTING SETTINGS
+#
+# Locale
+#     Setting for current (DBC) locale to use
+#
+# EventAI Error reporting
+# 0 - Only startup (Default)
+# 1 - Startup errors and Runtime event errors
+# 2 - Startup errors, Runtime event errors, and Creation errors
+###################################################################################################################
+
+Locale = 0
+EAIErrorLevel = 2
+
+###################################################################################################################
+# PERFORMANCE SETINGS
+#
+#    UseProcessors
+#        Used processors mask for multi-processors system (Used only at Windows)
+#        Default: 0 (selected by OS)
+#                 number (bitmask value of selected processors)
+#
+#    ProcessPriority
+#        Process priority setting (Used only at Windows)
+#        Default: 1 (HIGH)
+#                 0 (Normal)
+#
+#    Compression
+#        Compression level for update packages sent to client (1..9)
+#        Default: 1 (speed)
+#                 9 (best compression)
+#
+#    PlayerLimit
+#        Maximum number of players in the world. Excluding Mods, GM's and Admins
+#        Default: 100
+#                 0 (for infinite players)
+#                -1 (for Mods, GM's and Admins only)
+#                -2 (for GM's and Admins only)
+#                -3 (for Admins only)
+#
+#    SaveRespawnTimeImmediately
+#        Save respawn time for creatures at death and for gameobjects at use/open
+#        Default: 1 (save creature/gameobject respawn time without waiting grid unload)
+#                 0 (save creature/gameobject respawn time at grid unload)
+#
+#    MaxOverspeedPings
+#        Maximum overspeed ping count before player kick (minimum is 2, 0 used for disable check)
+#        Default: 2
+#
+#    GridUnload
+#        Unload grids (if you have lot memory you can disable it to speed up player move to new grids second time)
+#        Default: 1 (unload grids)
+#                 0 (do not unload grids)
+#
+#    SocketSelectTime
+#        Socket select time (in milliseconds)
+#        Default: 10000
+#
+#    GridCleanUpDelay
+#        Grid clean up delay (in milliseconds)
+#        Default: 300000 (5 min)
+#
+#    MapUpdateInterval
+#        Map update interval (in milliseconds)
+#        Default: 100
+#
+#    ChangeWeatherInterval
+#        Weather update interval (in milliseconds)
+#        Default: 600000 (10 min)
+#
+#    PlayerSaveInterval
+#        Player save interval (in milliseconds)
+#        Default: 900000 (15 min)
+#
+#    DisconnectToleranceInterval
+#        Tolerance for disconnected players before putting in the queue. (in seconds)
+#        Default: 0 (disabled)
+#
+#    vmap.enableLOS
+#    vmap.enableHeight
+#        Enable/Disable VMmap support for line of sight and height calculation
+#        Default: 1 (true)
+#                 0 (false)
+#
+#    vmap.ignoreMapIds
+#        Map id that will be ignored by VMaps
+#        List of ids with delimiter ','
+#        If more then one id is defined and spaces are included, the string has to be enclosed by "
+#        Example: "369,0,1,530"
+#
+#    vmap.ignoreSpellIds
+#        These spells are ignored for LoS calculation
+#        List of ids with delimiter ','
+#
+#    DetectPosCollision
+#        Check final move position, summon position, etc for visible collision with other objects or
+#        wall (wall only if vmaps are enabled)
+#        Default: 1 (enable, required more CPU power usage)
+#                 0 (disable, less nice position selection but will less CPU power usage)
+#
+#    TargetPosRecalculateRange
+#        Max distance from movement target point (+moving unit size) and targeted object (+size)
+#        after that new target movmeent point calculated. Max: melee attack range (5), min: contact range (0.5)
+#        More distance let have better performence, less distance let have more sensitive reaction at target move.
+#        Default: 1.5
+#
+#    UpdateUptimeInterval
+#        Update realm uptime period in minutes (for save data in 'uptime' table). Must be > 0
+#        Default: 10 (minutes)
+#
+#    MaxCoreStuckTime
+#        Periodically check if the process got freezed, if this is the case force crash after the specified
+#        amount of seconds. Must be > 0. Recommended > 10 secs if you use this.
+#        Default: 0 (Disabled)
+#
+#    AddonChannel
+#        Permit/disable the use of the addon channel through the server
+#        (some client side addons can stop work correctly with disabled addon channel)
+#        Default: 1 (permit addon channel)
+#                 0 (do not permit addon channel)
+#
+###################################################################################################################
+
+UseProcessors = 0
+ProcessPriority = 1
+Compression = 1
+PlayerLimit = 100
+SaveRespawnTimeImmediately = 1
+MaxOverspeedPings = 2
+GridUnload = 1
+SocketSelectTime = 10000
+GridCleanUpDelay = 300000
+MapUpdateInterval = 100
+ChangeWeatherInterval = 600000
+PlayerSaveInterval = 900000
+DisconnectToleranceInterval = 0
+vmap.enableLOS = 0
+vmap.enableHeight = 0
+vmap.ignoreMapIds = "369"
+vmap.ignoreSpellIds = "7720"
+DetectPosCollision = 1
+TargetPosRecalculateRange = 1.5
+UpdateUptimeInterval = 10
+MaxCoreStuckTime = 0
+AddonChannel = 1
+
+###################################################################################################################
+# SERVER LOGGING
+#
+#    LogSQL
+#        Enable logging of GM commands - all SQL code will be written to a log file
+#        All commands are written to a file: YYYY-MM-DD_logSQL.sql
+#        If a new day starts (00:00:00) then a new file is created - the old file will not be deleted.
+#        Default: 1 - Write SQL code to logfile
+#                 0 - Do not log
+#
+#    PidFile
+#        World daemon PID file
+#        Default: ""             - do not create PID file
+#                 "./worldd.pid" - create PID file (recommended name)
+#
+#    LogLevel
+#        Server console level of logging
+#        0 = Minimum; 1 = Basic&Error; 2 = Detail; 3 = Full/Debug
+#        Default: 3
+#
+#    LogTime
+#        Include time in server console output [hh:mm:ss]
+#        Default: 0 (no time)
+#                 1 (print time)
+#
+#    LogFile
+#        Logfile name
+#        Default: "Server.log"
+#                 "" - Empty name disable creating log file
+#
+#    LogTimestamp
+#        Logfile with timestamp of server start in name
+#        Default: 0 - no timestamp in name
+#                 1 - add timestamp in name in form Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
+#
+#    LogFileLevel
+#        Server file level of logging
+#        0 = Minimum; 1 = Error; 2 = Detail; 3 = Full/Debug
+#        Default: 0
+#
+#    LogFilter_TransportMoves
+#    LogFilter_CreatureMoves
+#    LogFilter_VisibilityChanges
+#        Log filters
+#        Default: 1 - not include with any log level
+#                 0 - include in log if log level permit
+#
+#    WorldLogFile
+#        Packet logging file for the worldserver
+#        Default: "world.log"
+#
+#    DBErrorLogFile
+#        Log file of DB errors detected at server run
+#        Default: "DBErrors.log"
+#
+#    CharLogFile
+#        Character operations logfile name
+#        Default: "Char.log"
+#                 "" - Empty name disable creating log file
+#
+#    CharLogTimestamp
+#        Logfile with timestamp of server start in name
+#        Default: 0 - no timestamp in name
+#                 1 - add timestamp in name in form Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
+#
+#    CharLogDump
+#        Write character dump before deleting in Char.log
+#        For restoration, cut character data from log starting from
+#        line == START DUMP == to line == END DUMP == (without its) in file and load it using loadpdump command
+#        Default: 0 - don't include dumping chars to log
+#                 1 - include dumping chars to log
+#
+#    GmLogFile
+#        Log file of gm commands
+#        Default: "gm_commands.log"
+#                 "" - Empty name for disable
+#
+#    GmLogTimestamp
+#        GM Logfile with timestamp of server start in name
+#        Default: 0 - no timestamp in name
+#                 1 - add timestamp in name in form Logname_YYYY-MM-DD_HH-MM-SS.Ext for Logname.Ext
+#
+#    GmLogPerAccount
+#        GM Logfiles with GM account id (Note: logs not created if GmLogFile not set)
+#        Default: 0 - add gm log data to single log file
+#                 1 - add gm log data to account specific log files with name
+#                     in form Logname_#ID_YYYY-MM-DD_HH-MM-SS.Ext
+#                     or form Logname_#ID.Ext
+#
+#    RaLogFile
+#        Log file of RA commands
+#        Default: "Ra.log"
+#                 "" - Empty name for disable
+#
+#    LogColors
+#        Color for messages (format "normal_color details_color debug_color error_color")
+#        Colors: 0 - BLACK, 1 - RED, 2 - GREEN,  3 - BROWN, 4 - BLUE, 5 - MAGENTA, 6 -  CYAN, 7 - GREY,
+#                8 - YELLOW, 9 - LRED, 10 - LGREEN, 11 - LBLUE, 12 - LMAGENTA, 13 - LCYAN, 14 - WHITE
+#        Default: "" - none colors
+#        Example: "13 7 11 9"
+#
+###################################################################################################################
+
+LogSQL = 1
+PidFile = ""
+LogLevel = 1
+LogTime = 0
+LogFile = "Server.log"
+LogTimestamp = 0
+LogFileLevel = 0
+LogFilter_TransportMoves = 1
+LogFilter_CreatureMoves = 1
+LogFilter_VisibilityChanges = 1
+WorldLogFile = ""
+DBErrorLogFile = "db_errors.log"
+CharLogFile = "characters.log"
+CharLogTimestamp = 0
+CharLogDump = 0
+GmLogFile = "gm_commands.log"
+GmLogTimestamp = 0
+GmLogPerAccount = 0
+RaLogFile = "ra_commands.log"
+LogColors = ""
+
+###################################################################################################################
+# SERVER SETTINGS
+#
+#    GameType
+#        Server realm style
+#        0 = NORMAL;1 = PVP; 4 = NORMAL; 6 = RP; 8 = RPPVP
+#        also custom type: 16 FFA_PVP (free for all pvp mode like arena PvP in all zones except rest
+#        activated places and sanctuaries)
+#
+#    RealmZone
+#        Server realm zone (set allowed alphabet in character names/etc). See also Strict*Names options.
+#
+#    1 Development    - any language (Default)
+#    2 United States  - extended-Latin
+#    3 Oceanic        - extended-Latin
+#    4 Latin America  - extended-Latin
+#    5 Tournament     - basic-Latin at create, any at login
+#    6 Korea          - East-Asian
+#    7 Tournament     - basic-Latin at create, any at login
+#    8 English        - extended-Latin
+#    9 German         - extended-Latin
+#    10 French        - extended-Latin
+#    11 Spanish       - extended-Latin
+#    12 Russian       - Cyrillic
+#    13 Tournament    - basic-Latin at create, any at login
+#    14 Taiwan        - East-Asian
+#    15 Tournament    - basic-Latin at create, any at login
+#    16 China         - East-Asian
+#    17 CN1           - basic-Latin at create, any at login
+#    18 CN2           - basic-Latin at create, any at login
+#    19 CN3           - basic-Latin at create, any at login
+#    20 CN4           - basic-Latin at create, any at login
+#    21 CN5           - basic-Latin at create, any at login
+#    22 CN6           - basic-Latin at create, any at login
+#    23 CN7           - basic-Latin at create, any at login
+#    24 CN8           - basic-Latin at create, any at login
+#    25 Tournament    - basic-Latin at create, any at login
+#    26 Test Server   - any language
+#    27 Tournament    - basic-Latin at create, any at login
+#    28 QA Server     - any language
+#    29 CN9           - basic-Latin at create, any at login
+#
+#    Expansion
+#        Allow server use content from expansion
+#                 2 - check expansion 2 maps existence, and if client support expansion 2 and account have
+#                     expansion 2 setting then allow visit expansion 2 maps, allow create new class character)
+#        Default: 1 - check expansion 1 maps existence, and if client support expansion 1 and account have
+#                     expansion 1 setting then allow visit expansion 1 maps, allow create new races character)
+#                 0 - not check expansion maps existence, not allow wisit its, not allow create new race or new class
+#                     characters, ignore account expansion setting)
+#
+#    DBC.Locale
+#        DBC Language Settings
+#        0 = English; 1 = Korean; 2 = French; 3 = German; 4 = Chinese; 5 = Taiwanese; 6 = Spanish; 7 = Spanish Mexico
+#        8 = Russian; 255 = Auto Detect (Default)
+#
+#    DeclinedNames
+#    Allow russian clients to set and use declined names
+#    Default: 0 - do not use declined names, except when the Russian RealmZone is set
+#         1 - use declined names
+#
+#    StrictPlayerNames
+#        Limit player name to language specific symbols set, not allow create characters, and set rename request and disconnect at not allowed symbols name
+#        Default: 0 disable (but limited server timezone dependent client check)
+#                 1 basic latin characters  (strict)
+#                 2 realm zone specific (strict). See RealmZone setting.
+#                   Note: In any case if you want correctly see character name at client this client must have apporopriate fonts
+#                   (included in client by default, with active official localization or custom localization fonts in clientdir/Fonts).
+#                 3 basic latin characters + server timezone specific
+#
+#    StrictCharterNames
+#        Limit guild charter names to language specific symbols set, not allow create charters with allowed symbols in name
+#        Default: 0 disable
+#                 1 basic latin characters  (strict)
+#                 2 realm zone specific (strict). See RealmZone setting.
+#                   Note: In any case if you want correctly see character name at client this client must have apporopriate fonts
+#                   (included in client by default, with active official localization or custom localization fonts in clientdir/Fonts).
+#                 3 basic latin characters + server timezone specific
+#
+#    StrictPetNames
+#        Limit pet names to language specific symbols set
+#        Default: 0 disable
+#                 1 basic latin characters  (strict)
+#                 2 realm zone specific (strict). See RealmZone setting.
+#                   Note: In any case if you want correctly see character name at client this client must have apporopriate fonts
+#                   (included in client by default, with active official localization or custom localization fonts in clientdir/Fonts).
+#                 3 basic latin characters + server timezone specific
+#
+#    CharactersCreatingDisabled
+#        Disable characters creating for specific team or any (non-player accounts not affected)
+#        Default: 0 - enabled
+#                 1 - disabled only for Alliance
+#                 2 - disabled only for Horde
+#                 3 - disabled for both teams
+#
+#    MaxWhoListReturns
+#        Set the maximum number of players returned in the /who list and interface.
+#        Default: 49 (stable)
+#
+#    CharactersPerAccount
+#        Limit numbers of characters per account (at all realms).
+#        Note: this setting limit character creating at _current_ realm base at characters amount at all realms
+#        Default: 50
+#                The number must be >= CharactersPerRealm
+#
+#    CharactersPerRealm
+#        Limit numbers of characters for account at realm
+#        Default: 10 (client limitation)
+#                The number must be between 1 and 10
+#
+#    SkipCinematics
+#        Disable in-game script movie at first character's login(allows to prevent buggy intro in case of custom start location coordinates)
+#        Default: 0 - show intro for each new characrer
+#                 1 - show intro only for first character of selected race
+#                 2 - disable intro show in all cases
+#
+#    MaxPlayerLevel
+#        Max level that can be reached by player for experience (in range from 1 to 255).
+#        Change not recommended
+#        Default: 70
+#
+#    StartPlayerLevel
+#        Staring level that have character at creating (in range 1 to MaxPlayerLevel)
+#        Default: 1
+#
+#    StartPlayerMoney
+#        Amount of money that new players will start with.
+#        If you want to start with silver, use for example 100 (100 copper = 1 silver)
+#        Default: 0
+#
+#    MaxHonorPoints
+#        Max honor points that player can have.
+#        Default: 75000
+#
+#    StartHonorPoints
+#        Amount of honor that new players will start with
+#        Default: 0
+#
+#    InstantLogout
+#        Enable or disable instant logout for security level (0..4) or high (NOT in combat/while dueling/while falling)
+#        Default: 1 (Mods/GMs/Admins)
+#
+#    DisableWaterBreath
+#        Disable/enable waterbreathing for security level (0..4) or high
+#        Default: 4 (None)
+#
+#    AllFlightPaths
+#        Players will start with all flight paths (Note: ALL flight paths, not only player's team)
+#        Default: 0 (true)
+#                 1 (false)
+#
+#    AlwaysMaxSkillForLevel
+#        Players will automatically gain max level dependent (weapon/defense) skill when logging in, leveling up etc.
+#        Default: 0 (true)
+#                 1 (false)
+#
+#    ActivateWeather
+#        Activate weather system
+#        Default: 1 (true)
+#                 0 (false)
+#
+#    Battleground.CastDeserter
+#        Cast or not Deserter spell at player who leave battleground in progress
+#        Default: 1 (true)
+#                 0 (false)
+#
+#    Battleground.QueueAnnouncer.Enable
+#        Enable queue announcer posting to chat
+#        Default: 1 (true)
+#                 0 (false)
+#
+#    Battleground.QueueAnnouncer.PlayerOnly
+#        Enable queue announcer posting to chat
+#        Default: 0 (false)
+#                 1 (true)
+#
+#   Battleground.PrematureReward
+#	 Reward players in case of prematurely finished BG
+#	 Default: 1 (true)
+#	 	  0 (false)
+#
+#    CastUnstuck
+#        Allow cast or not Unstuck spell at .start or client Help option use
+#        Default: 1 (true)
+#                 0 (false)
+#
+#    Instance.IgnoreLevel
+#        Ignore level requirement to enter instance
+#        Default: 0 (false)
+#                 1 (true)
+#
+#    Instance.IgnoreRaid
+#        Ignore raid requirement to enter instance
+#        Default: 0 (false)
+#                 1 (true)
+#
+#    Instance.ResetTimeHour
+#        The hour of the day (0-23) when the global instance resets occur.
+#        Default: 4
+#
+#    Instance.UnloadDelay
+#        Unload the instance map from memory after some time if no players are inside.
+#        Default: 1800000 (miliseconds, i.e 30 minutes)
+#                 0 (instance maps are kept in memory until they are reset)
+#
+#    Quests.LowLevelHideDiff
+#        Quest level difference to hide for player low level quests:
+#        if player_level > quest_level + LowLevelQuestsHideDiff then quest "!" mark not show for quest giver
+#        Default: 4
+#                -1 (show all available quests marks)
+#
+#    Quests.HighLevelHideDiff
+#        Quest level difference to hide for player high level quests:
+#        if player_level < quest_min_level - HighLevelQuestsHideDiff then quest "!" mark not show for quest giver
+#        Default: 7
+#                -1 (show all available quests marks)
+#
+#    MaxPrimaryTradeSkill
+#        Max count that player can learn the primary trade skill.
+#        Default: 2
+#        Max : 10
+#
+#    MinPetitionSigns
+#        Min signatures count to creating guild (0..9).
+#        Default: 9
+#
+#    MaxGroupXPDistance
+#        Max distance to creature for group memeber to get XP at creature death.
+#        Default: 74
+#
+#    MailDeliveryDelay
+#        Mail delivery delay time for item sending
+#        Default: 3600 sec (1 hour)
+#
+#    SkillChance.Prospecting
+#        For prospecting skillup not possible by default, but can be allowed as custom setting
+#        Default: 0 - no skilups
+#                 1 - skilups possible
+#
+#    Event.Announce
+#        Default: 0 (false)
+#                 1 (true)
+#
+#    BeepAtStart
+#        Beep at core start finished (mostly work only at Unix/Linux systems)
+#        Default: 1 (true)
+#                 0 (false)
+#
+#    Motd
+#        Message of the Day. Displayed at worldlogin for every user ('@' for a newline).
+#
+#    Server.LoginInfo
+#        Enable/disable sending server info (core version) on login.
+#        Default: 0 - disable
+#                 1 - enable
+#
+###################################################################################################################
+
+GameType = 1
+RealmZone = 1
+Expansion = 0
+DBC.Locale = 255
+DeclinedNames = 0
+StrictPlayerNames = 0
+StrictCharterNames = 0
+StrictPetNames = 0
+MaxWhoListReturns = 49
+CharactersCreatingDisabled = 0
+CharactersPerAccount = 50
+CharactersPerRealm = 10
+SkipCinematics = 0
+MaxPlayerLevel = 60
+StartPlayerLevel = 1
+StartPlayerMoney = 0
+MaxHonorPoints = 75000
+StartHonorPoints = 0
+InstantLogout = 1
+DisableWaterBreath = 4
+AllFlightPaths = 0
+AlwaysMaxSkillForLevel = 0
+ActivateWeather = 1
+Battleground.CastDeserter = 1
+Battleground.QueueAnnouncer.Enable = 1
+Battleground.QueueAnnouncer.PlayerOnly = 0
+Battleground.PrematureReward = 1
+CastUnstuck = 1
+Instance.IgnoreLevel = 0
+Instance.IgnoreRaid = 0
+Instance.ResetTimeHour = 4
+Instance.UnloadDelay = 1800000
+Quests.LowLevelHideDiff = 4
+Quests.HighLevelHideDiff = 7
+MaxPrimaryTradeSkill = 2
+MinPetitionSigns = 9
+MaxGroupXPDistance = 74
+MailDeliveryDelay = 3600
+SkillChance.Prospecting = 0
+Event.Announce = 0
+BeepAtStart = 1
+Motd = "Welcome to a Trinity Core server."
+Server.LoginInfo = 0
+
+###################################################################################################################
+# PLAYER INTERACTION
+#
+#    AllowTwoSide.Accounts
+#        Allow or not accounts to create characters in the 2 teams in any game type.
+#        Default: 0 (Not allowed)
+#                 1 (Allowed)
+#
+#    AllowTwoSide.Interaction.Chat
+#    AllowTwoSide.Interaction.Channel
+#    AllowTwoSide.Interaction.Group
+#    AllowTwoSide.Interaction.Guild
+#    AllowTwoSide.Interaction.Auction
+#    AllowTwoSide.Interaction.Mail
+#        Allow or not common :chat(say,yell);channel(chat)group(join)guild(join);merge all auction houses for players from
+#        different teams, send mail to different team.
+#        Default: 0 (Not allowed)
+#                 1 (Allowed)
+#
+#    AllowTwoSide.WhoList
+#        Allow or not show player from both team in who list.
+#        Default: 0 (Not allowed)
+#                 1 (Allowed)
+#
+#    AllowTwoSide.AddFriend
+#        Allow or not adding friends from other team in friend list.
+#        Default: 0 (Not allowed)
+#                 1 (Allowed)
+#
+#    AllowTwoSide.Trade
+#        Allow or not trading with other team in party.
+#        Default: 0 (Not allowed)
+#                 1 (Allowed)
+#
+#    TalentsInspecting
+#        Allow other players see character talents in inspect dialog (Characters in Gamemaster mode can
+#        inspect talents always)
+#        Default: 1 (allow)
+#                 0 (not allow)
+#
+###################################################################################################################
+
+AllowTwoSide.Accounts = 0
+AllowTwoSide.Interaction.Chat = 0
+AllowTwoSide.Interaction.Channel = 0
+AllowTwoSide.Interaction.Group = 0
+AllowTwoSide.Interaction.Guild = 0
+AllowTwoSide.Interaction.Auction = 0
+AllowTwoSide.Interaction.Mail = 0
+AllowTwoSide.WhoList = 0
+AllowTwoSide.AddFriend = 0
+AllowTwoSide.Trade = 0
+TalentsInspecting = 1
+
+###################################################################################################################
+# CREATURE SETTINGS
+#
+#    ThreatRadius
+#        Radius for creature to evade after being pulled away from combat start point
+#        If ThreatRadius is less than creature aggro radius then aggro radius will be used
+#        Default: 60 yards
+#
+#    Rate.Creature.Aggro
+#        Aggro radius percent or off.
+#        Default: 1   - 100%
+#                 1.5 - 150%
+#                 0   - off (0%)
+#
+#    CreatureFamilyAssistanceRadius
+#        Creature family assistance radius
+#        Default: 10
+#                 0   - off
+#
+#    CreatureFamilyAssistanceDelay
+#        Reaction time for creature assistance call
+#        Default: 1500 (1.5s)
+#
+#    WorldBossLevelDiff
+#        Difference for boss dynamic level with target
+#        Default: 3
+#
+#    Corpse.Decay.NORMAL
+#    Corpse.Decay.RARE
+#    Corpse.Decay.ELITE
+#    Corpse.Decay.RAREELITE
+#    Corpse.Decay.WORLDBOSS
+#        Seconds until creature corpse will decay without being looted or skinned.
+#        Default: 60, 300, 300, 300, 3600
+#
+#    Rate.Corpse.Decay.Looted
+#         Controls how long the creature corpse stays after it had been looted, as a multiplier of its Corpse.Decay.* config.
+#         Default: 0.5
+#
+#    Rate.Creature.Normal.Damage
+#    Rate.Creature.Elite.Elite.Damage
+#    Rate.Creature.Elite.RAREELITE.Damage
+#    Rate.Creature.Elite.WORLDBOSS.Damage
+#    Rate.Creature.Elite.RARE.Damage
+#        Creature Damage Rates.
+#        Examples: 2 - creatures will damage 2x, 1.7 - 1.7x.
+#
+#    Rate.Creature.Normal.SpellDamage
+#    Rate.Creature.Elite.Elite.SpellDamage
+#    Rate.Creature.Elite.RAREELITE.SpellDamage
+#    Rate.Creature.Elite.WORLDBOSS.SpellDamag
+#    Rate.Creature.Elite.RARE.SpellDamage
+#        Creature Spell Damage Rates.
+#        Examples: 2 - creatures will damage with spells 2x, 1.7 - 1.7x.
+#
+#    Rate.Creature.Normal.HP
+#    Rate.Creature.Elite.Elite.HP
+#    Rate.Creature.Elite.RAREELITE.HP
+#    Rate.Creature.Elite.WORLDBOSS.HP
+#    Rate.Creature.Elite.RARE.HP
+#        Creature Health Ammount Modifier.
+#        Examples: 2 - creatures have 2x health, 1.7 - 1.7x.
+#
+#    ListenRange.Say
+#        Distance from player to listen text that creature (or other world object) say
+#        Default: 25
+#
+#    ListenRange.TextEmote
+#        Distance from player to listen textemote that creature (or other world object) say
+#        Default: 25
+#
+#    ListenRange.Yell
+#        Distance from player to listen text that creature (or other world object) yell
+#        Default: 300
+#
+###################################################################################################################
+
+ThreatRadius = 60
+Rate.Creature.Aggro = 1
+CreatureFamilyAssistanceRadius = 10
+CreatureFamilyAssistanceDelay = 1500
+WorldBossLevelDiff = 3
+Corpse.Decay.NORMAL = 60
+Corpse.Decay.RARE = 300
+Corpse.Decay.ELITE = 300
+Corpse.Decay.RAREELITE = 300
+Corpse.Decay.WORLDBOSS = 3600
+Rate.Corpse.Decay.Looted = 0.5
+Rate.Creature.Normal.Damage = 1
+Rate.Creature.Elite.Elite.Damage = 1
+Rate.Creature.Elite.RAREELITE.Damage = 1
+Rate.Creature.Elite.WORLDBOSS.Damage = 1
+Rate.Creature.Elite.RARE.Damage = 1
+Rate.Creature.Normal.SpellDamage = 1
+Rate.Creature.Elite.Elite.SpellDamage = 1
+Rate.Creature.Elite.RAREELITE.SpellDamage = 1
+Rate.Creature.Elite.WORLDBOSS.SpellDamage = 1
+Rate.Creature.Elite.RARE.SpellDamage = 1
+Rate.Creature.Normal.HP = 1
+Rate.Creature.Elite.Elite.HP = 1
+Rate.Creature.Elite.RAREELITE.HP = 1
+Rate.Creature.Elite.WORLDBOSS.HP = 1
+Rate.Creature.Elite.RARE.HP = 1
+ListenRange.Say = 40
+ListenRange.TextEmote = 40
+ListenRange.Yell = 300
+
+###################################################################################################################
+# CHAT SETTINGS
+#
+#    ChatFakeMessagePreventing
+#        Chat protection from creating fake messages using a lot spaces (other invisible symbols),
+#        not applied to addon language messages, but can prevent working old addons
+#        that use normal languages for sending data to another clients.
+#        Default: 0 (disible fake messages preventing)
+#                 1 (enabled fake messages preventing)
+#
+#    ChatFlood.MessageCount
+#        Chat anti-flood protection, haste message count to activate protection
+#        Default: 10
+#                 0 (disible anti-flood protection)
+#
+#    ChatFlood.MessageDelay
+#        Chat anti-flood protection, minimum message delay to count message
+#        Default: 1 (in secs)
+#
+#    ChatFlood.MuteTime
+#        Chat anti-flood protection, mute time at activation flood protection (not saved)
+#        Default: 10 (in secs)
+#
+#    Channel.RestrictedLfg
+#        Restrict use LookupForGroup channel only registered in LFG tool players
+#        Default: 1 (allow join to channel only if active in LFG)
+#                 0 (allow join to channel in any time)
+#
+#    Channel.SilentlyGMJoin
+#        Silently join GM characters (security level > 1) to channels
+#        Default: 0 (join announcement in normal way)
+#                 1 (GM join without announcement)
+#
+###################################################################################################################
+
+ChatFakeMessagePreventing = 0
+ChatFlood.MessageCount = 10
+ChatFlood.MessageDelay = 1
+ChatFlood.MuteTime = 10
+Channel.RestrictedLfg = 1
+Channel.SilentlyGMJoin = 0
+
+###################################################################################################################
+# GAME MASTER SETTINGS
+#
+#    GM.LoginState
+#        GM mode at login
+#        Default: 2 (last save state)
+#                 0 (disable)
+#                 1 (enable)
+#
+#    GM.Chat
+#        GM chat mode at login
+#        Default: 2 (last save state)
+#                 0 (disable)
+#                 1 (enable)
+#
+#    GM.WhisperingTo
+#        Is GM accepting whispers from player by default or not.
+#        Default: 2 (last save state)
+#                 0 (disable)
+#                 1 (enable)
+#
+#    GM.InGMList
+#        Is GM showed in GM list (if visible) in non-GM state (.gmoff)
+#        Default: 0 (false)
+#                 1 (true)
+#
+#    GM.InWhoList
+#        Is GM showed in who list (if visible).
+#        Default: 0 (false)
+#                 1 (true)
+#
+#    GM.LogTrade
+#        Include GM trade and trade slot enchanting operations in GM log if it enable
+#        Default: 1 (include)
+#                 0 (not include)
+#
+#    GM.StartLevel
+#        GM starting level (1-255)
+#        Default: 1
+#
+###################################################################################################################
+
+GM.LoginState     = 2
+GM.Chat           = 2
+GM.WhisperingTo   = 2
+GM.InGMList       = 0
+GM.InWhoList      = 0
+GM.LogTrade       = 1
+GM.StartLevel     = 60
+
+###################################################################################################################
+# VISIBILITY AND RADIUSES
+#
+#    Visibility.GroupMode
+#        Group visibility modes
+#        Default: 0 (standard setting: only members from same group can 100% auto detect invisible player)
+#                 1 (raid members 100% auto detect invisible player from same raid)
+#                 2 (players from same team can 100% auto detect invisible player)
+#
+#    Visibility.Distance.Creature
+#    Visibility.Distance.Player
+#        Visibility distance for different in game object
+#        Max limited by active player zone: ~ 333
+#        Min limit dependent from objects
+#        Default: 132 (cell size)
+#        Min limit is max aggro radius (45) * Rate.Creature.Aggro
+#
+#    Visibility.Distance.Object
+#        Visible distance for gameobject, dynobject, bodies, corpses, bones
+#        Min limit is iteraction distance (5)
+#
+#    Visibility.Distance.InFlight
+#        Visible distance for player in flight
+#        Min limit is 0 (not show any objects)
+#
+#    Visibility.Distance.Grey.Unit
+#        Visibility grey distance for creatures/players (fast changing objects)
+#        addition to appropriate object type Visibility.Distance.* use in case visibility removing to
+#        object (except corpse around distences) If D is distance and G is grey distance then object
+#        make visible if distance to it <= D but make non visible if distance > D+G
+#        Default: 1 (yard)
+#
+#    Visibility.Distance.Grey.Object
+#        Visibility grey distance for dynobjects/gameobjects/corpses/creature bodies
+#        Default: 10 (yards)
+#
+#
+###################################################################################################################
+
+Visibility.GroupMode = 0
+Visibility.Distance.Creature      = 132
+Visibility.Distance.Player        = 132
+Visibility.Distance.Object        = 132
+Visibility.Distance.InFlight      = 132
+Visibility.Distance.Grey.Unit   = 1
+Visibility.Distance.Grey.Object = 10
+
+###################################################################################################################
+# SERVER RATES
+#
+#    Rate.Health
+#    Rate.Mana
+#    Rate.Rage.Income
+#    Rate.Rage.Loss
+#    Rate.Focus
+#    Rate.Loyalty
+#        Health and power regeneration and rage income from damage.
+#        Default: 1
+#
+#    Rate.Skill.Discovery
+#         Skill Discovery Rates
+#         Default: 1
+#
+#    Rate.Drop.Item.Poor
+#    Rate.Drop.Item.Normal
+#    Rate.Drop.Item.Uncommon
+#    Rate.Drop.Item.Rare
+#    Rate.Drop.Item.Epic
+#    Rate.Drop.Item.Legendary
+#    Rate.Drop.Item.Artifact
+#    Rate.Drop.Item.Referenced
+#    Rate.Drop.Money
+#         Drop rates (items by quality and money)
+#         Default: 1
+#
+#    Rate.Drop.Money
+#         Drop rates
+#         Default: 1
+#
+#    Rate.XP.Kill
+#    Rate.XP.Quest
+#    Rate.XP.Explore
+#        XP rates
+#        Default: 1
+#
+#    Rate.XP.PastLevel70
+#        XP needed per level past 70 (Rates below 1 not recommended)
+#        Default: 1
+#
+#    Rate.Rest.InGame
+#    Rate.Rest.Offline.InTavernOrCity
+#    Rate.Rest.Offline.InWilderness
+#        Resting points grow rates (1 - normal, 2 - double rate, 0.5 - half rate, etc) from standard values
+#
+#    Rate.Damage.Fall
+#        Damage after fall rate. (1 - standard, 2 - double damage, 0.5 - half damage, etc)
+#
+#    Rate.Auction.Time
+#    Rate.Auction.Deposit
+#    Rate.Auction.Cut
+#        Auction rates (auction time, deposit get at auction start, auction cut from price at auction end)
+#
+#    Rate.Honor
+#        Honor gain rate
+#
+#    Rate.Mining.Amount
+#    Rate.Mining.Next
+#        Mining Rates (Mining.Amount changes minimum/maximum usetimes of a deposit,
+#        Mining.Next changes chance to have next use of a deposit)
+#
+#    Rate.Talent
+#        Talent Point rates
+#        Default: 1
+#
+#    Rate.Reputation.Gain
+#         Reputation Gain rate
+#         Default: 1
+#
+#    Rate.InstanceResetTime
+#        Multiplier for the number of days in between global raid/heroic instance resets.
+#        Default: 1
+#
+#    SkillGain.Crafting
+#    SkillGain.Defense
+#    SkillGain.Gathering
+#    SkillGain.Weapon
+#         crafting/defense/gathering/weapon skills gain at skill grow (1,2,...)
+#         Default: 1
+#
+#    SkillChance.Orange
+#    SkillChance.Yellow
+#    SkillChance.Green
+#    SkillChance.Grey
+#        Skill chance values (0..100)
+#        Default: 100-75-25-0
+#
+#    SkillChance.MiningSteps
+#    SkillChance.SkinningSteps
+#         For skinning and Mining chance decrease with skill level.
+#         Default: 0  - no decrease
+#                  75 - in 2 times each 75 skill points
+#
+#    DurabilityLossChance.Damage
+#         Chance lost one from equiped items durability point at damage apply or receive.
+#         Default: 0.5 (100/0.5 = 200) Each 200 damage apply one from 19 possible equipped items
+#
+#    DurabilityLossChance.Absorb
+#         Chance lost one from armor items durability point at damage absorb.
+#         Default: 0.5 (100/0.5 = 200) Each 200 absorbs apply one from 15 possible armor equipped items
+#
+#    DurabilityLossChance.Parry
+#         Chance lost weapon durability point at parry.
+#         Default: 0.05 (100/0.05 = 2000) Each 2000 parry attacks main weapon lost point
+#
+#    DurabilityLossChance.Block
+#         Chance lost sheild durability point at damage block.
+#         Default: 0.05 (100/0.05 = 2000) Each 2000 partly or full blocked attacks shield lost point
+#
+#    Death.SicknessLevel
+#         Starting Character start gain sickness at spirit resurrection (1 min)
+#         Default: 11
+#                  -10 - character will have full time (10min) sickness at 1 level
+#                  maxplayerlevel+1 - chaarcter will not have sickess at any level
+#
+#    Death.CorpseReclaimDelay.PvP
+#    Death.CorpseReclaimDelay.PvE
+#         Enabled/disabled increase corpse reclaim delay at often PvP/PvE deaths
+#         Default: 1 (enabled)
+#                  0 (disabled)
+#
+###################################################################################################################
+
+Rate.Health = 1
+Rate.Mana = 1
+Rate.Rage.Income = 1
+Rate.Rage.Loss = 1
+Rate.Focus = 1
+Rate.Loyalty = 1
+Rate.Skill.Discovery = 1
+Rate.Drop.Item.Poor = 1
+Rate.Drop.Item.Normal = 1
+Rate.Drop.Item.Uncommon = 1
+Rate.Drop.Item.Rare = 1
+Rate.Drop.Item.Epic = 1
+Rate.Drop.Item.Legendary = 1
+Rate.Drop.Item.Artifact = 1
+Rate.Drop.Item.Referenced = 1
+Rate.Drop.Money = 1
+Rate.XP.Kill    = 1
+Rate.XP.Quest   = 1
+Rate.XP.Explore = 1
+Rate.XP.PastLevel70 = 1
+Rate.Rest.InGame = 1
+Rate.Rest.Offline.InTavernOrCity = 1
+Rate.Rest.Offline.InWilderness = 1
+Rate.Damage.Fall = 1
+Rate.Auction.Time = 1
+Rate.Auction.Deposit = 1
+Rate.Auction.Cut = 1
+Rate.Honor = 1
+Rate.Mining.Amount = 1
+Rate.Mining.Next   = 1
+Rate.Talent = 1
+Rate.Reputation.Gain = 1
+Rate.InstanceResetTime = 1
+SkillGain.Crafting = 1
+SkillGain.Defense = 1
+SkillGain.Gathering = 1
+SkillGain.Weapon = 1
+SkillChance.Orange = 100
+SkillChance.Yellow = 75
+SkillChance.Green  = 25
+SkillChance.Grey   = 0
+SkillChance.MiningSteps   = 0
+SkillChance.SkinningSteps = 0
+DurabilityLossChance.Damage = 0.5
+DurabilityLossChance.Absorb = 0.5
+DurabilityLossChance.Parry  = 0.05
+DurabilityLossChance.Block  = 0.05
+Death.SicknessLevel = 11
+Death.CorpseReclaimDelay.PvP = 1
+Death.CorpseReclaimDelay.PvE = 0
+
+###################################################################################################################
+#
+# Battleground config
+#
+# PrematureFinishTimer: the time to end the bg if there are less than minplayersperteam on one side
+#                       in milliseconds
+#              Default: 300000
+#                       0 - disable
+#
+###################################################################################################################
+
+BattleGround.PrematureFinishTimer = 300000
+
+
+###################################################################################################################
+#
+# NETWORK CONFIG
+#
+#    Network.Threads
+#         Number of threads for network, recommend 1 thread per 1000 connections.
+#         Default: 1
+#
+#    Network.OutKBuff
+#         The size of the output kernel buffer used ( SO_SNDBUF socket option, tcp manual ).
+#         Default: -1 (Use system default setting)
+#
+#    Network.OutUBuff
+#         Userspace buffer for output. This is amount of memory reserved per each connection.
+#         Default: 65536
+#
+#    Network.TcpNoDelay:
+#         TCP Nagle algorithm setting
+#         Default: 0 (enable Nagle algorithm, less traffic, more latency)
+#                  1 (TCP_NO_DELAY, disable Nagle algorithm, more traffic but less latency)
+#
+###################################################################################################################
+
+Network.Threads = 1
+Network.OutKBuff = -1
+Network.OutUBuff = 65536
+Network.TcpNodelay = 1
+
+###################################################################################################################
+# AUCTION HOUSE BOT SETTINGS
+# 
+#    AuctionHouseBot.EnableSeller
+#        Enable/Disable the part of AHBot that puts items up for auction
+#    Default 0 (disabled)
+#
+#    AuctionHouseBot.EnableBuyer
+#        Enable/Disable the part of AHBot that buys items from players
+#    Default 0 (disabled)
+#
+#    Auction House Bot character data
+#        AuctionHouseBot.Account is the account number (in realmd->account table) of the player you want to run as the auction bot.
+#         AuctionHouseBot.GUID is the GUID (in characters->characters table) of the player you want to run as the auction bot. 
+#    Default: 0 (Auction House Bot disabled)
+#
+#    AuctionHouseBot.VendorItems
+#        Include items that can be bought from vendors.
+#    Default 0
+#
+#    AuctionHouseBot.LootItems
+#        Include items that can be looted or fished for.
+#    Default 1
+#
+#    AuctionHouseBot.OtherItems
+#        Include misc. items.
+#    Default 0
+#
+#    AuctionHouseBot.Bonding_types
+#        Indicates which bonding types to allow seller to put up for auction
+#            No_Bind
+#             Default 1
+#            Bind_When_Picked_Up
+#             Default 0
+#            Bind_When_Equipped
+#             Default 1
+#            Bind_When_Use
+#             Default 1
+#            Bind_Quest_Item
+#             Default 0
+#              
+#    AuctionHouseBot.ItemsPerCycle
+#        Number of Items to Add/Remove from the AH during mass operations
+#    Default 200
+#
+#    AuctionHouseBot.UseBuyPriceForSeller
+#        Should the Seller use BuyPrice or SellPrice to determine Bid Prices
+#    Default 0 (use SellPrice)
+#
+#    AuctionHouseBot.UseBuyPriceForBuyer
+#        Should the Buyer use BuyPrice or SellPrice to determine Bid Prices
+#    Default 0 (use SellPrice)
+#
+#    All other settings have been moved to sql
+#
+###################################################################################################################
+
+AuctionHouseBot.EnableSeller = 0
+AuctionHouseBot.EnableBuyer = 0
+AuctionHouseBot.Account = 0
+AuctionHouseBot.GUID = 0
+AuctionHouseBot.VendorItems = 0
+AuctionHouseBot.LootItems = 1
+AuctionHouseBot.OtherItems = 0
+AuctionHouseBot.No_Bind = 1
+AuctionHouseBot.Bind_When_Picked_Up = 0
+AuctionHouseBot.Bind_When_Equipped = 1
+AuctionHouseBot.Bind_When_Use = 1
+AuctionHouseBot.Bind_Quest_Item = 0
+AuctionHouseBot.ItemsPerCycle = 200
+AuctionHouseBot.UseBuyPriceForSeller = 0
+AuctionHouseBot.UseBuyPriceForBuyer = 0
+
+###################################################################################################################
+# CONSOLE AND REMOTE ACCESS
+#
+#    Console.Enable
+#        Enable console
+#        Default: 1 - on
+#                 0 - off
+#
+#    Ra.Enable
+#        Enable remote console
+#        Default: 0 - off
+#                 1 - on
+#
+#    Ra.IP
+#        Default remote console ip address, use 0.0.0.0 for every address
+#
+#    Ra.Port
+#        Default remote console port
+#
+#    Ra.MinLevel
+#        Minimum level that's required to login,3 by default
+#
+#    Ra.Secure
+#        Kick client on wrong pass
+#
+###################################################################################################################
+
+Console.Enable = 1
+Ra.Enable = 0
+Ra.IP = 0.0.0.0
+Ra.Port = 3443
+Ra.MinLevel = 3
+Ra.Secure = 1
+
+###################################################################################################################
+# CUSTOM SERVER OPTIONS
+#
+#	PlayerStart.AllReputation
+#		Players will start with most of the high level reputations that are needed for items, mounts etc.
+#		If there are any reputation faction you want to be added, just tell me.
+#
+#	PlayerStart.AllSpells
+#		If enabled, players will start with all their class spells (not talents). Useful for instant 70 servers.
+#		You must import playercreateinfo_spell_custom.sql, it's included in the SQL folder.
+#		Default: 0 - off
+#				 1 - on
+#
+#	PlayerStart.MapsExplored
+#		Players will start with all maps explored if enabled
+#
+#	MusicInBattleground
+#		If enabled, "L70ETC - Power of the horde" will be played when BG starts ;)
+#
+#	HonorPointsAfterDuel
+#		The amount of honor points the duel winner will get after a duel.
+#		Default: 0 - disable
+#
+#	AlwaysMaxWeaponSkill
+#		Players will automatically gain max weapon/defense skill when logging in, leveling up etc.
+#
+#	PvPToken.Enable
+#		Enable/disable PvP Token System. Players will get a token after slaying another player that gives honor.
+#
+#	PvPToken.MapAllowType
+#		Where players can receive the pvp token
+#		4 - In all maps
+#		3 - In battlegrounds only
+#		2 - In FFA areas only (gurubashi arena etc)
+#		1 - In battlegrounds AND FFA areas only
+#
+#	PvPToken.ItemID
+#		The item players will get after killing someone if PvP Token system is enabled.
+#		Default: 29434 - Badge of justice
+#
+#	PvPToken.ItemCount
+#		Modify the item ID count - Default: 1
+#
+#	NoResetTalentsCost
+#		Enable or disable no cost when reseting talents
+#
+#   ForbiddenMaps
+#       map ids that users below SEC_GAMEMASTER cannot enter, with delimiter ','
+#       Default: ""
+#       example: "538,90"
+#       Note that it's HIGHLY DISCOURAGED to forbid starting maps (0, 1, 530)!
+#
+#   ShowKickInWorld
+#        determines wether a message is broadcasted to the entire server when a player gets kicked
+#        Default: 0
+#        1 = Enable
+#        0 = Disable
+#
+#   RecordUpdateTimeDiffInterval
+#        record update time diff to the log file
+#        update diff can be used as a criterion of performance
+#        diff < 300: good performance
+#        diff > 600: bad performance, may be caused by high cpu usage
+#        Default: 60000 (diff is written into log every 60000 ms or 1 minute.
+#        >0 = Interval
+#        0 = Disable
+#
+#   MinRecordUpdateTimeDiff
+#        only record update time diff which is greater than this value
+#
+#   PlayerStart.String
+#       If set to anything else than "", this string will be displayed to players when they login
+#       to a newly created character.
+#       Default: "" - send no text
+#
+###################################################################################################################
+
+PlayerStart.AllReputation = 0
+PlayerStart.AllSpells = 0
+PlayerStart.MapsExplored = 0
+MusicInBattleground = 0
+HonorPointsAfterDuel = 0
+AlwaysMaxWeaponSkill = 0
+PvPToken.Enable = 0
+PvPToken.MapAllowType = 4
+PvPToken.ItemID = 29434
+PvPToken.ItemCount = 1
+NoResetTalentsCost = 0
+ShowKickInWorld = 0
+RecordUpdateTimeDiffInterval = 60000
+MinRecordUpdateTimeDiff = 10
+PlayerStart.String = ""
